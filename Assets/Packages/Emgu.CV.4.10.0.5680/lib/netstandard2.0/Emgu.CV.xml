<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emgu.CV</name>
    </assembly>
    <members>
        <member name="T:Emgu.CV.Affine3d">
            <summary>
            The Affine3 matrix, double precision. 
            </summary>
        </member>
        <member name="M:Emgu.CV.Affine3d.#ctor">
            <summary>
            Create an empty Affine3, double precision matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.Affine3d.Identity">
            <summary>
            Create a new identity matrix
            </summary>
            <returns>The identity affine 3d matrix</returns>
        </member>
        <member name="M:Emgu.CV.Affine3d.Rotate(System.Double,System.Double,System.Double)">
            <summary>
            Rotate the Affine3 matrix by a Rodrigues vector
            </summary>
            <param name="r0">Value of the Rodrigues vector</param>
            <param name="r1">Value of the Rodrigues vector</param>
            <param name="r2">Value of the Rodrigues vector</param>
            <returns>The rotated Affine3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.Affine3d.Translate(System.Double,System.Double,System.Double)">
            <summary>
            Translate the Affine3 matrix by the given value
            </summary>
            <param name="t0">Value of the translation vector</param>
            <param name="t1">Value of the translation vector</param>
            <param name="t2">Value of the translation vector</param>
            <returns>The translated Affine3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.Affine3d.GetValues">
            <summary>
            Get the 3x3 matrix's value as a double vector (of size 9)
            </summary>
            <returns>The 3x3 matrix's value as a double vector (of size 9)</returns>
        </member>
        <member name="M:Emgu.CV.Affine3d.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Affine3 model
            </summary>
        </member>
        <member name="T:Emgu.CV.CvInvoke">
            <summary>
            Class that provide access to native OpenCV functions
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveInputArrayRelease(System.IntPtr@)">
            <summary>
            Release the InputArray
            </summary>
            <param name="arr">Pointer to the input array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveInputOutputArrayRelease(System.IntPtr@)">
            <summary>
            Release the input / output array
            </summary>
            <param name="arr">Pointer to the input output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveOutputArrayRelease(System.IntPtr@)">
            <summary>
            Release the input / output array
            </summary>
            <param name="arr">Pointer to the input / output array</param>
        </member>
        <member name="P:Emgu.CV.CvInvoke.Backends">
            <summary>
            Returns list of all built-in backends
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.CameraBackends">
            <summary>
            Returns list of available backends which works via cv::VideoCapture(int index)
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.StreamBackends">
            <summary>
            Returns list of available backends which works via cv::VideoCapture(filename)
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.WriterBackends">
            <summary>
            Returns list of available backends which works via cv::VideoWriter()
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoWriterCreate(System.IntPtr,System.Int32,System.Double,System.Drawing.Size@,System.Boolean)">
            <summary>
            Creates video writer structure.
            </summary>
            <param name="filename">Name of the output video file.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.</param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames.</param>
            <param name="isColor">If != 0, the encoder will expect and encode color frames, otherwise it will work with grayscale frames </param>
            <returns>The video writer</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoWriterRelease(System.IntPtr@)">
            <summary>
            Finishes writing to video file and releases the structure.
            </summary>
            <param name="writer">pointer to video file writer structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoWriterWrite(System.IntPtr,System.IntPtr)">
            <summary>
            Writes/appends one frame to video file.
            </summary>
            <param name="writer">video writer structure.</param>
            <param name="image">the written frame</param>
            <returns>True on success, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Init">
            <summary>
            Check to make sure all the unmanaged libraries are loaded
            </summary>
            <returns>True if library loaded</returns>
        </member>
        <member name="F:Emgu.CV.CvInvoke.StringMarshalType">
            <summary>
            string marshaling type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.BoolMarshalType">
            <summary>
            Represent a bool value in C++
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.BoolToIntMarshalType">
            <summary>
            Represent a int value in C++
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvCallingConvention">
            <summary>
            Opencv's calling convention
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LoadUnmanagedModules(System.String,System.String[])">
            <summary>
            Attempts to load opencv modules from the specific location
            </summary>
            <param name="loadDirectory">The directory where the unmanaged modules will be loaded. If it is null, the default location will be used.</param>
            <param name="unmanagedModules">The names of opencv modules. e.g. "opencv_core.dll" on windows.</param>
            <returns>True if all the modules has been loaded successfully</returns>
            <remarks>If <paramref name="loadDirectory"/> is null, the default location on windows is the dll's path appended by either "x64" or "x86", depends on the applications current mode.</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetModuleFormatString">
            <summary>
            Get the module format string.
            </summary>
            <returns>On Windows, "{0}".dll will be returned; On Linux, "lib{0}.so" will be returned; Otherwise {0} is returned.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DefaultLoadUnmanagedModules(System.String[],System.String)">
            <summary>
            Attempts to load opencv modules from the specific location
            </summary>
            <param name="modules">The names of opencv modules. e.g. "opencv_core.dll" on windows.</param>
            <param name="loadDirectory">The path to load the opencv modules. If null, will use the default path.</param>
            <returns>True if all the modules has been loaded successfully</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.#cctor">
            <summary>
            Static Constructor to setup opencv environment
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDepthType(Emgu.CV.CvEnum.DepthType)">
            <summary>
            Get the corresponding depth type
            </summary>
            <param name="t">The opencv depth type</param>
            <returns>The equivalent depth type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDepthType(System.Type)">
            <summary>
            Get the corresponding opencv depth type
            </summary>
            <param name="t">The element type</param>
            <returns>The equivalent opencv depth type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MakeType(Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            This function performs the same as MakeType macro
            </summary>
            <param name="depth">The type of depth</param>
            <param name="channels">The number of channels</param>
            <returns>An integer that represent a mat type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SanityCheck">
            <summary>
            Check if the size of the C structures match those of C#
            </summary>
            <returns>True if the size matches</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindHomography(System.Drawing.PointF[],System.Drawing.PointF[],Emgu.CV.CvEnum.RobustEstimationAlgorithm,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Finds perspective transformation H=||h_ij|| between the source and the destination planes
            </summary>
            <param name="srcPoints">Point coordinates in the original plane</param>
            <param name="dstPoints">Point coordinates in the destination plane</param>
            <param name="method">FindHomography method</param>
            <param name="ransacReprojThreshold">
            The maximum allowed reprojection error to treat a point pair as an inlier. 
            The parameter is only used in RANSAC-based homography estimation. 
            E.g. if dst_points coordinates are measured in pixels with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3
            </param>
            <param name="mask">Optional output mask set by a robust method ( CV_RANSAC or CV_LMEDS ). Note that the input mask values are ignored.</param>
            <returns>The 3x3 homography matrix if found. Null if not found.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindHomography(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.RobustEstimationAlgorithm,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Finds perspective transformation H=||hij|| between the source and the destination planes
            </summary>
            <param name="srcPoints">Point coordinates in the original plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogeneous coordinates), where N is the number of points. </param>
            <param name="dstPoints">Point coordinates in the destination plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogeneous coordinates) </param>
            <param name="method">The type of the method</param>
            <param name="ransacReprojThreshold">The maximum allowed re-projection error to treat a point pair as an inlier. The parameter is only used in RANSAC-based homography estimation. E.g. if dst_points coordinates are measured in pixels with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3</param>
            <param name="mask">The optional output mask set by a robust method (RANSAC or LMEDS). </param>
            <returns>Output 3x3 homography matrix. Homography matrix is determined up to a scale, thus it is normalized to make h33=1</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Rodrigues(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Converts a rotation vector to rotation matrix or vice versa. Rotation vector is a compact representation of rotation matrix. Direction of the rotation vector is the rotation axis and the length of the vector is the rotation angle around the axis. 
            </summary>
            <param name="src">The input rotation vector (3x1 or 1x3) or rotation matrix (3x3). </param>
            <param name="dst">The output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9 or 9x3 - partial derivatives of the output array components w.r.t the input array components</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindEssentialMat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.FmType,System.Double,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Calculates an essential matrix from the corresponding points in two images.
            </summary>
            <param name="points1">Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1</param>
            <param name="cameraMatrix">Camera matrix K=[[fx 0 cx][0 fy cy][0 0 1]]. Note that this function assumes that points1 and points2 are feature points from cameras with the same camera matrix.</param>
            <param name="method">Method for computing a fundamental matrix. RANSAC for the RANSAC algorithm. LMEDS for the LMedS algorithm</param>
            <param name="prob">Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="threshold">Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="mask">Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods.</param>
            <returns>The essential mat</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindFundamentalMat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.FmType,System.Double,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Calculates fundamental matrix using one of four methods listed above and returns the number of fundamental matrices found (1 or 3) and 0, if no matrix is found. 
            </summary>
            <param name="points1">Array of N points from the first image. The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1 </param>
            <param name="method">Method for computing the fundamental matrix </param>
            <param name="param1">Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="param2">Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="mask">The optional pointer to output array of N elements, every element of which is set to 0 for outliers and to 1 for the "inliers", i.e. points that comply well with the estimated epipolar geometry. The array is computed only in RANSAC and LMedS methods. For other methods it is set to all 1.</param>
            <returns>The calculated fundamental matrix </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ComputeCorrespondEpilines(Emgu.CV.IInputArray,System.Int32,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            For every point in one of the two images of stereo-pair the function cvComputeCorrespondEpilines finds equation of a line that contains the corresponding point (i.e. projection of the same 3D point) in the other image. Each line is encoded by a vector of 3 elements l=[a,b,c]^T, so that: 
            l^T*[x, y, 1]^T=0, or
            a*x + b*y + c = 0
            From the fundamental matrix definition (see cvFindFundamentalMatrix discussion), line l2 for a point p1 in the first image (which_image=1) can be computed as: 
            l2=F*p1 and the line l1 for a point p2 in the second image (which_image=1) can be computed as: 
            l1=F^T*p2Line coefficients are defined up to a scale. They are normalized (a2+b2=1) are stored into correspondent_lines
            </summary>
            <param name="points">The input points. 2xN, Nx2, 3xN or Nx3 array (where N number of points). Multi-channel 1xN or Nx1 array is also acceptable.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points</param>
            <param name="fundamentalMatrix">Fundamental matrix </param>
            <param name="correspondentLines">Computed epilines, 3xN or Nx3 array </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertPointsToHomogeneous(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Converts points from Euclidean to homogeneous space.
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N+1-dimensional points.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertPointsFromHomogeneous(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Converts points from homogeneous to Euclidean space.
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N-1-dimensional points.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ReprojectImageTo3D(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Boolean,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Transforms 1-channel disparity map to 3-channel image, a 3D surface.
            </summary>
            <param name="disparity">Disparity map</param>
            <param name="image3D">3-channel, 16-bit integer or 32-bit floating-point image - the output map of 3D points</param>
            <param name="q">The reprojection 4x4 matrix, can be arbitrary, e.g. the one, computed by cvStereoRectify</param>
            <param name="handleMissingValues">Indicates, whether the function should handle missing values (i.e. points where the disparity was not computed). 
            If handleMissingValues=true, then pixels with the minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) 
            are transformed to 3D points with a very large Z value (currently set to 10000).</param>
            <param name="ddepth">The optional output array depth. If it is -1, the output image will have CV_32F depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetOptimalNewCameraMatrix(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,System.Double,System.Drawing.Size,System.Drawing.Rectangle@,System.Boolean)">
            <summary>
            Returns the new camera matrix based on the free scaling parameter.
            </summary>
            <param name="cameraMatrix">	Input camera matrix.</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,?x,?y]]]]) of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</param>
            <param name="imageSize">Original image size.</param>
            <param name="alpha">Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) and 1 (when all the source image pixels are retained in the undistorted image).</param>
            <param name="newImgSize">Image size after rectification. By default,it is set to imageSize .</param>
            <param name="validPixROI">output rectangle that outlines all-good-pixels region in the undistorted image. </param>
            <param name="centerPrincipalPoint">indicates whether in the new camera matrix the principal point should be at the image center or not. By default, the principal point is chosen to best fit a subset of the source image (determined by alpha) to the corrected image.</param>
            <returns>The new camera matrix based on the free scaling parameter.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InitCameraMatrix2D(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IInputArrayOfArrays,System.Drawing.Size,System.Double)">
            <summary>
            Finds an initial camera matrix from 3D-2D point correspondences.
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points in the calibration pattern coordinate space.</param>
            <param name="imagePoints">Vector of vectors of the projections of the calibration pattern points.</param>
            <param name="imageSize">Image size in pixels used to initialize the principal point.</param>
            <param name="aspectRatio">If it is zero or negative, both fx and fy are estimated independently. Otherwise, fx=fy*aspectRatio.</param>
            <returns>An initial camera matrix for the camera calibration process.</returns>
            <remarks>Currently, the function only supports planar calibration patterns, which are patterns where each object point has z-coordinate =0.</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ProjectPoints(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. 
            Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. 
            The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. 
            The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters. 
            </summary>
            <remarks>Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points) </remarks>
            <param name="objectPoints">The array of object points.</param>
            <param name="rvec">The rotation vector, 1x3 or 3x1</param>
            <param name="tvec">The translation vector, 1x3 or 3x1</param>
            <param name="cameraMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's</param>
            <returns>The output array of image points, 2xN or Nx2, where N is the total number of points in the view</returns>
            <param name="aspectRatio">Aspect ratio</param>
            <param name="jacobian">Optional output 2Nx(10+&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image points with respect to components of the rotation vector, translation vector, focal lengths, coordinates of the principal point and the distortion coefficients. In the old interface different components of the jacobian are returned via different output parameters.</param>
            <returns>The array of image points which is the projection of <paramref name="objectPoints"/></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ProjectPoints(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters.
            Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points). 
            </summary>
            <param name="objectPoints">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="rvec">The rotation vector, 1x3 or 3x1</param>
            <param name="tvec">The translation vector, 1x3 or 3x1</param>
            <param name="cameraMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's</param>
            <param name="imagePoints">The output array of image points, 2xN or Nx2, where N is the total number of points in the view</param>
            <param name="aspectRatio">Aspect ratio</param>
            <param name="jacobian">Optional output 2Nx(10+&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image points with respect to components of the rotation vector, translation vector, focal lengths, coordinates of the principal point and the distortion coefficients. In the old interface different components of the jacobian are returned via different output parameters.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalibrateCamera(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.Size,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.Mat[]@,Emgu.CV.Mat[]@)">
            <summary>
            Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.
            </summary>
            <param name="objectPoints">
            In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space.
            The outer vector contains as many elements as the number of pattern views. If the same calibration pattern is shown in each
            view and it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns
            or even different patterns in different views. Then, the vectors will be different. Although the points are 3D, they all
            lie in the calibration pattern's XY coordinate plane (thus 0 in the Z-coordinate), if the used calibration pattern is a
            planar rig. In the old interface all the vectors of object points from different views are concatenated together.
            </param>
            <param name="imagePoints">
            In the new interface it is a vector of vectors of the projections of calibration pattern points.
            In the old interface all the vectors of object points from different views are concatenated together.
            </param>
            <param name="imageSize">Size of the image used only to initialize the camera intrinsic matrix.</param>
            <param name="rotationVectors">
            Output vector of rotation vectors (Rodrigues) estimated for each pattern view. That is, each i-th rotation vector together
            with the corresponding i-th translation vector (see the next output parameter description) brings the calibration pattern from
            the object coordinate space (in which object points are specified) to the camera coordinate space. In more technical terms,
            the tuple of the i-th rotation and translation vector performs a change of basis from object coordinate space to camera
            coordinate space. Due to its duality, this tuple is equivalent to the position of the calibration pattern with respect to the
            camera coordinate space.
            </param>
            <param name="calibrationType">The camera calibration flags.</param>
            <param name="translationVectors">Output vector of translation vectors estimated for each pattern view, see parameter describtion above.</param>
            <param name="termCriteria">The termination criteria</param>
            <param name="cameraMatrix">Input/output 3x3 floating-point camera intrinsic matrix A [fx 0 cx; 0 fy cy; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATION are specified, some or all of fx, fy, cx, cy must be initialized</param>
            <param name="distortionCoeffs">Input/output vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τx,τy]]]]) of 4, 5, 8, 12 or 14 elements.</param>
            <returns>The final reprojection error</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalibrateCamera(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.
            </summary>
            <param name="objectPoints">
            In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space.
            The outer vector contains as many elements as the number of pattern views. If the same calibration pattern is shown in each
            view and it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns
            or even different patterns in different views. Then, the vectors will be different. Although the points are 3D, they all
            lie in the calibration pattern's XY coordinate plane (thus 0 in the Z-coordinate), if the used calibration pattern is a
            planar rig. In the old interface all the vectors of object points from different views are concatenated together.
            </param>
            <param name="imagePoints">
            In the new interface it is a vector of vectors of the projections of calibration pattern points.
            In the old interface all the vectors of object points from different views are concatenated together.
            </param>
            <param name="imageSize">Size of the image used only to initialize the camera intrinsic matrix.</param>
            <param name="cameraMatrix">Input/output 3x3 floating-point camera intrinsic matrix A [fx 0 cx; 0 fy cy; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATION are specified, some or all of fx, fy, cx, cy must be initialized</param>
            <param name="distortionCoeffs">Input/output vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τx,τy]]]]) of 4, 5, 8, 12 or 14 elements.</param>
            <param name="rotationVectors">
            Output vector of rotation vectors (Rodrigues) estimated for each pattern view. That is, each i-th rotation vector together
            with the corresponding i-th translation vector (see the next output parameter description) brings the calibration pattern from
            the object coordinate space (in which object points are specified) to the camera coordinate space. In more technical terms,
            the tuple of the i-th rotation and translation vector performs a change of basis from object coordinate space to camera
            coordinate space. Due to its duality, this tuple is equivalent to the position of the calibration pattern with respect to the
            camera coordinate space.
            </param>
            <param name="translationVectors">Output vector of translation vectors estimated for each pattern view, see parameter describtion above.</param>
            <param name="flags">Different flags</param>
            <param name="termCriteria">The termination criteria</param>
            <returns>The final reprojection error</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalibrationMatrixValues(Emgu.CV.IInputArray,System.Drawing.Size,System.Double,System.Double,System.Double@,System.Double@,System.Double@,Emgu.CV.Structure.MCvPoint2D64f@,System.Double@)">
            <summary>
            Computes various useful camera (sensor/lens) characteristics using the computed camera calibration matrix, image frame resolution in pixels and the physical aperture size
            </summary>
            <param name="cameraMatrix">The matrix of intrinsic parameters</param>
            <param name="imageSize">Image size in pixels</param>
            <param name="apertureWidth">Aperture width in real-world units (optional input parameter). Set it to 0 if not used</param>
            <param name="apertureHeight">Aperture width in real-world units (optional input parameter). Set it to 0 if not used</param>
            <param name="fovx">Field of view angle in x direction in degrees</param>
            <param name="fovy">Field of view angle in y direction in degrees </param>
            <param name="focalLength">Focal length in real-world units </param>
            <param name="principalPoint">The principal point in real-world units </param>
            <param name="aspectRatio">The pixel aspect ratio ~ fy/f</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnP(Emgu.CV.Structure.MCvPoint3D32f[],System.Drawing.PointF[],Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Estimates extrinsic camera parameters using known intrinsic parameters and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error. 
            </summary>
            <param name="objectPoints">The array of object points</param>
            <param name="imagePoints">The array of corresponding image points</param>
            <param name="intrinsicMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's.</param>
            <param name="rotationVector">The output 3x1 or 1x3 rotation vector (compact representation of a rotation matrix, see cvRodrigues2). </param>
            <param name="translationVector">The output 3x1 or 1x3 translation vector</param>
            <param name="useExtrinsicGuess">Use the input rotation and translation parameters as a guess</param>
            <param name="method">Method for solving a PnP problem</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnP(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Estimates extrinsic camera parameters using known intrinsic parameters and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error
            </summary>
            <param name="objectPoints">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="imagePoints">The array of corresponding image points, 2xN or Nx2, where N is the number of points in the view</param>
            <param name="intrinsicMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's.</param>
            <param name="rotationVector">The output 3x1 or 1x3 rotation vector (compact representation of a rotation matrix, see cvRodrigues2). </param>
            <param name="translationVector">The output 3x1 or 1x3 translation vector</param>
            <param name="useExtrinsicGuess">Use the input rotation and translation parameters as a guess</param>
            <param name="flags">Method for solving a PnP problem</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnPRansac(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,System.Int32,System.Single,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. VectorOfPoint3D32f can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. VectorOfPointF can be also passed here.</param>
            <param name="cameraMatrix">Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients of 4, 5, 8 or 12 elements. If the vector is null/empty, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector </param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="iterationsCount">Number of iterations.</param>
            <param name="reprojectionError">Inlier threshold value used by the RANSAC procedure. The parameter value is the maximum allowed distance between the observed and computed point projections to consider it an inlier.</param>
            <param name="confident">The probability that the algorithm produces a useful result.</param>
            <param name="inliers">Output vector that contains indices of inliers in objectPoints and imagePoints .</param>
            <param name="flags">Method for solving a PnP problem </param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolveP3P(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Finds an object pose from 3 3D-2D point correspondences.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3x3 1-channel or 1x3/3x1 3-channel. VectorOfPoint3f can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 3x2 1-channel or 1x3/3x1 2-channel. VectorOfPoint2f can be also passed here.</param>
            <param name="cameraMatrix">Input camera matrix A=[[fx 0 0] [0 fy 0] [cx cy 1]] .</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τx,τy]]]]) of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</param>
            <param name="rvecs">Output rotation vectors (see Rodrigues ) that, together with tvecs , brings points from the model coordinate system to the camera coordinate system. A P3P problem has up to 4 solutions.</param>
            <param name="tvecs">Output translation vectors.</param>
            <param name="flags">Method for solving a P3P problem: either P3P or AP3P</param>
            <returns>Number of solutions</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnPRefineLM(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. VectorOfPoint3f can also be passed here.</param>
            <param name="imagePoints">Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. VectorOfPoint2f can also be passed here.</param>
            <param name="cameraMatrix">Input camera matrix A=[[fx,0,0],[0,fy,0][cx,cy,1]].</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τx,τy]]]]) of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Input/Output rotation vector (see Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</param>
            <param name="tvec">Input/Output translation vector. Input values are used as an initial solution.</param>
            <param name="criteria">Criteria when to stop the Levenberg-Marquard iterative algorithm.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnPRefineVVS(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvTermCriteria,System.Double)">
            <summary>
            Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. VectorOfPoint3f can also be passed here.</param>
            <param name="imagePoints">Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. VectorOfPoint2f can also be passed here.</param>
            <param name="cameraMatrix">Input camera matrix A=[[fx,0,0],[0,fy,0][cx,cy,1]].</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τx,τy]]]]) of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Input/Output rotation vector (see Rodrigues ) that, together with tvec, brings points from the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</param>
            <param name="tvec">Input/Output translation vector. Input values are used as an initial solution.</param>
            <param name="criteria">Criteria when to stop the Levenberg-Marquard iterative algorithm.</param>
            <param name="VVSlambda">Gain for the virtual visual servoing control law, equivalent to the α gain in the Damped Gauss-Newton formulation.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnPGeneric(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArrayOfArrays,System.Boolean,Emgu.CV.CvEnum.SolvePnpMethod,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Finds an object pose from 3D-2D point correspondences. 
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. VectorOfPoint3f can also be passed here.</param>
            <param name="imagePoints">Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. VectorOfPoint2f can also be passed here.</param>
            <param name="cameraMatrix">Input camera matrix A=[[fx,0,0],[0,fy,0][cx,cy,1]].</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τx,τy]]]]) of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</param>
            <param name="rvecs">Vector of output rotation vectors (see Rodrigues ) that, together with tvecs, brings points from the model coordinate system to the camera coordinate system.</param>
            <param name="tvecs">Vector of output translation vectors.</param>
            <param name="useExtrinsicGuess">Parameter used for SolvePnpMethod.Iterative. If true, the function uses the provided rvec and tvec values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="flags">Method for solving a PnP problem</param>
            <param name="rvec">Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is SOLVEPNP_ITERATIVE and useExtrinsicGuess is set to true.</param>
            <param name="tvec">Translation vector used to initialize an iterative PnP refinement algorithm, when flag is SOLVEPNP_ITERATIVE and useExtrinsicGuess is set to true.</param>
            <param name="reprojectionError">Optional vector of reprojection error, that is the RMS error between the input image points and the 3D object points projected with the estimated pose.</param>
            <returns>The number of solutions</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoCalibrate(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.PointF[][],Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the first camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints1">The 2D image location of the points for camera 1. The first index is the index of the image, second index is the index of the point</param>
            <param name="imagePoints2">The 2D image location of the points for camera 2. The first index is the index of the image, second index is the index of the point</param>
            <param name="cameraMatrix1">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs1">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="cameraMatrix2">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs2">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="r">The rotation matrix between the 1st and the 2nd cameras' coordinate systems </param>
            <param name="t">The translation vector between the cameras' coordinate systems</param>
            <param name="e">The optional output essential matrix</param>
            <param name="f">The optional output fundamental matrix </param>
            <param name="termCrit">Termination criteria for the iterative optimization algorithm</param>
            <param name="flags">The calibration flags</param>
            <returns>The final value of the re-projection error.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoCalibrate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the first camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints1">The 2D image location of the points for camera 1. The first index is the index of the image, second index is the index of the point</param>
            <param name="imagePoints2">The 2D image location of the points for camera 2. The first index is the index of the image, second index is the index of the point</param>
            <param name="cameraMatrix1">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs1">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="cameraMatrix2">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs2">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="r">Output rotation matrix. Together with the translation vector T, this matrix brings points given in the first camera's coordinate system to points in the second camera's coordinate system. In more technical terms, the tuple of R and T performs a change of basis from the first camera's coordinate system to the second camera's coordinate system. Due to its duality, this tuple is equivalent to the position of the first camera with respect to the second camera coordinate system.</param>
            <param name="t">Output translation vector, see description for "r".</param>
            <param name="e">The optional output essential matrix</param>
            <param name="f">The optional output fundamental matrix </param>
            <param name="rvecs">Output vector of rotation vectors ( Rodrigues ) estimated for each pattern view in the coordinate system of the first camera of the stereo pair (e.g. std::vector &lt; cv::Mat &gt;). More in detail, each i-th rotation vector together with the corresponding i-th translation vector (see the next output parameter description) brings the calibration pattern from the object coordinate space (in which object points are specified) to the camera coordinate space of the first camera of the stereo pair. In more technical terms, the tuple of the i-th rotation and translation vector performs a change of basis from object coordinate space to camera coordinate space of the first camera of the stereo pair.</param>
            <param name="tvecs">Output vector of translation vectors estimated for each pattern view, see parameter description of previous output parameter ( rvecs ).</param>
            <param name="perViewErrors">Output vector of the RMS re-projection error estimated for each pattern view.</param>
            <param name="termCrit">Termination criteria for the iterative optimization algorithm</param>
            <param name="flags">The calibration flags</param>
            <returns>The final value of the re-projection error.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoCalibrate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the fist camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The joint matrix of object points, 3xN or Nx3, where N is the total number of points in all views</param>
            <param name="imagePoints1">The joint matrix of corresponding image points in the views from the 1st camera, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="imagePoints2">The joint matrix of corresponding image points in the views from the 2nd camera, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="cameraMatrix1">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs1">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="cameraMatrix2">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs2">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="r">The rotation matrix between the 1st and the 2nd cameras' coordinate systems </param>
            <param name="t">The translation vector between the cameras' coordinate systems</param>
            <param name="e">The optional output essential matrix</param>
            <param name="f">The optional output fundamental matrix </param>
            <param name="termCrit">Termination criteria for the iterative optimization algorithm</param>
            <param name="flags">The calibration flags</param>
            <returns>The final value of the re-projection error.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoRectifyUncalibrated(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in space, hence the suffix "Uncalibrated". Another related difference from cvStereoRectify is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations, encoded by the homography matrices H1 and H2. The function implements the following algorithm [Hartley99]. 
            </summary>
            <remarks>
            Note that while the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have significant distortion, it would better be corrected before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using cvCalibrateCamera2 and then the images can be corrected using cvUndistort2
            </remarks>
            <param name="points1">The array of 2D points</param>
            <param name="points2">The array of 2D points</param>
            <param name="f">Fundamental matrix. It can be computed using the same set of point pairs points1 and points2 using cvFindFundamentalMat</param>
            <param name="imgSize">Size of the image</param>
            <param name="h1">The rectification homography matrices for the first images</param>
            <param name="h2">The rectification homography matrices for the second images</param>
            <param name="threshold">If the parameter is greater than zero, then all the point pairs that do not comply the epipolar geometry well enough (that is, the points for which fabs(points2[i]T*F*points1[i])&gt;threshold) are rejected prior to computing the homographies</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoRectify(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.StereoRectifyType,System.Double,System.Drawing.Size,System.Drawing.Rectangle@,System.Drawing.Rectangle@)">
            <summary>
            computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, that makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. On input the function takes the matrices computed by cvStereoCalibrate and on output it gives 2 rotation matrices and also 2 projection matrices in the new coordinates. The function is normally called after cvStereoCalibrate that computes both camera matrices, the distortion coefficients, R and T
            </summary>
            <param name="cameraMatrix1">The camera matrices [fx_k 0 cx_k; 0 fy_k cy_k; 0 0 1]</param>
            <param name="cameraMatrix2">The camera matrices [fx_k 0 cx_k; 0 fy_k cy_k; 0 0 1]</param>
            <param name="distCoeffs1">The vectors of distortion coefficients for first camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="distCoeffs2">The vectors of distortion coefficients for second camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image used for stereo calibration</param>
            <param name="r">The rotation matrix between the 1st and the 2nd cameras' coordinate systems</param>
            <param name="t">The translation vector between the cameras' coordinate systems</param>
            <param name="r1">3x3 Rectification transforms (rotation matrices) for the first camera</param>
            <param name="r2">3x3 Rectification transforms (rotation matrices) for the second camera</param>
            <param name="p1">3x4 Projection matrices in the new (rectified) coordinate systems</param>
            <param name="p2">3x4 Projection matrices in the new (rectified) coordinate systems</param>
            <param name="q">The optional output disparity-to-depth mapping matrix, 4x4, see cvReprojectImageTo3D. </param>
            <param name="flags">The operation flags, use ZeroDisparity for default</param>
            <param name="alpha">Use -1 for default</param>
            <param name="newImageSize">Use Size.Empty for default</param>
            <param name="validPixRoi1">The valid pixel ROI for image1</param>
            <param name="validPixRoi2">The valid pixel ROI for image2</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Find4QuadCornerSubpix(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size)">
            <summary>
            Finds subpixel-accurate positions of the chessboard corners
            </summary>
            <param name="image">Source chessboard view; it must be 8-bit grayscale or color image</param>
            <param name="corners">Pointer to the output array of corners(PointF) detected</param>
            <param name="regionSize">region size</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindChessboardCorners(Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibCbType)">
            <summary>
            Attempts to determine whether the input image is a view of the chessboard pattern and locate internal chessboard corners
            </summary>
            <param name="image">Source chessboard view; it must be 8-bit grayscale or color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">Pointer to the output array of corners(PointF) detected</param>
            <param name="flags">Various operation flags</param>
            <returns>True if all the corners have been found and they have been placed in a certain order (row by row, left to right in every row), otherwise, if the function fails to find all the corners or reorder them, it returns 0</returns>
            <remarks>The coordinates detected are approximate, and to determine their position more accurately, the user may use the function cvFindCornerSubPix</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FilterSpeckles(Emgu.CV.IInputOutputArray,System.Double,System.Int32,System.Double,Emgu.CV.IInputOutputArray)">
            <summary>
            Filters off small noise blobs (speckles) in the disparity map.
            </summary>
            <param name="img">The input 16-bit signed disparity image</param>
            <param name="newVal">The disparity value used to paint-off the speckles</param>
            <param name="maxSpeckleSize">The maximum speckle size to consider it a speckle. Larger blobs are not affected by the algorithm</param>
            <param name="maxDiff">Maximum difference between neighbor disparity pixels to put them into the same blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point disparity map, where disparity values are multiplied by 16, this scale factor should be taken into account when specifying this parameter value.</param>
            <param name="buf">The optional temporary buffer to avoid memory allocation within the function.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindChessboardCornersSB(Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibCbType)">
            <summary>
            Finds the positions of internal corners of the chessboard using a sector based approach.
            </summary>
            <param name="image">Source chessboard view. It must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).</param>
            <param name="corners">Output array of detected corners.</param>
            <param name="flags">Various operation flags</param>
            <returns>True if chessboard corners found</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DrawChessboardCorners(Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Draws the individual chessboard corners detected (as red circles) in case if the board was not found (pattern_was_found=0) or the colored corners connected with lines when the board was found (pattern_was_found != 0). 
            </summary>
            <param name="image">The destination image; it must be 8-bit color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">The array of corners detected</param>
            <param name="patternWasFound">Indicates whether the complete board was found (!=0) or not (=0). One may just pass the return value cvFindChessboardCorners here. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.TriangulatePoints(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Reconstructs points by triangulation.
            </summary>
            <param name="projMat1">3x4 projection matrix of the first camera.</param>
            <param name="projMat2">3x4 projection matrix of the second camera.</param>
            <param name="projPoints1">2xN array of feature points in the first image. It can be also a vector of feature points or two-channel matrix of size 1xN or Nx1</param>
            <param name="projPoints2">2xN array of corresponding points in the second image. It can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <param name="points4D">4xN array of reconstructed points in homogeneous coordinates.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CorrectMatches(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Refines coordinates of corresponding points.
            </summary>
            <param name="f">3x3 fundamental matrix.</param>
            <param name="points1">1xN array containing the first set of points.</param>
            <param name="points2">1xN array containing the second set of points.</param>
            <param name="newPoints1">The optimized points1.</param>
            <param name="newPoints2">The optimized points2.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateChessboardSharpness(Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputArray,System.Single,System.Boolean,Emgu.CV.IOutputArray)">
            <summary>
            Estimates the sharpness of a detected chessboard.
            Image sharpness, as well as brightness, are a critical parameter for accuracte camera calibration. For accessing these parameters for filtering out problematic calibraiton images, this method calculates edge profiles by traveling from black to white chessboard cell centers. Based on this, the number of pixels is calculated required to transit from black to white. This width of the transition area is a good indication of how sharp the chessboard is imaged and should be below ~3.0 pixels.
            </summary>
            <param name="image">Gray image used to find chessboard corners</param>
            <param name="patternSize">Size of a found chessboard pattern</param>
            <param name="corners">Corners found by findChessboardCorners(SB)</param>
            <param name="riseDistance">Rise distance 0.8 means 10% ... 90% of the final signal strength</param>
            <param name="vertical">By default edge responses for horizontal lines are calculated</param>
            <param name="sharpness">Optional output array with a sharpness value for calculated edge responses</param>
            <returns>Scalar(average sharpness, average min brightness, average max brightness,0)</returns>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvErrorHandlerThrowException">
            <summary>
            The default Exception callback to handle Error thrown by OpenCV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvErrorHandlerIgnoreError">
            <summary>
            An error handler which will ignore any error and continue
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvIgnoreErrorErrorHandler(System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            A custom error handler for OpenCV
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparently passed to the error handler.</param>
            <returns>if 0, signal the process to continue</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvErrorHandler(System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            A custom error handler for OpenCV
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparently passed to the error handler.</param>
            <returns>If 0, signal the process to continue</returns>
        </member>
        <member name="T:Emgu.CV.CvInvoke.CvErrorCallback">
            <summary>
            Define an error callback that can be registered using RedirectError function
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparently passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RedirectError(Emgu.CV.CvInvoke.CvErrorCallback,System.IntPtr,System.IntPtr)">
            <summary>
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </summary>
            <param name="errorHandler">The new error handler</param>
            <param name="userdata">Arbitrary pointer that is transparently passed to the error handler.</param>
            <param name="prevUserdata">Pointer to the previously assigned user data pointer.</param>
            <returns>Pointer to the old error handler</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RedirectError(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </summary>
            <param name="errorHandler">Pointer to the new error handler</param>
            <param name="userdata">Arbitrary pointer that is transparently passed to the error handler.</param>
            <param name="prevUserdata">Pointer to the previously assigned user data pointer.</param>
            <returns>Pointer to the old error handler</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetBreakOnError(System.Boolean)">
            <summary>
            When the break-on-error mode is set, the default error handler issues a hardware exception, which
            can make debugging more convenient.
            </summary>
            <param name="flag">The flag</param>
            <returns>The previous state</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetErrMode(System.Int32)">
            <summary>
            Sets the specified error mode.
            </summary>
            <param name="errorMode">The error mode</param>
            <returns>The previous error mode</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetErrMode">
            <summary>
            Returns the current error mode
            </summary>
            <returns>The error mode</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetErrStatus">
            <summary>
            Returns the current error status - the value set with the last cvSetErrStatus call. Note, that in Leaf mode the program terminates immediately after error occurred, so to always get control after the function call, one should call cvSetErrMode and set Parent or Silent error mode.
            </summary>
            <returns>The current error status</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetErrStatus(Emgu.CV.CvEnum.ErrorCodes)">
            <summary>
            Sets the error status to the specified value. Mostly, the function is used to reset the error status (set to it CV_StsOk) to recover after error. In other cases it is more natural to call cvError or CV_ERROR.
            </summary>
            <param name="code">The error status.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ErrorStr(System.Int32)">
            <summary>
            Returns the textual description for the specified error status code. In case of unknown status the function returns NULL pointer. 
            </summary>
            <param name="status">The error status</param>
            <returns>the textual description for the specified error status code.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.TempFile(System.String)">
            <summary>
            Get a temporary file name
            </summary>
            <param name="suffix">The suffix of the temporary file name</param>
            <returns>A temporary file name</returns>
        </member>
        <member name="P:Emgu.CV.CvInvoke.LogLevel">
            <summary>
            Get or Set the log level.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReshape(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            initializes CvMat header so that it points to the same data as the original array but has different shape - different number of channels, different number of rows or both
            </summary>
            <param name="arr">Input array</param>
            <param name="header">Output header to be filled</param>
            <param name="newCn">New number of channels. new_cn = 0 means that number of channels remains unchanged</param>
            <param name="newRows">New number of rows. new_rows = 0 means that number of rows remains unchanged unless it needs to be changed according to new_cn value. destination array to be changed</param>
            <returns>The CvMat header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Repeat(Emgu.CV.IInputArray,System.Int32,System.Int32,Emgu.CV.IOutputArray)">
            <summary>
            Fills the destination array with source array tiled:
            dst(i,j)=src(i mod rows(src), j mod cols(src))So the destination array may be as larger as well as smaller than the source array
            </summary>
            <param name="src">Source array, image or matrix</param>
            <param name="dst">Destination array, image or matrix</param>
            <param name="nx">Flag to specify how many times the src is repeated along the vertical axis.</param>
            <param name="ny">Flag to specify how many times the src is repeated along the horizontal axis.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Merge(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IOutputArray)">
            <summary>
            This function is the opposite to cvSplit. If the destination array has N channels then if the first N input channels are not IntPtr.Zero, all they are copied to the destination array, otherwise if only a single source channel of the first N is not IntPtr.Zero, this particular channel is copied into the destination array, otherwise an error is raised. Rest of source channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to insert a single channel into the image. 
            </summary>
            <param name="mv">Input vector of matrices to be merged; all the matrices in mv must have the same size and the same depth.</param>
            <param name="dst">output array of the same size and the same depth as mv[0]; The number of channels will be the total number of channels in the matrix array.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MixChannels(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IInputOutputArray,System.Int32[])">
            <summary>
            The function cvMixChannels is a generalized form of cvSplit and cvMerge and some forms of cvCvtColor. It can be used to change the order of the planes, add/remove alpha channel, extract or insert a single plane or multiple planes etc.
            </summary>
            <param name="src">The array of input arrays.</param>
            <param name="dst">The array of output arrays</param>
            <param name="fromTo">The array of pairs of indices of the planes copied. from_to[k*2] is the 0-based index of the input plane, and from_to[k*2+1] is the index of the output plane, where the continuous numbering of the planes over all the input and over all the output arrays is used. When from_to[k*2] is negative, the corresponding output plane is filled with 0's.</param>
            <remarks>Unlike many other new-style C++ functions in OpenCV, mixChannels requires the output arrays to be pre-allocated before calling the function.</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ExtractChannel(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Extract the specific channel from the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The channel</param>
            <param name="coi">0 based index of the channel to be extracted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InsertChannel(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Int32)">
            <summary>
            Insert the specific channel to the image
            </summary>
            <param name="src">The source channel</param>
            <param name="dst">The destination image where the channel will be inserted into</param>
            <param name="coi">0-based index of the channel to be inserted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RandShuffle(Emgu.CV.IInputOutputArray,System.Double,System.UInt64)">
            <summary>
            Shuffles the matrix by swapping randomly chosen pairs of the matrix elements on each iteration (where each element may contain several components in case of multi-channel arrays)
            </summary>
            <param name="mat">The input/output matrix. It is shuffled in-place. </param>
            <param name="rng">Pointer to MCvRNG random number generator. Use 0 if not sure</param>
            <param name="iterFactor">The relative parameter that characterizes intensity of the shuffling performed. The number of iterations (i.e. pairs swapped) is round(iter_factor*rows(mat)*cols(mat)), so iter_factor=0 means that no shuffling is done, iter_factor=1 means that the function swaps rows(mat)*cols(mat) random pairs etc</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseNot(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Inverses every bit of every array element:
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">The optional mask for the operation, use null to ignore</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Max(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates per-element maximum of two arrays:
            dst(I)=max(src1(I), src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. </param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HasNonZero(Emgu.CV.IInputArray)">
            <summary>
            Checks for the presence of at least one non-zero array element.
            </summary>
            <param name="arr">Single-channel array.</param>
            <returns>Whether there are non-zero elements in src</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CountNonZero(Emgu.CV.IInputArray)">
            <summary>
            Returns the number of non-zero elements in arr:
            result = sumI arr(I)!=0
            In case of IplImage both ROI and COI are supported.
            </summary>
            <param name="arr">The image</param>
            <returns>the number of non-zero elements in image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindNonZero(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Find the location of the non-zero pixel
            </summary>
            <param name="src">The source array</param>
            <param name="idx">The output array where the location of the pixels are sorted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PSNR(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Computes PSNR image/video quality metric
            </summary>
            <param name="src1">The first source image</param>
            <param name="src2">The second source image</param>
            <returns>the quality metric</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Min(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates per-element minimum of two arrays:
            dst(I)=min(src1(I),src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Add(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Adds one array to another one:
            dst(I)=src1(I)+src2(I) if mask(I)!=0All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="src2">The second source array.</param>
            <param name="dst">The destination array.</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed. </param>
            <param name="dtype">Optional depth type of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Subtract(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Subtracts one array from another one:
            dst(I)=src1(I)-src2(I) if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
            <param name="dtype">Optional depth of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Divide(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Divides one array by another:
            dst(I)=scale * src1(I)/src2(I), if src1!=IntPtr.Zero;
            dst(I)=scale/src2(I),      if src1==IntPtr.Zero;
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. If the pointer is IntPtr.Zero, the array is assumed to be all 1s. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor </param>
            <param name="dtype">Optional depth of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Multiply(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates per-element product of two arrays:
            dst(I)=scale*src1(I)*src2(I)
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor</param>
            <param name="dtype">Optional depth of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseAnd(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I) &amp; src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseOr(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates per-element bit-wise disjunction of two arrays:
            dst(I)=src1(I)|src2(I)
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseXor(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I)^src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Mask, 8-bit single channel array; specifies elements of destination array to be changed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCopy(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copies selected elements from input array to output array:
            dst(I)=src(I) if mask(I)!=0. 
            If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions and the same size. The function can also copy sparse arrays (mask is not supported in this case).
            </summary>
            <param name="src">The source array</param>
            <param name="des">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetIdentity(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Initializes scaled identity matrix:
            arr(i,j)=value if i=j,
            0 otherwise
            </summary>
            <param name="mat">The matrix to initialize (not necessarily square).</param>
            <param name="value">The value to assign to the diagonal elements.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRange(System.IntPtr,System.Double,System.Double)">
            <summary>
            Initializes the matrix as following:
            arr(i,j)=(end-start)*(i*cols(arr)+j)/(cols(arr)*rows(arr))
            </summary>
            <param name="mat">The matrix to initialize. It should be single-channel 32-bit, integer or floating-point</param>
            <param name="start">The lower inclusive boundary of the range</param>
            <param name="end">The upper exclusive boundary of the range</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CartToPolar(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Calculates the magnitude and angle of 2D vectors.
            magnitude(I)=sqrt( x(I)^2+y(I)^2 ),
            angle(I)=atan2( y(I)/x(I) ) 
            The angles are calculated with accuracy about 0.3 degrees. For the point (0,0), the angle is set to 0.
            </summary>
            <param name="x">Array of x-coordinates; this must be a single-precision or double-precision floating-point array.</param>
            <param name="y">Array of y-coordinates, that must have the same size and same type as x.</param>
            <param name="magnitude">Output array of magnitudes of the same size and type as x.</param>
            <param name="angle">Output array of angles that has the same size and type as x; the angles are measured in radians (from 0 to 2*Pi) or in degrees (0 to 360 degrees).</param>
            <param name="angleInDegrees">A flag, indicating whether the angles are measured in radians (which is by default), or in degrees.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PolarToCart(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Calculates either x-coordinate, y-coordinate or both of every vector magnitude(I)* exp(angle(I)*j), j=sqrt(-1):
            x(I)=magnitude(I)*cos(angle(I)),
            y(I)=magnitude(I)*sin(angle(I))
            </summary>
            <param name="magnitude">Input floating-point array of magnitudes of 2D vectors; it can be an empty matrix (=Mat()), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as angle</param>
            <param name="angle">input floating-point array of angles of 2D vectors.</param>
            <param name="x">Output array of x-coordinates of 2D vectors; it has the same size and type as angle.</param>
            <param name="y">Output array of y-coordinates of 2D vectors; it has the same size and type as angle.</param>
            <param name="angleInDegrees">The flag indicating whether the angles are measured in radians or in degrees</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Pow(Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Raises every element of input array to p:
            dst(I)=src(I)p, if p is integer
            dst(I)=abs(src(I))p, otherwise
            That is, for non-integer power exponent the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations, as the following sample, computing cube root of array elements, shows:
            CvSize size = cvGetSize(src);
            CvMat* mask = cvCreateMat( size.height, size.width, CV_8UC1 );
            cvCmpS( src, 0, mask, CV_CMP_LT ); /* find negative elements */
            cvPow( src, dst, 1./3 );
            cvSubRS( dst, cvScalarAll(0), dst, mask ); /* negate the results of negative inputs */
            cvReleaseMat( &amp;mask );
            For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used.
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, should be the same type as the source</param>
            <param name="power">The exponent of power</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Exp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            Maximum relative error is 7e-6. Currently, the function converts denormalized values to zeros on output
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Log(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates natural logarithm of absolute value of every element of input array:
            dst(I)=log(abs(src(I))), src(I)!=0
            dst(I)=C,  src(I)=0
            Where C is large negative number (-700 in the current implementation)
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolveCubic(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            finds real roots of a cubic equation:
            coeffs[0]*x^3 + coeffs[1]*x^2 + coeffs[2]*x + coeffs[3] = 0
            (if coeffs is 4-element vector)
            or
            x^3 + coeffs[0]*x^2 + coeffs[1]*x + coeffs[2] = 0
            (if coeffs is 3-element vector)
            </summary>
            <param name="coeffs">The equation coefficients, array of 3 or 4 elements</param>
            <param name="roots">The output array of real roots. Should have 3 elements. Padded with zeros if there is only one root</param>
            <returns>the number of real roots found</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePoly(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Finds all real and complex roots of any degree polynomial with real coefficients
            </summary>
            <param name="coeffs">The (degree + 1)-length array of equation coefficients (CV_32FC1 or CV_64FC1)</param>
            <param name="roots">The degree-length output array of real or complex roots (CV_32FC2 or CV_64FC2)</param>
            <param name="maxiter">The maximum number of iterations</param>
            <returns>The max difference.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Solve(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DecompMethod)">
            <summary>
            Solves linear system (src1)*(dst) = (src2)
            </summary>
            <param name="src1">The source matrix in the LHS</param>
            <param name="src2">The source matrix in the RHS</param>
            <param name="dst">The result</param>
            <param name="method">The method for solving the equation</param>
            <returns>0 if src1 is a singular and CV_LU method is used</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sort(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.SortFlags)">
            <summary>
            Sorts each matrix row or each matrix column in
            ascending or descending order.So you should pass two operation flags to
            get desired behaviour.
            </summary>
            <param name="src">input single-channel array.</param>
            <param name="dst">output array of the same size and type as src.</param>
            <param name="flags">operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SortIdx(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.SortFlags)">
            <summary>
            Sorts each matrix row or each matrix column in the
            ascending or descending order.So you should pass two operation flags to
            get desired behaviour. Instead of reordering the elements themselves, it
            stores the indices of sorted elements in the output array.
            </summary>
            <param name="src">input single-channel array.</param>
            <param name="dst">output integer array of the same size as src.</param>
            <param name="flags">operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Dft(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DxtType,System.Int32)">
            <summary>
            Performs forward or inverse transform of 1D or 2D floating-point array
            In case of real (single-channel) data, the packed format, borrowed from IPL, is used to to represent a result of forward Fourier transform or input for inverse Fourier transform
            </summary>
            <param name="src">Source array, real or complex</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
            <param name="nonzeroRows">Number of nonzero rows to in the source array (in case of forward 2d transform), or a number of rows of interest in the destination array (in case of inverse 2d transform). If the value is negative, zero, or greater than the total number of rows, it is ignored. The parameter can be used to speed up 2d convolution/correlation when computing them via DFT. See the sample below</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetOptimalDFTSize(System.Int32)">
            <summary>
            Returns the minimum number N that is greater to equal to size0, such that DFT of a vector of size N can be computed fast. In the current implementation N=2^p x 3^q x 5^r for some p, q, r. 
            </summary>
            <param name="vecsize">Vector size</param>
            <returns>The minimum number N that is greater to equal to size0, such that DFT of a vector of size N can be computed fast. In the current implementation N=2^p x 3^q x 5^r for some p, q, r. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MulSpectrums(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.MulSpectrumsType,System.Boolean)">
            <summary>
            Performs per-element multiplication of the two CCS-packed or complex matrices that are results of real or complex Fourier transform. 
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array of the same type and the same size of the sources</param>
            <param name="flags">Operation flags; currently, the only supported flag is DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum.</param>
            <param name="conjB">Optional flag that conjugates the second input array before the multiplication (true) or not (false).</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Dct(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DctType)">
            <summary>
            Performs forward or inverse transform of 1D or 2D floating-point array
            </summary>
            <param name="src">Source array, real 1D or 2D array</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ClipLine(System.Drawing.Rectangle,System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
            Calculates a part of the line segment which is entirely in the rectangle.
            </summary>
            <param name="rectangle">The rectangle</param>
            <param name="pt1">First ending point of the line segment. It is modified by the function</param>
            <param name="pt2">Second ending point of the line segment. It is modified by the function.</param>
            <returns>It returns false if the line segment is completely outside the rectangle and true otherwise.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AbsDiff(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates absolute difference between two arrays.
            dst(I)c = abs(src1(I)c - src2(I)c).
            All the arrays must have the same data type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ScaleAdd(Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates the sum of a scaled array and another array.
            </summary>
            <param name="src1">First input array</param>
            <param name="alpha">Scale factor for the first array</param>
            <param name="src2">Second input array of the same size and type as src1</param>
            <param name="dst">Output array of the same size and type as src1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AddWeighted(Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculated weighted sum of two arrays as following:
            dst(I)=src1(I)*alpha+src2(I)*beta+gamma
            All the arrays must have the same type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="alpha">Weight of the first array elements.</param>
            <param name="src2">The second source array. </param>
            <param name="beta">Weight of the second array elements.</param>
            <param name="gamma">Scalar, added to each sum. </param>
            <param name="dst">The destination array.</param>
            <param name="dtype">Optional depth of the output array; when both input arrays have the same depth</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InRange(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Performs range check for every element of the input array:
            dst(I)=lower(I)_0 &lt;= src(I)_0 &lt;= upper(I)_0
            For single-channel arrays,
            dst(I)=lower(I)_0 &lt;= src(I)_0 &lt;= upper(I)_0 &amp;&amp;
            lower(I)_1 &lt;= src(I)_1 &lt;= upper(I)_1
            For two-channel arrays etc.
            dst(I) is set to 0xff (all '1'-bits) if src(I) is within the range and 0 otherwise. All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </summary>
            <param name="src">The source image</param>
            <param name="lower">The lower values stored in an image of same type &amp; size as <paramref name="src"/></param>
            <param name="upper">The upper values stored in an image of same type &amp; size as <paramref name="src"/></param>
            <param name="dst">The resulting mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Norm(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.CvEnum.NormType,Emgu.CV.IInputArray)">
            <summary>
            Returns the calculated norm. The multiple-channel array are treated as single-channel, that is, the results for all channels are combined. 
            </summary>
            <param name="arr1">The first source image</param>
            <param name="arr2">The second source image. If it is null, the absolute norm of arr1 is calculated, otherwise absolute or relative norm of arr1-arr2 is calculated</param>
            <param name="normType">Type of norm</param>
            <param name="mask">The optional operation mask</param>
            <returns>The calculated norm</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Norm(Emgu.CV.IInputArray,Emgu.CV.CvEnum.NormType,Emgu.CV.IInputArray)">
            <summary>
            Returns the calculated norm. The multiple-channel array are treated as single-channel, that is, the results for all channels are combined. 
            </summary>
            <param name="arr1">The first source image</param>
            <param name="normType">Type of norm</param>
            <param name="mask">The optional operation mask</param>
            <returns>The calculated norm</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImage(System.Drawing.Size,Emgu.CV.CvEnum.IplDepth,System.Int32)">
            <summary>
            Creates the header and allocates data. 
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns>A pointer to IplImage </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImageHeader(System.Drawing.Size,Emgu.CV.CvEnum.IplDepth,System.Int32)">
            <summary>
            Allocates, initializes, and returns the structure IplImage.
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns> The structure IplImage</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitImageHeader(System.IntPtr,System.Drawing.Size,Emgu.CV.CvEnum.IplDepth,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the image header structure, pointer to which is passed by the user, and returns the pointer.
            </summary>
            <param name="image">Image header to initialize.</param>
            <param name="size">Image width and height.</param>
            <param name="depth">Image depth </param>
            <param name="channels">Number of channels </param>
            <param name="origin">IPL_ORIGIN_TL or IPL_ORIGIN_BL.</param>
            <param name="align">Alignment for image rows, typically 4 or 8 bytes.</param>
            <returns>Pointer to the image header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetData(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Assigns user data to the array header.
            </summary>
            <param name="arr">Array header.</param>
            <param name="data">User data.</param>
            <param name="step">Full row length in bytes.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImageHeader(System.IntPtr@)">
            <summary>
            Releases the header.
            </summary>
            <param name="image">Pointer to the deallocated header.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatHeader(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Initializes already allocated CvMat structure. It can be used to process raw data with OpenCV matrix functions.
            </summary>
            <param name="mat">Pointer to the matrix header to be initialized.</param>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <param name="step">Full row width in bytes of the data assigned. By default, the minimal possible step is used, i.e., no gaps is assumed between subsequent rows of the matrix.</param>
            <returns>Pointer to the CvMat</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageCOI(System.IntPtr,System.Int32)">
            <summary>
            Sets the channel of interest to a given value. Value 0 means that all channels are selected, 1 means that the first channel is selected etc. If ROI is NULL and coi != 0, ROI is allocated.
            </summary>
            <param name="image">Image header</param>
            <param name="coi">Channel of interest starting from 1. If 0, the COI is unset.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageCOI(System.IntPtr)">
            <summary>
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header. </param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvResetImageROI(System.IntPtr)">
            <summary>
            Releases image ROI. After that the whole image is considered selected.
            </summary>
            <param name="image">Image header</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageROI(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Sets the image ROI to a given rectangle. If ROI is NULL and the value of the parameter rect is not equal to the whole image, ROI is allocated. 
            </summary>
            <param name="image">Image header.</param>
            <param name="rect">ROI rectangle.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageROI(System.IntPtr)">
            <summary>
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header.</param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateMat(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Allocates header for the new matrix and underlying data, and returns a pointer to the created matrix. Matrices are stored row by row. All the rows are aligned by 4 bytes. 
            </summary>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <returns>A pointer to the created matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatNDHeader(System.IntPtr,System.Int32,System.Int32[],Emgu.CV.CvEnum.DepthType,System.IntPtr)">
            <summary>
            Initializes CvMatND structure allocated by the user
            </summary>
            <param name="mat">Pointer to the array header to be initialized</param>
            <param name="dims">Number of array dimensions</param>
            <param name="sizes">Array of dimension sizes</param>
            <param name="type">Type of array elements</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <returns>Pointer to the array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseMat(System.IntPtr@)">
            <summary>
            Decrements the matrix data reference counter and releases matrix header
            </summary>
            <param name="mat">Double pointer to the matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSparseMat(System.Int32,System.IntPtr,Emgu.CV.CvEnum.DepthType)">
            <summary>
            The function allocates a multi-dimensional sparse array. Initially the array contain no elements, that is Get or GetReal returns zero for every index
            </summary>
            <param name="dims">Number of array dimensions</param>
            <param name="sizes">Array of dimension sizes</param>
            <param name="type">Type of array elements</param>
            <returns>Pointer to the array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseSparseMat(System.IntPtr@)">
            <summary>
            The function releases the sparse array and clears the array pointer upon exit.
            </summary>
            <param name="mat">Reference of the pointer to the array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal1D(System.IntPtr,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal2D(System.IntPtr,System.Int32,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal3D(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index </param>
            <param name="idx2">The third zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetRealND(System.IntPtr,System.Int32[],System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx">Array of the element indices </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearND(System.IntPtr,System.Int32[])">
            <summary>
            Clears (sets to zero) the particular element of dense array or deletes the element of sparse array. If the element does not exists, the function does nothing
            </summary>
            <param name="arr">Input array</param>
            <param name="idx">Array of the element indices </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSet2D(System.IntPtr,System.Int32,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Assign the new value to the particular element of array
            </summary>
            <param name="arr">Input array. </param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="value">The assigned value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Flip(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.FlipType)">
            <summary>
            Flips the array in one of different 3 ways (row and column indices are 0-based)
            </summary>
            <param name="src">Source array.</param>
            <param name="dst">Destination array.</param>
            <param name="flipType">Specifies how to flip the array.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FlipND(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Flips a n-dimensional at given axis
            </summary>
            <param name="src">Input array</param>
            <param name="dst">Output array that has the same shape of src</param>
            <param name="axis">Axis that performs a flip on. 0 &lt;= axis &lt; src.dims.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Broadcast(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Broadcast the given Mat to the given shape.
            </summary>
            <param name="src">Input array</param>
            <param name="shape">Target shape. Should be a list of CV_32S numbers. Note that negative values are not supported.</param>
            <param name="dst">Output array that has the given shape</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Rotate(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.RotateFlags)">
            <summary>
            Rotates a 2D array in multiples of 90 degrees.
            </summary>
            <param name="src">Input array.</param>
            <param name="dst">Output array of the same type as src.  The size is the same with ROTATE_180, and the rows and cols are switched for ROTATE_90 and ROTATE_270.</param>
            <param name="rotateCode">A flag to specify how to rotate the array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSubRect(System.IntPtr,System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Returns header, corresponding to a specified rectangle of the input array. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array. ROI is taken into account by the function so the sub-array of ROI is actually extracted.
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the resultant sub-array header.</param>
            <param name="rect">Zero-based coordinates of the rectangle of interest.</param>
            <returns>the resultant sub-array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRows(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the header, corresponding to a specified row span of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocated memory of resulting sub-array header</param>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <param name="deltaRow">Index step in the row span. That is, the function extracts every delta_row-th row from start_row and up to (but not including) end_row</param>
            <returns>The header, corresponding to a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRow(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Return the header, corresponding to a specified row of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocate memory of the resulting sub-array header</param>
            <param name="row">Zero-based index of the selected row</param>
            <returns>The header, corresponding to a specified row of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCols(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the header, corresponding to a specified col span of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocated memory of the resulting sub-array header</param>
            <param name="startCol">Zero-based index of the selected column</param>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <returns>The header, corresponding to a specified col span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCol(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Return the header, corresponding to a specified column of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocate memory of the resulting sub-array header</param>
            <param name="col">Zero-based index of the selected column</param>
            <returns>The header, corresponding to a specified column of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetDiag(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            returns the header, corresponding to a specified diagonal of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the resulting sub-array header</param>
            <param name="diag">Array diagonal. Zero corresponds to the main diagonal, -1 corresponds to the diagonal above the main etc., 1 corresponds to the diagonal below the main etc</param>
            <returns>Pointer to the resulting sub-array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSize(System.IntPtr)">
            <summary>
            Returns number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.
            </summary>
            <param name="arr">array header</param>
            <returns>number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Circle(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Int32,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a simple or filled circle with given center and radius. The circle is clipped by ROI rectangle.
            </summary>
            <param name="img">Image where the circle is drawn</param>
            <param name="center">Center of the circle</param>
            <param name="radius">Radius of the circle.</param>
            <param name="color">Color of the circle</param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Split(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Divides a multi-channel array into separate single-channel arrays. Two modes are available for the operation. If the source array has N channels then if the first N destination channels are not IntPtr.Zero, all they are extracted from the source array, otherwise if only a single destination channel of the first N is not IntPtr.Zero, this particular channel is extracted, otherwise an error is raised. Rest of destination channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to extract a single channel from the image
            </summary>
            <param name="src">Input multi-channel array</param>
            <param name="mv">Output array or vector of arrays</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Ellipse(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Drawing.Size,System.Double,System.Double,System.Double,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </summary>
            <param name="img">Image</param>
            <param name="center">Center of the ellipse</param>
            <param name="axes">Length of the ellipse axes</param>
            <param name="angle">Rotation angle</param>
            <param name="startAngle">Starting angle of the elliptic arc</param>
            <param name="endAngle">Ending angle of the elliptic arc</param>
            <param name="color">Ellipse color</param>
            <param name="thickness">Thickness of the ellipse arc</param>
            <param name="lineType">Type of the ellipse boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Ellipse(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.RotatedRect,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType)">
            <summary>
            Draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </summary>
            <param name="img">Image</param>
            <param name="box">Alternative ellipse representation via RotatedRect. This means that the function draws an ellipse inscribed in the rotated rectangle.</param>
            <param name="color">Ellipse color</param>
            <param name="thickness">Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.</param>
            <param name="lineType">Type of the ellipse boundary</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DrawMarker(Emgu.CV.IInputOutputArray,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.MarkerTypes,System.Int32,System.Int32,Emgu.CV.CvEnum.LineType)">
            <summary>
            Draws a marker on a predefined position in an image.
            </summary>
            <param name="img">Image.</param>
            <param name="position">The point where the crosshair is positioned.</param>
            <param name="color">Line color.</param>
            <param name="markerType">The specific type of marker you want to use</param>
            <param name="markerSize">The length of the marker axis [default = 20 pixels]</param>
            <param name="thickness">Line thickness.</param>
            <param name="lineType">Type of the line</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LUT(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Fills the destination array with values from the look-up table. Indices of the entries are taken from the source array. That is, the function processes each element of src as following:
            dst(I)=lut[src(I)+DELTA]
            where DELTA=0 if src has depth CV_8U, and DELTA=128 if src has depth CV_8S
            </summary>
            <param name="src">Source array of 8-bit elements</param>
            <param name="dst">Destination array of arbitrary depth and of the same number of channels as the source array</param>
            <param name="lut">Look-up table of 256 elements; should have the same depth as the destination array. In case of multi-channel source and destination arrays, the table should either have a single-channel (in this case the same table is used for all channels), or the same number of channels as the source/destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvertScale(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel arrays are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination array element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate cvConvert synonym. If source and destination array types have equal types, this is also a special case that can be used to scale and shift a matrix or an image and that fits to cvScale synonym.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertScaleAbs(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Similar to cvCvtScale but it stores absolute values of the conversion results:
            dst(I)=abs(src(I)*scale + (shift,shift,...))
            The function supports only destination arrays of 8u (8-bit unsigned integers) type, for other types the function can be emulated by combination of cvConvertScale and cvAbs functions.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array (should have 8u depth). </param>
            <param name="scale">ScaleAbs factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Mean(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
             <summary>
             Calculates the average value M of array elements, independently for each channel:
            N = sumI mask(I)!=0
            Mc = 1/N * sumI,mask(I)!=0 arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the average to the first scalar component (S0).
             </summary>
             <param name="arr">The array</param>
             <param name="mask">The optional operation mask</param>
             <returns>average (mean) of array elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MeanStdDev(Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Structure.MCvScalar@,Emgu.CV.IInputArray)">
            <summary>
            The function cvAvgSdv calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <remarks>If the array is IplImage and COI is set, the function processes the selected channel only and stores the average and standard deviation to the first compoenents of output scalars (M0 and S0).</remarks>
            <param name="arr">The array</param>
            <param name="mean">Pointer to the mean value</param>
            <param name="stdDev">Pointer to the standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MeanStdDev(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates a mean and standard deviation of array elements.
            </summary>
            <param name="arr">Input array that should have from 1 to 4 channels so that the results can be stored in MCvScalar</param>
            <param name="mean">Calculated mean value</param>
            <param name="stdDev">Calculated standard deviation</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sum(Emgu.CV.IInputArray)">
            <summary>
            Calculates sum S of array elements, independently for each channel
            Sc = sumI arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the sum to the first scalar component (S0).
            </summary>
            <param name="src">The array</param>
            <returns>The sum of array elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Reduce(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ReduceDimension,Emgu.CV.CvEnum.ReduceType,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Reduces matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <remarks>
            The function can be used to compute horizontal and vertical projections of an raster image. 
            In case of CV_REDUCE_SUM and CV_REDUCE_AVG the output may have a larger element bit-depth to preserve accuracy. 
            And multi-channel arrays are also supported in these two reduction modes
            </remarks>
            <param name="src">The input matrix</param>
            <param name="dst">The output single-row/single-column vector that accumulates somehow all the matrix rows/columns</param>
            <param name="dim">The dimension index along which the matrix is reduce.</param>
            <param name="type">The reduction operation type</param>
            <param name="dtype">Optional depth type of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImage(System.IntPtr@)">
            <summary>
            Releases the header and the image data.
            </summary>
            <param name="image">Double pointer to the header of the deallocated image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DrawContours(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArrayOfArrays,System.Int32,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,Emgu.CV.IInputArray,System.Int32,System.Drawing.Point)">
            <summary>
            Draws contours outlines or filled contours.
            </summary>
            <param name="image">Image where the contours are to be drawn. Like in any other drawing function, the contours are clipped with the ROI</param>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours </param>
            <param name="maxLevel">Maximal level for drawn contours. If 0, only contour is drawn. If 1, the contour and all contours after it on the same level are drawn. If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level. </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrieved in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FillConvexPoly(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Fills convex polygon interior. This function is much faster than The function cvFillPoly and can fill not only the convex polygons but any monotonic polygon, i.e. a polygon whose contour intersects every horizontal line (scan line) twice at the most
            </summary>
            <param name="img">Image</param>
            <param name="points">Array of pointers to a single polygon</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FillPoly(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.LineType,System.Int32,System.Drawing.Point)">
            <summary>
            Fills the area bounded by one or more polygons.
            </summary>
            <param name="img">Image.</param>
            <param name="points">Array of polygons where each polygon is represented as an array of points.</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries.</param>
            <param name="shift">Number of fractional bits in the vertex coordinates.</param>
            <param name="offset">Optional offset of all points of the contours.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PutText(Emgu.CV.IInputOutputArray,System.String,System.Drawing.Point,Emgu.CV.CvEnum.FontFace,System.Double,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Boolean)">
            <summary>
            Renders the text in the image with the specified font and color. The printed text is clipped by ROI rectangle. Symbols that do not belong to the specified font are replaced with the rectangle symbol.
            </summary>
            <param name="img">Input image</param>
            <param name="text">String to print</param>
            <param name="org">Coordinates of the bottom-left corner of the first letter</param>
            <param name="fontFace">Font type.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="color">Text color</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetTextSize(System.String,Emgu.CV.CvEnum.FontFace,System.Double,System.Int32,System.Int32@)">
            <summary>
            Calculates the width and height of a text string.
            </summary>
            <param name="text">Input text string.</param>
            <param name="fontFace">Font to use</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="thickness">Thickness of lines used to render the text. </param>
            <param name="baseLine">Y-coordinate of the baseline relative to the bottom-most text point.</param>
            <returns>The size of a box that contains the specified text.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinMaxLoc(Emgu.CV.IInputArray,System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,Emgu.CV.IInputArray)">
            <summary>
            Finds minimum and maximum element values and their positions. The extremums are searched over the whole array, selected ROI (in case of IplImage) or, if mask is not IntPtr.Zero, in the specified array region. If the array has more than one channel, it must be IplImage with COI set. In case if multi-dimensional arrays min_loc->x and max_loc->x will contain raw (linear) positions of the extremums
            </summary>
            <param name="arr">The source array, single-channel or multi-channel with COI set</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask that is used to select a subarray. Use IntPtr.Zero if not needed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ReduceArgMin(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Boolean)">
            <summary>
            Finds indices of min elements along provided axis.
            </summary>
            <param name="src">Input single-channel array.</param>
            <param name="dst">Output array of type CV_32SC1 with the same dimensionality as src, except for axis being reduced - it should be set to 1.</param>
            <param name="axis">Axis to reduce along.</param>
            <param name="lastIndex">Whether to get the index of first or last occurrence of min.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ReduceArgMax(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Boolean)">
            <summary>
            Finds indices of max elements along provided axis.
            </summary>
            <param name="src">Input single-channel array.</param>
            <param name="dst">Output array of type CV_32SC1 with the same dimensionality as src, except for axis being reduced - it should be set to 1.</param>
            <param name="axis">Axis to reduce along.</param>
            <param name="lastIndex">Whether to get the index of first or last occurrence of max.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CopyMakeBorder(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Copies the source 2D array into interior of destination array and makes a border of the specified type around the copied area. The function is useful when one needs to emulate border type that is different from the one embedded into a specific algorithm implementation. For example, morphological functions, as well as most of other filtering functions in OpenCV, internally use replication border type, while the user may need zero border or a border, filled with 1's or 255's
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="bordertype">Type of the border to create around the copied source image rectangle</param>
            <param name="value">Value of the border pixels if bordertype=CONSTANT</param>
            <param name="bottom">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="left">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="right">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="top">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet1D(System.IntPtr,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal1D(System.IntPtr,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="P:Emgu.CV.CvInvoke.UseOptimized">
            <summary>
            Enables or disables the optimized code.
            </summary>
            <value>
              <c>true</c> if [use optimized]; otherwise, <c>false</c>.
            </value>
            <remarks>The function can be used to dynamically turn on and off optimized code (code that uses SSE2, AVX, and other instructions on the platforms that support it). It sets a global flag that is further checked by OpenCV functions. Since the flag is not checked in the inner OpenCV loops, it is only safe to call the function on the very top level in your application where you can be sure that no other OpenCV function is currently executed.</remarks>
        </member>
        <member name="P:Emgu.CV.CvInvoke.HaveOpenVX">
            <summary>
            Check if use of OpenVX is possible.
            </summary>
            <returns>True use of OpenVX is possible.</returns>
        </member>
        <member name="P:Emgu.CV.CvInvoke.UseOpenVX">
            <summary>
            Enable/disable use of OpenVX
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.BuildInformation">
            <summary>
            Returns full configuration time cmake output.
            Returned value is raw cmake output including version control system revision, compiler version, compiler flags, enabled modules and third party libraries, etc.Output format depends on target architecture.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Randn(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Fills the array with normally distributed random numbers.
            </summary>
            <param name="dst">Output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.</param>
            <param name="mean">Mean value (expectation) of the generated random numbers.</param>
            <param name="stddev">Standard deviation of the generated random numbers; it can be either a vector (in which case a diagonal standard deviation matrix is assumed) or a square matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Randn(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Fills the array with normally distributed random numbers.
            </summary>
            <param name="dst">Output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.</param>
            <param name="mean">Mean value (expectation) of the generated random numbers.</param>
            <param name="stddev">Standard deviation of the generated random numbers; it can be either a vector (in which case a diagonal standard deviation matrix is assumed) or a square matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Randu(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Generates a single uniformly-distributed random number or an array of random numbers.
            </summary>
            <param name="dst">Output array of random numbers; the array must be pre-allocated.</param>
            <param name="low">Inclusive lower boundary of the generated random numbers.</param>
            <param name="high">Exclusive upper boundary of the generated random numbers.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Randu(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Generates a single uniformly-distributed random number or an array of random numbers.
            </summary>
            <param name="dst">Output array of random numbers; the array must be pre-allocated.</param>
            <param name="low">Inclusive lower boundary of the generated random numbers.</param>
            <param name="high">Exclusive upper boundary of the generated random numbers.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Eigen(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes eigenvalues and eigenvectors of a symmetric matrix
            </summary>
            <param name="src">The input symmetric square matrix, modified during the processing</param>
            <param name="eigenVectors">The output matrix of eigenvectors, stored as subsequent rows</param>
            <param name="eigenValues">The output vector of eigenvalues, stored in the descending order (order of eigenvalues and eigenvectors is syncronized, of course)</param>
            <remarks>Currently the function is slower than cvSVD yet less accurate, so if A is known to be positivelydefined (for example, it is a covariance matrix)it is recommended to use cvSVD to find eigenvalues and eigenvectors of A, especially if eigenvectors are not required.</remarks>
            <example>To calculate the largest eigenvector/-value set lowindex = highindex = 1. For legacy reasons this function always returns a square matrix the same size as the source matrix with eigenvectors and a vector the length of the source matrix with eigenvalues. The selected eigenvectors/-values are always in the first highindex - lowindex + 1 rows.</example>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Normalize(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.CvEnum.NormType,Emgu.CV.CvEnum.DepthType,Emgu.CV.IInputArray)">
            <summary>
            Normalizes the input array so that it's norm or value range takes the certain value(s).
            </summary>
            <param name="src">The input array</param>
            <param name="dst">The output array; in-place operation is supported</param>
            <param name="alpha">The minimum/maximum value of the output array or the norm of output array</param>
            <param name="beta">The maximum/minimum value of the output array</param>
            <param name="normType">The normalization type</param>
            <param name="mask">The operation mask. Makes the function consider and normalize only certain array elements</param>
            <param name="dType">Optional depth type for the dst array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Gemm(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.GemmType)">
            <summary>
            Performs generalized matrix multiplication:
            dst = alpha*op(src1)*op(src2) + beta*op(src3), where op(X) is X or XT
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array. </param>
            <param name="alpha">The scalar</param>
            <param name="src3">The third source array (shift). Can be null, if there is no shift.</param>
            <param name="beta">The scalar</param>
            <param name="dst">The destination array.</param>
            <param name="tAbc">The Gemm operation type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Transform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Performs matrix transformation of every element of array src and stores the results in dst
            Both source and destination arrays should have the same depth and the same size or selected ROI size. transmat and shiftvec should be real floating-point matrices.
            </summary>
            <param name="src">The first source array</param>
            <param name="dst">The destination array</param>
            <param name="m"> transformation 2x2 or 2x3 floating-point matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PerspectiveTransform(System.Drawing.PointF[],Emgu.CV.IInputArray)">
            <summary>
            Transforms every element of src in the following way:
            (x, y) -> (x'/w, y'/w),
            where
            (x', y', w') = mat3x3 * (x, y, 1)
            and w = w'   if w'!=0,
                   inf  otherwise
            </summary>
            <param name="src">The source points</param>
            <param name="mat">3x3 floating-point transformation matrix.</param>
            <returns>The destination points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PerspectiveTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Transforms every element of src (by treating it as 2D or 3D vector) in the following way:
            (x, y, z) -> (x'/w, y'/w, z'/w) or
            (x, y) -> (x'/w, y'/w),
            where
            (x', y', z', w') = mat4x4 * (x, y, z, 1) or
            (x', y', w') = mat3x3 * (x, y, 1)
            and w = w'   if w'!=0,
                   inf  otherwise
            </summary>
            <param name="src">The source three-channel floating-point array</param>
            <param name="dst">The destination three-channel floating-point array</param>
            <param name="mat">3x3 or 4x4 floating-point transformation matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MulTransposed(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.IInputArray,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates the product of src and its transposition.
            The function evaluates dst=scale(src-delta)*(src-delta)^T if order=0, and dst=scale(src-delta)^T*(src-delta) otherwise.
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix</param>
            <param name="aTa">Order of multipliers</param>
            <param name="delta">An optional array, subtracted from <paramref name="src"/> before multiplication</param>
            <param name="scale">An optional scaling</param>
            <param name="dtype">Optional depth type of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Trace(Emgu.CV.IInputArray)">
            <summary>
            Returns sum of diagonal elements of the matrix <paramref name="mat"/>.
            </summary>
            <param name="mat">the matrix</param>
            <returns>sum of diagonal elements of the matrix src1</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Transpose(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Transposes matrix src1:
            dst(i,j)=src(j,i)
            Note that no complex conjugation is done in case of complex matrix. Conjugation should be done separately: look at the sample code in cvXorS for example
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Determinant(Emgu.CV.IInputArray)">
            <summary>
            Returns determinant of the square matrix mat. The direct method is used for small matrices and Gaussian elimination is used for larger matrices. For symmetric positive-determined matrices it is also possible to run SVD with U=V=NULL and then calculate determinant as a product of the diagonal elements of W
            </summary>
            <param name="mat">The pointer to the matrix</param>
            <returns>determinant of the square matrix mat</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Invert(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DecompMethod)">
            <summary>
            Finds the inverse or pseudo-inverse of a matrix. This function inverts the matrix src and stores the result in dst . When the matrix src is singular or non-square, the function calculates the pseudo-inverse matrix (the dst matrix) so that norm(src*dst - I) is minimal, where I is an identity matrix.
            </summary>
            <param name="src">The input floating-point M x N matrix.</param>
            <param name="dst">The output matrix of N x M size and the same type as src.</param>
            <param name="method">Inversion method</param>
            <returns>
            In case of the DECOMP_LU method, the function returns non-zero value if the inverse has been successfully calculated and 0 if src is singular.
            In case of the DECOMP_SVD method, the function returns the inverse condition number of src (the ratio of the smallest singular value to the largest singular value) and 0 if src is singular. The SVD method calculates a pseudo-inverse matrix if src is singular.
            Similarly to DECOMP_LU, the method DECOMP_CHOLESKY works only with non-singular square matrices that should also be symmetrical and positively defined. In this case, the function stores the inverted matrix in dst and returns non-zero. Otherwise, it returns 0.
            </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SVDecomp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.SvdFlag)">
            <summary>
            Decomposes matrix A into a product of a diagonal matrix and two orthogonal matrices:
            A=U*W*VT
            Where W is diagonal matrix of singular values that can be coded as a 1D vector of singular values and U and V. All the singular values are non-negative and sorted (together with U and V columns) in descenting order.
            </summary>
            <remarks>
            SVD algorithm is numerically robust and its typical applications include: 
            1. accurate eigenvalue problem solution when matrix A is square, symmetric and positively defined matrix, for example, when it is a covariation matrix. W in this case will be a vector of eigen values, and U=V is matrix of eigen vectors (thus, only one of U or V needs to be calculated if the eigen vectors are required) 
            2. accurate solution of poor-conditioned linear systems 
            3. least-squares solution of overdetermined linear systems. This and previous is done by cvSolve function with CV_SVD method 
            4. accurate calculation of different matrix characteristics such as rank (number of non-zero singular values), condition number (ratio of the largest singular value to the smallest one), determinant (absolute value of determinant is equal to the product of singular values). All the things listed in this item do not require calculation of U and V matrices. 
            </remarks>
            <param name="src">Source MxN matrix</param>
            <param name="w">Resulting singular value matrix (MxN or NxN) or vector (Nx1). </param>
            <param name="u">Optional left orthogonal matrix (MxM or MxN). If CV_SVD_U_T is specified, the number of rows and columns in the sentence above should be swapped</param>
            <param name="v">Optional right orthogonal matrix (NxN)</param>
            <param name="flags">Operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SVBackSubst(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Performs a singular value back substitution.
            </summary>
            <param name="w">Singular values</param>
            <param name="u">Left singular vectors</param>
            <param name="vt">Transposed matrix of right singular vectors.</param>
            <param name="rhs">Right-hand side of a linear system</param>
            <param name="dst">Found solution of the system.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcCovarMatrix(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.CvEnum.CovarMethod,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates the covariance matrix of a set of vectors.
            </summary>
            <param name="samples">Samples stored either as separate matrices or as rows/columns of a single matrix.</param>
            <param name="covar">Output covariance matrix of the type ctype and square size.</param>
            <param name="mean">Input or output (depending on the flags) array as the average value of the input vectors.</param>
            <param name="flags">Operation flags</param>
            <param name="ctype">Type of the matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Mahalanobis(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates the weighted distance between two vectors and returns it
            </summary>
            <param name="v1">The first 1D source vector</param>
            <param name="v2">The second 1D source vector</param>
            <param name="iconvar">The inverse covariation matrix</param>
            <returns>the Mahalanobis distance</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PCACompute(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Performs Principal Component Analysis of the supplied dataset.
            </summary>
            <param name="data">Input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">Optional mean value; if the matrix is empty, the mean is computed from the data.</param>
            <param name="eigenvectors">The eigenvectors.</param>
            <param name="maxComponents">Maximum number of components that PCA should retain; by default, all the components are retained.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PCACompute(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Performs Principal Component Analysis of the supplied dataset.
            </summary>
            <param name="data">Input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">Optional mean value; if the matrix is empty, the mean is computed from the data.</param>
            <param name="eigenvectors">The eigenvectors.</param>
            <param name="retainedVariance">Percentage of variance that PCA should retain. Using this parameter will let the PCA decided how many components to retain but it will always keep at least 2.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PCAProject(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Projects vector(s) to the principal component subspace.
            </summary>
            <param name="data">Input vector(s); must have the same dimensionality and the same layout as the input data used at PCA phase</param>
            <param name="mean">The mean.</param>
            <param name="eigenvectors">The eigenvectors.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PCABackProject(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Reconstructs vectors from their PC projections.
            </summary>
            <param name="data">Coordinates of the vectors in the principal component subspace</param>
            <param name="mean">The mean.</param>
            <param name="eigenvectors">The eigenvectors.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRawData(System.IntPtr,System.IntPtr@,System.Int32@,System.Drawing.Size@)">
            <summary>
            Fills output variables with low-level information about the array data. All output parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, parameters of ROI are returned. 
            </summary>
            <param name="arr">Array header</param>
            <param name="data">Output pointer to the whole image origin or ROI origin if ROI is set</param>
            <param name="step">Output full row length in bytes</param>
            <param name="roiSize">Output ROI size</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetMat(System.IntPtr,System.IntPtr,System.Int32@,System.Int32)">
            <summary>
            Returns matrix header for the input array that can be matrix - CvMat, image - IplImage or multi-dimensional dense array - CvMatND* (latter case is allowed only if allowND != 0) . In the case of matrix the function simply returns the input pointer. In the case of IplImage* or CvMatND* it initializes header structure with parameters of the current image ROI and returns pointer to this temporary structure. Because COI is not supported by CvMat, it is returned separately. 
            </summary>
            <param name="arr">Input array</param>
            <param name="header">Pointer to CvMat structure used as a temporary buffer</param>
            <param name="coi">Optional output parameter for storing COI</param>
            <param name="allowNd">If non-zero, the function accepts multi-dimensional dense arrays (CvMatND*) and returns 2D (if CvMatND has two dimensions) or 1D matrix (when CvMatND has 1 dimension or more than 2 dimensions). The array must be continuous</param>
            <returns>Returns matrix header for the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImage(System.IntPtr,System.IntPtr)">
            <summary>
            Returns image header for the input array that can be matrix - CvMat*, or image - IplImage*.
            </summary>
            <param name="arr">Input array. </param>
            <param name="imageHeader">Pointer to IplImage structure used as a temporary buffer.</param>
            <returns>Returns image header for the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCheckArr(System.IntPtr,Emgu.CV.CvEnum.CheckType,System.Double,System.Double)">
            <summary>
            Checks that every array element is neither NaN nor Infinity. If CV_CHECK_RANGE is set, it also checks that every element is greater than or equal to minVal and less than maxVal. 
            </summary>
            <param name="arr">The array to check.</param>
            <param name="flags">The operation flags, CHECK_NAN_INFINITY or combination of
            CHECK_RANGE - if set, the function checks that every value of array is within [minVal,maxVal) range, otherwise it just checks that every element is neither NaN nor Infinity.
            CHECK_QUIET - if set, the function does not raises an error if an element is invalid or out of range 
            </param>
            <param name="minVal">The inclusive lower boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <param name="maxVal">The exclusive upper boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <returns>Returns nonzero if the check succeeded, i.e. all elements are valid and within the range, and zero otherwise. In the latter case if CV_CHECK_QUIET flag is not set, the function raises runtime error.</returns>
        </member>
        <member name="P:Emgu.CV.CvInvoke.NumThreads">
            <summary>
            Get or set the number of threads that are used by parallelized OpenCV functions
            </summary>
            <remarks>When the argument is zero or negative, and at the beginning of the program, the number of threads is set to the number of processors in the system, as returned by the function omp_get_num_procs() from OpenMP runtime. </remarks>
        </member>
        <member name="P:Emgu.CV.CvInvoke.ThreadNum">
            <summary>
            Returns the index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.NumberOfCPUs">
            <summary>
            Returns the number of logical CPUs available for the process.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetParallelForBackend(System.String,System.Boolean)">
            <summary>
            Replace OpenCV parallel_for backend.
            </summary>
            <param name="backendName">The name of the backend.</param>
            <param name="propagateNumThreads">It true, the number of threads of the current enviroment will be passed to the new backend.</param>
            <returns>True if backend is set</returns>
            <remarks>This call is not thread-safe. Consider calling this function from the main() before any other OpenCV processing functions (and without any other created threads).</remarks>
        </member>
        <member name="P:Emgu.CV.CvInvoke.AvailableParallelBackends">
            <summary>
            Get a list of the available parallel backends.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Compare(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CmpType)">
            <summary>
            Compares the corresponding elements of two arrays and fills the destination mask array:
            dst(I)=src1(I) op src2(I),
            dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise. 
            All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </summary>
            <param name="src1">The first image to compare with</param>
            <param name="src2">The second image to compare with</param>
            <param name="dst">dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise.</param>
            <param name="cmpOp">The comparison operator type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvArrToMat(System.IntPtr,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Converts CvMat, IplImage , or CvMatND to Mat.
            </summary>
            <param name="arr">Input CvMat, IplImage , or CvMatND.</param>
            <param name="allowND">When true (default value), CvMatND is converted to 2-dimensional Mat, if it is possible (see the discussion below); if it is not possible, or when the parameter is false, the function will report an error</param>
            <param name="copyData">When false (default value), no data is copied and only the new header is created, in this case, the original array should not be deallocated while the new matrix header is used; if the parameter is true, all the data is copied and you may deallocate the original array right after the conversion.</param>
            <param name="coiMode">Parameter specifying how the IplImage COI (when set) is handled. If coiMode=0 and COI is set, the function reports an error. If coiMode=1 , the function never reports an error. Instead, it returns the header to the whole original image and you will have to check and process COI manually. </param>
            <returns>The Mat header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HConcat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Horizontally concatenate two images
            </summary>
            <param name="src1">The first image</param>
            <param name="src2">The second image</param>
            <param name="dst">The result image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HConcat(Emgu.CV.Mat[],Emgu.CV.IOutputArray)">
            <summary>
            Horizontally concatenate two images
            </summary>
            <param name="srcs">Input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.</param>
            <param name="dst">output array. It has the same number of rows and depth as the src, and the sum of cols of the src. same depth.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HConcat(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IOutputArray)">
            <summary>
            Horizontally concatenate two images
            </summary>
            <param name="srcs">Input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.</param>
            <param name="dst">output array. It has the same number of rows and depth as the src, and the sum of cols of the src. same depth.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.VConcat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Vertically concatenate two images
            </summary>
            <param name="src1">The first image</param>
            <param name="src2">The second image</param>
            <param name="dst">The result image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.VConcat(Emgu.CV.Mat[],Emgu.CV.IOutputArray)">
            <summary>
            The function vertically concatenates two or more matrices
            </summary>
            <param name="srcs">Input array or vector of matrices. all of the matrices must have the same number of cols and the same depth</param>
            <param name="dst">Output array. It has the same number of cols and depth as the src, and the sum of rows of the src. same depth.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.VConcat(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IOutputArray)">
            <summary>
            The function vertically concatenates two or more matrices
            </summary>
            <param name="srcs">Input array or vector of matrices. all of the matrices must have the same number of cols and the same depth</param>
            <param name="dst">Output array. It has the same number of cols and depth as the src, and the sum of rows of the src. same depth.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Swap(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Swaps two matrices
            </summary>
            <param name="m1">The Mat to be swapped</param>
            <param name="m2">The Mat to be swapped</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Swap(Emgu.CV.UMat,Emgu.CV.UMat)">
            <summary>
            Swaps two matrices
            </summary>
            <param name="m1">The UMat to be swapped</param>
            <param name="m2">The UMat to be swapped</param>
        </member>
        <member name="P:Emgu.CV.CvInvoke.HaveOpenCL">
            <summary>
            Check if we have OpenCL
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.UseOpenCL">
            <summary>
            Get or set if OpenCL should be used
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.OclFinish">
            <summary>
            Finishes OpenCL queue.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.OclGetPlatformsSummary">
            <summary>
            Get the OpenCL platform summary as a string
            </summary>
            <returns>An OpenCL platform summary</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.OclSetDefaultDevice(System.String)">
            <summary>
            Set the default opencl device
            </summary>
            <param name="deviceName">The name of the opencl device</param>
        </member>
        <member name="P:Emgu.CV.CvInvoke.HaveOpenCLCompatibleGpuDevice">
            <summary>
            Gets a value indicating whether this device have open CL compatible gpu device.
            </summary>
            <value><c>true</c> if have open CL compatible gpu device; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Kmeans(Emgu.CV.IInputArray,System.Int32,Emgu.CV.IOutputArray,Emgu.CV.Structure.MCvTermCriteria,System.Int32,Emgu.CV.CvEnum.KMeansInitType,Emgu.CV.IOutputArray)">
            <summary>
            Implements k-means algorithm that finds centers of cluster_count clusters and groups the input samples around the clusters. On output labels(i) contains a cluster index for sample stored in the i-th row of samples matrix
            </summary>
            <param name="data">Floating-point matrix of input samples, one row per sample</param>
            <param name="bestLabels">Output integer vector storing cluster indices for every sample</param>
            <param name="termcrit">Specifies maximum number of iterations and/or accuracy (distance the centers move by between the subsequent iterations)</param>
            <param name="attempts">The number of attempts. Use 2 if not sure</param>
            <param name="flags">Flags, use 0 if not sure</param>
            <param name="centers">Pointer to array of centers, use IntPtr.Zero if not sure</param>
            <param name="k">Number of clusters to split the set by.</param>
            <returns>The function returns the compactness measure. The best (minimum) value is chosen and the corresponding labels and the compactness value are returned by the function. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GrabCut(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Drawing.Rectangle,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Int32,Emgu.CV.CvEnum.GrabcutInitType)">
             <summary>
             The grab cut algorithm for segmentation
             </summary>
             <param name="img">The 8-bit 3-channel image to be segmented</param>
             <param name="mask">Input/output 8-bit single-channel mask. The mask is initialized by the function
             when mode is set to GC_INIT_WITH_RECT. Its elements may have one of following values:
             0 (GC_BGD) defines an obvious background pixels.
             1 (GC_FGD) defines an obvious foreground (object) pixel.
             2 (GC_PR_BGR) defines a possible background pixel.
             3 (GC_PR_FGD) defines a possible foreground pixel.
            </param>
             <param name="rect">The rectangle to initialize the segmentation</param>
             <param name="bgdModel">
             Temporary array for the background model. Do not modify it while you are
             processing the same image.
             </param>
             <param name="fgdModel">
             Temporary arrays for the foreground model. Do not modify it while you are
             processing the same image.
             </param>
             <param name="iterCount">The number of iterations</param>
             <param name="type">The initialization type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sqrt(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculate square root of each source array element. in the case of multichannel
            arrays each channel is processed independently. The function accuracy is approximately
            the same as of the built-in std::sqrt.
            </summary>
            <param name="src">The source floating-point array</param>
            <param name="dst">The destination array; will have the same size and the same type as src</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ApplyColorMap(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorMapType)">
            <summary>
            Applies a GNU Octave/MATLAB equivalent colormap on a given image.
            </summary>
            <param name="src"> The source image, grayscale or colored of type CV_8UC1 or CV_8UC3</param>
            <param name="dst"> The result is the colormapped source image</param>
            <param name="colorMapType">The type of color map</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ApplyColorMap(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Applies a user colormap on a given image.
            </summary>
            <param name="src"> The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. </param>
            <param name="dst"> The result is the colormapped source image. </param>
            <param name="userColorMap">The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CheckRange(Emgu.CV.IInputArray,System.Boolean,System.Drawing.Point@,System.Double,System.Double)">
            <summary>
            Check that every array element is neither NaN nor +- inf. The functions also check that each value
            is between minVal and maxVal. in the case of multi-channel arrays each channel is processed
            independently. If some values are out of range, position of the first outlier is stored in pos, 
            and then the functions either return false (when quiet=true) or throw an exception.
            </summary>
            <param name="arr">The array to check</param>
            <param name="quiet">The flag indicating whether the functions quietly return false when the array elements are
            out of range, or they throw an exception</param>
            <param name="pos">This will be filled with the position of the first outlier</param>
            <param name="minVal">The inclusive lower boundary of valid values range</param>
            <param name="maxVal">The exclusive upper boundary of valid values range</param>
            <returns>If quiet, return true if all values are in range</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PatchNaNs(Emgu.CV.IInputOutputArray,System.Double)">
            <summary>
            Converts NaN's to the given number
            </summary>
            <param name="a">The array where NaN needs to be converted</param>
            <param name="val">The value to convert to</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateAffine3D(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.Matrix{System.Double}@,System.Byte[]@,System.Double,System.Double)">
            <summary>
            Computes an optimal affine transformation between two 3D point sets.
            </summary>
            <param name="src">First input 3D point set.</param>
            <param name="dst">Second input 3D point set.</param>
            <param name="estimate">Output 3D affine transformation matrix.</param>
            <param name="inliers">Output vector indicating which points are inliers.</param>
            <param name="ransacThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <returns>The result</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateAffine3D(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Computes an optimal affine transformation between two 3D point sets.
            </summary>
            <param name="src"> First input 3D point set.</param>
            <param name="dst">Second input 3D point set.</param>
            <param name="affineEstimate">Output 3D affine transformation matrix 3 x 4</param>
            <param name="inliers"> Output vector indicating which points are inliers.</param>
            <param name="ransacThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <returns>the result</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinMaxIdx(Emgu.CV.IInputArray,System.Double@,System.Double@,System.Int32[],System.Int32[],Emgu.CV.IInputArray)">
            <summary>
            Finds the global minimum and maximum in an array
            </summary>
            <param name="src">Input single-channel array.</param>
            <param name="minVal">The returned minimum value</param>
            <param name="maxVal">The returned maximum value</param>
            <param name="minIdx">The returned minimum location</param>
            <param name="maxIdx">The returned maximum location</param>
            <param name="mask">The extremums are searched across the whole array if mask is IntPtr.Zert. Otherwise, search is performed in the specified array region.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Filter2D(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Applies arbitrary linear filter to the image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values from the nearest pixels that is inside the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="kernel">Convolution kernel, single-channel floating point matrix. If you want to apply different kernels to different channels, split the image using cvSplit into separate color planes and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of a filtered point within the kernel. The anchor shoud lie within the kernel. The special default value (-1,-1) means that it is at the kernel center</param>
            <param name="delta">The optional value added to the filtered pixels before storing them in dst</param>
            <param name="borderType">The pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SepFilter2D(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            The function applies a separable linear filter to the image. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result shifted by delta is stored in dst .
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image of the same size and the same number of channels as src.</param>
            <param name="ddepth">Destination image depth</param>
            <param name="kernelX">Coefficients for filtering each row.</param>
            <param name="kernelY">Coefficients for filtering each column.</param>
            <param name="anchor">Anchor position within the kernel. The value (-1,-1) means that the anchor is at the kernel center.</param>
            <param name="delta">Value added to the filtered results before storing them.</param>
            <param name="borderType">Pixel extrapolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BlendLinear(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Performs linear blending of two images:
            dst(i, j)=weights1(i, j) x src1(i, j) + weights2(i, j) x src2(i, j)
            </summary>
            <param name="src1">It has a type of CV_8UC(n) or CV_32FC(n), where n is a positive integer.</param>
            <param name="src2">It has the same type and size as src1.</param>
            <param name="weights1">It has a type of CV_32FC1 and the same size with src1.</param>
            <param name="weights2">It has a type of CV_32FC1 and the same size with src1.</param>
            <param name="dst">It is created if it does not have the same size and type with src1.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CLAHE(Emgu.CV.IInputArray,System.Double,System.Drawing.Size,Emgu.CV.IOutputArray)">
            <summary>
            Contrast Limited Adaptive Histogram Equalization (CLAHE)
            </summary>
            <param name="src">The source image</param>
            <param name="clipLimit">Clip Limit, use 40 for default</param>
            <param name="tileGridSize">Tile grid size, use (8, 8) for default</param>
            <param name="dst">The destination image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetCvStructSizes">
            <summary>
            This function retrieve the Open CV structure sizes in unmanaged code
            </summary>
            <returns>The structure that will hold the Open CV structure sizes</returns>
        </member>
        <member name="P:Emgu.CV.CvInvoke.ConfigDict">
            <summary>
            Get the dictionary that hold the Open CV build flags. The key is a String and the value is type double. If it is a flag, 0 means false and 1 means true 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindCirclesGrid(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.Size,Emgu.CV.CvEnum.CalibCgType,Emgu.CV.Features2D.Feature2D)">
            <summary>
            Finds centers in the grid of circles
            </summary>
            <param name="image">Source chessboard view</param>
            <param name="patternSize">The number of inner circle per chessboard row and column</param>
            <param name="flags">Various operation flags</param>
            <param name="featureDetector">The feature detector. Use a SimpleBlobDetector for default</param>
            <returns>The center of circles detected if the chess board pattern is found, otherwise null is returned</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindCirclesGrid(Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibCgType,Emgu.CV.Features2D.Feature2D)">
            <summary>
            Finds centers in the grid of circles
            </summary>
            <param name="image">Source chessboard view</param>
            <param name="patternSize">The number of inner circle per chessboard row and column</param>
            <param name="flags">Various operation flags</param>
            <param name="featureDetector">The feature detector. Use a SimpleBlobDetector for default</param>
            <param name="centers">output array of detected centers.</param>
            <returns>True if grid found.</returns>
        </member>
        <member name="F:Emgu.CV.CvInvoke.ExternLibrary">
            <summary>
            The file name of the cvextern library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.ExternCudaLibrary">
            <summary>
            The file name of the cvextern library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvFFMpegLibrary">
            <summary>
            The file name of the opencv_ffmpeg library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpenCVModuleList">
            <summary>
            The List of the opencv modules
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.NamedWindow(System.String,Emgu.CV.CvEnum.WindowFlags)">
            <summary>
            Creates a window which can be used as a placeholder for images and trackbars. Created windows are reffered by their names. 
            If the window with such a name already exists, the function does nothing.
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption</param>
            <param name="flags">Flags of the window.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetWindowProperty(System.String,Emgu.CV.CvEnum.WindowPropertyFlags,System.Double)">
            <summary>
            Changes parameters of a window dynamically.
            </summary>
            <param name="name">Name of the window.</param>
            <param name="propId">Window property to edit.</param>
            <param name="propValue">New value of the window property.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetWindowProperty(System.String,Emgu.CV.CvEnum.WindowPropertyFlags)">
            <summary>
            Provides parameters of a window.
            </summary>
            <param name="name">Name of the window.</param>
            <param name="propId">Window property to retrieve.</param>
            <returns>Value of the window property</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetWindowTitle(System.String,System.String)">
            <summary>
            Updates window title
            </summary>
            <param name="winname">Name of the window.</param>
            <param name="title">New title.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WaitKey(System.Int32)">
            <summary>
            Waits for key event infinitely (delay &lt;= 0) or for "delay" milliseconds. 
            </summary>
            <param name="delay">Delay in milliseconds.</param>
            <returns>The code of the pressed key or -1 if no key were pressed until the specified timeout has elapsed</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PollKey">
            <summary>
            Polls for a key event without waiting.
            </summary>
            <returns>The code of the pressed key or -1 if no key was pressed since the last invocation.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imshow(System.String,Emgu.CV.IInputArray)">
            <summary>
            Shows the image in the specified window
            </summary>
            <param name="name">Name of the window</param>
            <param name="image">Image to be shown</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DestroyWindow(System.String)">
            <summary>
            Destroys the window with a given name
            </summary>
            <param name="name">Name of the window to be destroyed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DestroyAllWindows">
            <summary>
            Destroys all of the HighGUI windows.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SelectROI(System.String,Emgu.CV.IInputArray,System.Boolean,System.Boolean)">
            <summary>
            Selects ROI on the given image. Function creates a window and allows user to select a ROI using mouse. Controls: use space or enter to finish selection, use key c to cancel selection (function will return the zero cv::Rect).
            </summary>
            <param name="windowName"> Name of the window where selection process will be shown.</param>
            <param name="img"> Image to select a ROI.</param>
            <param name="showCrosshair"> If true crosshair of selection rectangle will be shown.</param>
            <param name="fromCenter"> If true center of selection will match initial mouse position. In opposite case a corner of selection rectangle will correspont to the initial mouse position.</param>
            <returns> Selected ROI or empty rect if selection canceled.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SelectROIs(System.String,Emgu.CV.IInputArray,System.Boolean,System.Boolean)">
            <summary>
            Selects ROIs on the given image. Function creates a window and allows user to select a ROIs using mouse. Controls: use space or enter to finish current selection and start a new one, use esc to terminate multiple ROI selection process.
            </summary>
            <param name="windowName"> Name of the window where selection process will be shown.</param>
            <param name="img"> Image to select a ROI.</param>
            <param name="showCrosshair"> If true crosshair of selection rectangle will be shown.</param>
            <param name="fromCenter"> If true center of selection will match initial mouse position. In opposite case a corner of selection rectangle will correspont to the initial mouse position.</param>
            <returns> Selected ROIs.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imread(System.String,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            Loads an image from the specified file and returns the pointer to the loaded image. Currently the following file formats are supported: 
            Windows bitmaps - BMP, DIB; 
            JPEG files - JPEG, JPG, JPE; 
            Portable Network Graphics - PNG; 
            Portable image format - PBM, PGM, PPM; 
            Sun rasters - SR, RAS; 
            TIFF files - TIFF, TIF; 
            OpenEXR HDR images - EXR; 
            JPEG 2000 images - jp2. 
            </summary>
            <param name="filename">The name of the file to be loaded</param>
            <param name="loadType">The image loading type</param>
            <returns>The loaded image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HaveImageReader(System.String)">
            <summary>
            Returns true if the specified image can be decoded by OpenCV.
            </summary>
            <param name="fileName">File name of the image</param>
            <returns>True if the specified image can be decoded by OpenCV.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HaveImageWriter(System.String)">
            <summary>
            Returns true if an image with the specified filename can be encoded by OpenCV.
            </summary>
            <param name="fileName">File name of the image</param>
            <returns>True if an image with the specified filename can be encoded by OpenCV.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imwritemulti(System.String,Emgu.CV.IInputArrayOfArrays,System.Collections.Generic.KeyValuePair{Emgu.CV.CvEnum.ImwriteFlags,System.Int32}[])">
            <summary>
            Save multiple images to a specified file (e.g. ".tiff" that support multiple images).
            </summary>
            <param name="filename">Name of the file.</param>
            <param name="images">Images to be saved.</param>
            <param name="parameters">The parameters</param>
            <returns>true if success</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imreadmulti(System.String,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects.
            </summary>
            <param name="filename">Name of file to be loaded.</param>
            <param name="flags">Read flags</param>
            <returns>Null if the reading fails, otherwise, an array of Mat from the file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imwrite(System.String,Emgu.CV.IInputArray,System.Collections.Generic.KeyValuePair{Emgu.CV.CvEnum.ImwriteFlags,System.Int32}[])">
            <summary>
            Saves the image to the specified file. The function imwrite saves the image to the specified file. The image format is chosen based on the filename extension (see cv::imread for the list of extensions).
            </summary>
            <param name="filename">The name of the file to be saved to</param>
            <param name="image">The image to be saved</param>
            <param name="parameters">The parameters</param>
            <remarks>In general, only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function, with these exceptions:
            16-bit unsigned(CV_16U) images can be saved in the case of PNG, JPEG 2000, and TIFF formats
            32-bit float (CV_32F) images can be saved in PFM, TIFF, OpenEXR, and Radiance HDR formats; 3-channel(CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding(4 bytes per pixel)
            PNG images with an alpha channel can be saved using this function.To do this, create 8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels should have alpha set to 0, fully opaque pixels should have alpha set to 255 / 65535(see the code sample below).
            Multiple images(vector of Mat) can be saved in TIFF format(see the code sample below).
            If the image format is not supported, the image will be converted to 8 - bit unsigned(CV_8U) and saved that way.
            If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I / O functions to save the image to XML or YAML format.</remarks>
            <returns>true if success</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imdecode(System.Byte[],Emgu.CV.CvEnum.ImreadModes,Emgu.CV.Mat)">
            <summary>
            Decode image stored in the buffer
            </summary>
            <param name="buf">The buffer</param>
            <param name="loadType">The image loading type</param>
            <param name="dst">The output placeholder for the decoded matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imdecode(Emgu.CV.IInputArray,Emgu.CV.CvEnum.ImreadModes,Emgu.CV.Mat)">
            <summary>
            Decode image stored in the buffer
            </summary>
            <param name="buf">The buffer</param>
            <param name="loadType">The image loading type</param>
            <param name="dst">The output placeholder for the decoded matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imencode(System.String,Emgu.CV.IInputArray,System.Collections.Generic.KeyValuePair{Emgu.CV.CvEnum.ImwriteFlags,System.Int32}[])">
            <summary>
            Encode image and return the result as a byte vector.
            </summary>
            <param name="ext">The image format</param>
            <param name="image">The image</param>
            <param name="parameters">The pointer to the array of integers, which contains the parameter for encoding, use IntPtr.Zero for default</param>
            <returns>Byte array that contains the image in the specific image format. If failed to encode, return null</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imencode(System.String,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfByte,System.Collections.Generic.KeyValuePair{Emgu.CV.CvEnum.ImwriteFlags,System.Int32}[])">
            <summary>
            Encode image and store the result as a byte vector.
            </summary>
            <param name="ext">The image format</param>
            <param name="image">The image</param>
            <param name="buf">Output buffer resized to fit the compressed image.</param>
            <param name="parameters">The pointer to the array of integers, which contains the parameter for encoding, use IntPtr.Zero for default</param>
            <returns>True if successfully encoded the image into the buffer.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetRectSubPix(Emgu.CV.IInputArray,System.Drawing.Size,System.Drawing.PointF,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Extracts pixels from src:
            dst(x, y) = src(x + center.x - (width(dst)-1)*0.5, y + center.y - (height(dst)-1)*0.5)
            where the values of pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multiple-channel images is processed independently. Whereas the rectangle center must be inside the image, the whole rectangle may be partially occluded. In this case, the replication border mode is used to get pixel values beyond the image boundaries.
            </summary>
            <param name="image">Source image</param>
            <param name="patchSize">Size of the extracted patch.</param>
            <param name="patch">Extracted rectangle</param>
            <param name="patchType">Depth of the extracted pixels. By default, they have the same depth as <paramref name="image"/>.</param>
            <param name="center">Floating point coordinates of the extracted rectangle center within the source image. The center must be inside the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Resize(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.Inter)">
            <summary>
            Resizes the image src down to or up to the specified size
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image</param>
            <param name="dsize">Output image size; if it equals zero, it is computed as: dsize=Size(round(fx*src.cols), round(fy * src.rows)). Either dsize or both fx and fy must be non-zero.</param>
            <param name="fx">Scale factor along the horizontal axis</param>
            <param name="fy">Scale factor along the vertical axis;</param>
            <param name="interpolation">Interpolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ResizeForFrame(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,System.Boolean)">
            <summary>
            Resize an image such that it fits in a given frame, keeping the aspect ratio.
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The result image</param>
            <param name="frameSize">The size of the frame</param>
            <param name="interpolationMethod">The interpolation method</param>
            <param name="scaleDownOnly">If true, it will not try to scale up the image to fit the frame</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WarpAffine(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Applies an affine transformation to an image.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="dsize">Size of the output image.</param>
            <param name="interMethod">Interpolation method</param>
            <param name="warpMethod">Warp method</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="borderValue">A value used to fill outliers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetAffineTransform(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Coordinates of 3 triangle vertices in the source image. If the array contains more than 3 points, only the first 3 will be used</param>
            <param name="dest">Coordinates of the 3 corresponding triangle vertices in the destination image. If the array contains more than 3 points, only the first 3 will be used</param>
            <returns>The 2x3 rotation matrix that defines the Affine transform</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetAffineTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Pointer to an array of PointF, Coordinates of 3 triangle vertices in the source image.</param>
            <param name="dst">Pointer to an array of PointF, Coordinates of the 3 corresponding triangle vertices in the destination image</param>
            <returns>The destination 2x3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetRotationMatrix2D(System.Drawing.PointF,System.Double,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Calculates rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image. </param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner).</param>
            <param name="scale">Isotropic scale factor</param>
            <param name="mapMatrix">Pointer to the destination 2x3 matrix</param>
            <returns>Pointer to the destination 2x3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WarpPerspective(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Applies a perspective transformation to an image
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="dsize">Size of the output image</param>
            <param name="interpolationType">Interpolation method</param>
            <param name="warpType">Warp method</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="borderValue">value used in case of a constant border</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetPerspectiveTransform(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dst">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <returns>The perspective transform matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetPerspectiveTransform(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dest">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <returns>The 3x3 Homography matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Remap(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Applies a generic geometrical transformation to an image.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="map1">The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1 , or CV_32FC2 . See convertMaps() for details on converting a floating point representation to fixed-point for speed.</param>
            <param name="map2">The second map of y values having the type CV_16UC1 , CV_32FC1 , or none (empty map if map1 is (x,y) points), respectively.</param>
            <param name="interpolation">Interpolation method (see resize() ). The method 'Area' is not supported by this function. </param>
            <param name="borderMode">Pixel extrapolation method </param>
            <param name="borderValue">A value used to fill outliers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InvertAffineTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Inverts an affine transformation
            </summary>
            <param name="m">Original affine transformation</param>
            <param name="im">Output reverse affine transformation.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LogPolar(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.PointF,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp)">
            <summary>
            The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking etc.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center, where the output precision is maximal</param>
            <param name="M">Magnitude scale parameter</param>
            <param name="interpolationType">Interpolation method</param>
            <param name="warpType">warp method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LinearPolar(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.PointF,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp)">
            <summary>
            The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking etc.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center, where the output precision is maximal</param>
            <param name="maxRadius">Maximum radius</param>
            <param name="interpolationType">Interpolation method</param>
            <param name="warpType">Warp method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PyrDown(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Performs downsampling step of Gaussian pyramid decomposition. First it convolves source image with the specified filter and then downsamples the image by rejecting even rows and columns.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="borderType">Border type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PyrUp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Performs up-sampling step of Gaussian pyramid decomposition. First it upsamples the source image by injecting even zero rows and columns and then convolves result with the specified filter multiplied by 4 for interpolation. So the destination image is four times larger than the source image.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="borderType">Border type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BuildPyramid(Emgu.CV.IInputArray,Emgu.CV.IOutputArrayOfArrays,System.Int32,Emgu.CV.CvEnum.BorderType)">
            <summary>
            The function constructs a vector of images and builds the Gaussian pyramid by recursively applying pyrDown to the previously built pyramid layers, starting from dst[0]==src.
            </summary>
            <param name="src">Source image. Check pyrDown for the list of supported types.</param>
            <param name="dst">Destination vector of maxlevel+1 images of the same type as src. dst[0] will be the same as src. dst[1] is the next pyramid layer, a smoothed and down-sized src, and so on.</param>
            <param name="maxlevel">0-based index of the last (the smallest) pyramid layer. It must be non-negative.</param>
            <param name="borderType">Pixel extrapolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Watershed(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray)">
            <summary>
            Implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in [Meyer92] Before passing the image to the function, user has to outline roughly the desired regions in the image markers with positive (>0) indices, i.e. every region is represented as one or more connected components with the pixel values 1, 2, 3 etc. Those components will be "seeds" of the future image regions. All the other pixels in markers, which relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0's. On the output of the function, each pixel in markers is set to one of values of the "seed" components, or to -1 at boundaries between the regions.
            </summary>
            <remarks>Note, that it is not necessary that every two neighbor connected components are separated by a watershed boundary (-1's pixels), for example, in case when such tangent components exist in the initial marker image. </remarks>
            <param name="image">The input 8-bit 3-channel image</param>
            <param name="markers">The input/output Int32 depth single-channel image (map) of markers. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMaxRect(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Finds minimum area rectangle that contains both input rectangles inside
            </summary>
            <param name="rect1">First rectangle </param>
            <param name="rect2">Second rectangle </param>
            <returns>The minimum area rectangle that contains both input rectangles inside</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitLine(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DistType,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to 2D or 3D point set 
            </summary>
            <param name="points">Input vector of 2D or 3D points, stored in std::vector or Mat.</param>
            <param name="distType">The distance used for fitting </param>
            <param name="param">Numerical parameter (C) for some types of distances, if 0 then some optimal value is chosen</param>
            <param name="reps">Sufficient accuracy for radius (distance between the coordinate origin and the line), 0.01 would be a good default</param>
            <param name="aeps">Sufficient accuracy for angle, 0.01 would be a good default</param>
            <param name="line">Output line parameters. In case of 2D fitting, it should be a vector of 4 elements (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line 
            and (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements
            (like Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector
            collinear to the line and (x0, y0, z0) is a point on the line.
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitLine(System.Drawing.PointF[],System.Drawing.PointF@,System.Drawing.PointF@,Emgu.CV.CvEnum.DistType,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to 2D or 3D point set 
            </summary>
            <param name="points">Input vector of 2D points.</param>
            <param name="distType">The distance used for fitting </param>
            <param name="param">Numerical parameter (C) for some types of distances, if 0 then some optimal value is chosen</param>
            <param name="reps">Sufficient accuracy for radius (distance between the coordinate origin and the line),  0.01 would be a good default</param>
            <param name="aeps">Sufficient accuracy for angle, 0.01 would be a good default</param>
            <param name="direction">A normalized vector collinear to the line </param>
            <param name="pointOnLine">A point on the line.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RotatedRectangleIntersection(Emgu.CV.Structure.RotatedRect,Emgu.CV.Structure.RotatedRect,Emgu.CV.IOutputArray)">
            <summary>
            Finds out if there is any intersection between two rotated rectangles.
            </summary>
            <param name="rect1">First rectangle</param>
            <param name="rect2">Second rectangle</param>
            <param name="intersectingRegion">The output array of the verticies of the intersecting region. It returns at most 8 vertices. Stored as VectorOfPointF or Mat as Mx1 of type CV_32FC2.</param>
            <returns>The intersect type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoxPoints(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Calculates vertices of the input 2d box.
            </summary>
            <param name="box">The box</param>
            <returns>The four vertices of rectangles.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoxPoints(Emgu.CV.Structure.RotatedRect,Emgu.CV.IOutputArray)">
            <summary>
            Calculates vertices of the input 2d box.
            </summary>
            <param name="box">The box</param>
            <param name="points">The output array of four vertices of rectangles.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitEllipse(Emgu.CV.IInputArray)">
            <summary>
            Fits an ellipse around a set of 2D points.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns>The ellipse that fits best (in least-squares sense) to a set of 2D points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitEllipseAMS(Emgu.CV.IInputArray)">
            <summary>
            The function calculates the ellipse that fits a set of 2D points. The Approximate Mean Square (AMS) is used.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns>The rotated rectangle in which the ellipse is inscribed</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitEllipseDirect(Emgu.CV.IInputArray)">
            <summary>
            The function calculates the ellipse that fits a set of 2D points. The Direct least square (Direct) method by [58] is used.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns>The rotated rectangle in which the ellipse is inscribed</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvexHull(System.Drawing.PointF[],System.Boolean)">
            <summary>
            Finds convex hull of 2D point set using Sklansky's algorithm
            </summary>
            <param name="points">The points to find convex hull from</param>
            <param name="clockwise">Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards.</param>
            <returns>The convex hull of the points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvexHull(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,System.Boolean)">
            <summary>
            The function cvConvexHull2 finds convex hull of 2D point set using Sklansky's algorithm. 
            </summary>
            <param name="points"> Input 2D point set</param>
            <param name="hull">Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the hull elements are 0-based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, hull elements are the convex hull points themselves.</param>
            <param name="clockwise">Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards.</param>
            <param name="returnPoints">Operation flag. In case of a matrix, when the flag is true, the function returns convex hull points. Otherwise, it returns indices of the convex hull points. When the output array is std::vector, the flag is ignored, and the output depends on the type of the vector</param>
        </member>
        <member name="F:Emgu.CV.CvInvoke.MorphologyDefaultBorderValue">
            <summary>
            The default morphology value.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Erode(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:
            dst=erode(src,element):  dst(x,y)=min((x',y') in element)) src(x+x',y+y')
            The function supports the in-place mode. Erosion can be applied several (iterations) times. In case of color image each channel is processed independently.
            </summary>
            <param name="src">Source image. </param>
            <param name="dst">Destination image</param>
            <param name="element">Structuring element used for erosion. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used.</param>
            <param name="iterations">Number of times erosion is applied.</param>
            <param name="borderType">Pixel extrapolation method</param>
            <param name="borderValue">Border value in case of a constant border, use Constant for default</param>
            <param name="anchor">Position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Dilate(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken
            The function supports the in-place mode. Dilation can be applied several (iterations) times. In case of color image each channel is processed independently
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="element">Structuring element used for erosion. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used</param>
            <param name="iterations">Number of times erosion is applied</param>
            <param name="borderType">Pixel extrapolation method</param>
            <param name="borderValue">Border value in case of a constant border </param>
            <param name="anchor">Position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GaussianBlur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Blurs an image using a Gaussian filter.
            </summary>
            <param name="src">input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</param>
            <param name="dst">output image of the same size and type as src.</param>
            <param name="ksize">Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero�s and then they are computed from sigma* .</param>
            <param name="sigmaX">Gaussian kernel standard deviation in X direction.</param>
            <param name="sigmaY">Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height , respectively (see getGaussianKernel() for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</param>
            <param name="borderType">Pixel extrapolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Blur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Drawing.Point,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Blurs an image using the normalized box filter.
            </summary>
            <param name="src">input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="ksize">Blurring kernel size.</param>
            <param name="anchor">Anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.</param>
            <param name="borderType">Border mode used to extrapolate pixels outside of the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StackBlur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size)">
            <summary>
            The function applies and stackBlur to an image.
            stackBlur can generate similar results as Gaussian blur, and the time consumption does not increase with the increase of kernel size.
            It creates a kind of moving stack of colors whilst scanning through the image.Thereby it just has to add one new block of color to the right side
            of the stack and remove the leftmost color.The remaining colors on the topmost layer of the stack are either added on or reduced by one,
            depending on if they are on the right or on the left side of the stack.The only supported borderType is BORDER_REPLICATE.
            Original paper was proposed by Mario Klingemann, which can be found http://underdestruction.com/2004/02/25/stackblur-2004.
            </summary>
            <param name="src">Input image. The number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S or CV_32F.</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="ksize">Stack-blurring kernel size. The ksize.width and ksize.height can differ but they both must be positive and odd.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MedianBlur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Blurs an image using the median filter.
            </summary>
            <param name="src">Input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.</param>
            <param name="dst">Destination array of the same size and type as src.</param>
            <param name="ksize">Aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoxFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Drawing.Size,System.Drawing.Point,System.Boolean,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Blurs an image using the box filter.
            </summary>
            <param name="src">Input image.</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="ddepth">The output image depth (-1 to use src.depth()).</param>
            <param name="ksize">Blurring kernel size.</param>
            <param name="anchor">Anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.</param>
            <param name="normalize">Specifying whether the kernel is normalized by its area or not.</param>
            <param name="borderType">Border mode used to extrapolate pixels outside of the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SqrBoxFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Drawing.Size,System.Drawing.Point,System.Boolean,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Calculates the normalized sum of squares of the pixel values overlapping the filter.
            For every pixel(x, y) in the source image, the function calculates the sum of squares of those neighboring pixel values which overlap the filter placed over the pixel(x, y).
            The unnormalized square box filter can be useful in computing local image statistics such as the the local variance and standard deviation around the neighborhood of a pixel.
            </summary>
            <param name="src">input image</param>
            <param name="dst">output image of the same size and type as src</param>
            <param name="ddepth">the output image depth (-1 to use src.depth())</param>
            <param name="ksize">kernel size</param>
            <param name="anchor">kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel center</param>
            <param name="normalize">flag, specifying whether the kernel is to be normalized by it's area or not.</param>
            <param name="borderType">border mode used to extrapolate pixels outside of the image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BilateralFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Applies the bilateral filter to an image.
            </summary>
            <param name="src">Source 8-bit or floating-point, 1-channel or 3-channel image.</param>
            <param name="dst">Destination image of the same size and type as src .</param>
            <param name="d">Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace .</param>
            <param name="sigmaColor">Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace ) will be mixed together, resulting in larger areas of semi-equal color.</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d>0 , it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is proportional to sigmaSpace.</param>
            <param name="borderType">Border mode used to extrapolate pixels outside of the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sobel(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
             <summary>
             The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative. The first case corresponds to
             <pre> 
              |-1  0  1|
              |-2  0  2|
              |-1  0  1|</pre>
             kernel and the second one corresponds to
             <pre>
              |-1 -2 -1|
              | 0  0  0|
              | 1  2  1|</pre>
             or
             <pre>
              | 1  2  1|
              | 0  0  0|
              |-1 -2 -1|</pre>
             kernel, depending on the image origin (origin field of IplImage structure). No scaling is done, so the destination image usually has larger by absolute value numbers than the source image. To avoid overflow, the function requires 16-bit destination image if the source image is 8-bit. The result can be converted back to 8-bit using cvConvertScale or cvConvertScaleAbs functions. Besides 8-bit images the function can process 32-bit floating-point images. Both source and destination must be single-channel images of equal size or ROI size
             </summary>
             <param name="src">Source image.</param>
             <param name="dst">Destination image</param>
             <param name="ddepth">output image depth; the following combinations of src.depth() and ddepth are supported:
             <para> src.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F </para>
             <para> src.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F</para>
             <para> src.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F</para>
             <para>src.depth() = CV_64F, ddepth = -1/CV_64F</para>
             when ddepth=-1, the destination image will have the same depth as the source; in the case of 8-bit input images it will result in truncated derivatives.</param>
             <param name="xorder">Order of the derivative x </param>
             <param name="yorder">Order of the derivative y</param>
             <param name="kSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. </param>
            <param name="borderType">Pixel extrapolation method </param>
            <param name="scale">Optional scale factor for the computed derivative values</param>
            <param name="delta">Optional delta value that is added to the results prior to storing them in <paramref name="dst"/></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SpatialGradient(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Int32,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Calculates the first order image derivative in both x and y using a Sobel operator. Equivalent to calling:
            Sobel(src, dx, CV_16SC1, 1, 0, 3 );
            Sobel(src, dy, CV_16SC1, 0, 1, 3 );
            </summary>
            <param name="src">input image.</param>
            <param name="dx">output image with first-order derivative in x.</param>
            <param name="dy">output image with first-order derivative in y.</param>
            <param name="ksize">size of Sobel kernel. It must be 3.</param>
            <param name="borderType">pixel extrapolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Scharr(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Calculates the first x- or y- image derivative using Scharr operator.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image of the same size and the same number of channels as src.</param>
            <param name="ddepth">output image depth</param>
            <param name="dx">order of the derivative x.</param>
            <param name="dy">order of the derivative y.</param>
            <param name="scale">optional scale factor for the computed derivative values; by default, no scaling is applied </param>
            <param name="delta">optional delta value that is added to the results prior to storing them in dst.</param>
            <param name="borderType">pixel extrapolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Laplacian(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator:
            dst(x,y) = d2src/dx2 + d2src/dy2
            Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            |0  1  0|
            |1 -4  1|
            |0  1  0|
            Similar to cvSobel function, no scaling is done and the same combinations of input and output formats are supported. 
            </summary>
            <param name="src">Source image. </param>
            <param name="dst">Destination image. Should have type of float</param>
            <param name="ddepth">Desired depth of the destination image.</param>
            <param name="ksize">Aperture size used to compute the second-derivative filters.</param>
            <param name="scale">Optional scale factor for the computed Laplacian values. By default, no scaling is applied. </param>
            <param name="delta">Optional delta value that is added to the results prior to storing them in dst.</param>
            <param name="borderType"> Pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Canny(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,System.Boolean)">
             <summary>
             Finds the edges on the input <paramref name="image"/> and marks them in the output image edges using the Canny algorithm. The smallest of threshold1 and threshold2 is used for edge linking, the largest - to find initial segments of strong edges.
             </summary>
             <param name="image">Input image</param>
             <param name="edges">Image to store the edges found by the function</param>
             <param name="threshold1">The first threshold</param>
             <param name="threshold2">The second threshold.</param>
             <param name="apertureSize">Aperture parameter for Sobel operator </param>
            <param name="l2Gradient">a flag, indicating whether a more accurate norm should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default norm is enough ( L2gradient=false ).</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Canny(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Boolean)">
             <summary>
             Finds the edges on the input <paramref name="dx"/>, <paramref name="dy"/> and marks them in the output image edges using the Canny algorithm. The smallest of threshold1 and threshold2 is used for edge linking, the largest - to find initial segments of strong edges.
             </summary>
             <param name="dx">16-bit x derivative of input image</param>
             <param name="dy">16-bit y derivative of input image</param>
             <param name="edges">Image to store the edges found by the function</param>
             <param name="threshold1">The first threshold</param>
             <param name="threshold2">The second threshold.</param>
            <param name="l2Gradient">a flag, indicating whether a more accurate norm should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default norm is enough ( L2gradient=false ).</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CornerEigenValsAndVecs(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Calculates eigenvalues and eigenvectors of image blocks for corner detection.
            </summary>
            <param name="src">Input single-channel 8-bit or floating-point image.</param>
            <param name="dst">Image to store the results. It has the same size as src and the type CV_32FC.</param>
            <param name="blockSize">Neighborhood size</param>
            <param name="kSize">Aperture parameter for the Sobel operator.</param>
            <param name="borderType">Pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.IsContourConvex(Emgu.CV.IInputArray)">
            <summary>
            The function tests whether the input contour is convex or not. The contour must be simple, that is, without self-intersections. Otherwise, the function output is undefined.
            </summary>
            <param name="contour">Input vector of 2D points </param>
            <returns>true if input is convex</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.IntersectConvexConvex(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            finds intersection of two convex polygons
            </summary>
            <param name="p1">The first convex polygon</param>
            <param name="p2">The second convex polygon</param>
            <param name="p12">The intersection of the convex polygon</param>
            <param name="handleNested">Handle nest</param>
            <returns>Absolute value of area of intersecting polygon.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PointPolygonTest(Emgu.CV.IInputArray,System.Drawing.PointF,System.Boolean)">
            <summary>
            Determines whether the point is inside contour, outside, or lies on an edge (or coinsides with a vertex). It returns positive, negative or zero value, correspondingly
            </summary>
            <param name="contour">Input contour</param>
            <param name="pt">The point tested against the contour</param>
            <param name="measureDist">If != 0, the function estimates distance from the point to the nearest contour edge</param>
            <returns>
            When measureDist = false, the return value is &gt;0 (inside), &lt;0 (outside) and =0 (on edge), respectively. 
            When measureDist != true, it is a signed distance between the point and the nearest contour edge
            </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvexityDefects(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Finds the convexity defects of a contour.
            </summary>
            <param name="contour">Input contour</param>
            <param name="convexhull">Convex hull obtained using ConvexHull that should contain pointers or indices to the contour points, not the hull points themselves, i.e. return_points parameter in cvConvexHull2 should be 0</param>
            <param name="convexityDefects">The output vector of convexity defects. Each convexity defect is represented as 4-element integer vector (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices in the original contour of the convexity defect beginning, end and the farthest point, and fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the farthest contour point and the hull. That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinAreaRect(System.Drawing.PointF[])">
            <summary>
            Find the bounding rectangle for the specific array of points
            </summary>
            <param name="points">The collection of points</param>
            <returns>The bounding rectangle for the array of points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinAreaRect(Emgu.CV.IInputArray)">
            <summary>
            Finds a rotated rectangle of the minimum area enclosing the input 2D point set.
            </summary>
            <param name="points">Input vector of 2D points</param>
            <returns>a circumscribed rectangle of the minimal area for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinEnclosingCircle(System.Drawing.PointF[])">
             <summary>
             Finds the minimal circumscribed circle for 2D point set using iterative algorithm. It returns nonzero if the resultant circle contains all the input points and zero otherwise (i.e. algorithm failed)
             </summary>
             <param name="points">Sequence or array of 2D points</param>
            <returns>The minimal circumscribed circle for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinEnclosingCircle(Emgu.CV.IInputArray)">
             <summary>
             Finds the minimal circumscribed circle for 2D point set using iterative algorithm. It returns nonzero if the resultant circle contains all the input points and zero otherwise (i.e. algorithm failed)
             </summary>
             <param name="points">Sequence or array of 2D points</param>
            <returns>The minimal circumscribed circle for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinEnclosingTriangle(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Finds a triangle of minimum area enclosing a 2D point set and returns its area.
            </summary>
            <param name="points">Input vector of 2D points with depth CV_32S or CV_32F</param>
            <param name="triangles">Output vector of three 2D points defining the vertices of the triangle. The depth of the OutputArray must be CV_32F.</param>
            <returns>The triangle's area</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ApproxPolyDP(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Boolean)">
             <summary>
             Approximates a polygonal curve(s) with the specified precision.
             </summary>
            <param name="curve">Input vector of a 2D point</param>
             <param name="approxCurve">Result of the approximation. The type should match the type of the input curve. </param>
             <param name="epsilon">Parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation.</param>
             <param name="closed"> If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoundingRectangle(System.Drawing.Point[])">
            <summary>
            Returns the up-right bounding rectangle for 2d point set
            </summary>
            <param name="points"> Input 2D point set</param>
            <returns>The up-right bounding rectangle for 2d point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoundingRectangle(Emgu.CV.IInputArray)">
            <summary>
            Returns the up-right bounding rectangle for 2d point set
            </summary>
            <param name="points"> Input 2D point set, stored in std::vector or Mat.</param>
            <returns>The up-right bounding rectangle for 2d point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ContourArea(Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Calculates area of the whole contour or contour section. 
            </summary>
            <param name="contour">Input vector of 2D points (contour vertices), stored in std::vector or Mat. </param>
            <param name="oriented">Oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-clockwise).
            Using this feature you can determine orientation of a contour by taking the sign of an area. 
            By default, the parameter is false, which means that the absolute value is returned.</param>
            <returns>The area of the whole contour or contour section</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ArcLength(Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length
            </summary>
            <param name="curve">Sequence or array of the curve points</param>
            <param name="isClosed">
            Indicates whether the curve is closed or not.
            </param>
            <returns>Contour perimeter or a curve length</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Threshold(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.CvEnum.ThresholdType)">
            <summary>
            Applies a fixed-level threshold to each array element.
            The function applies fixed-level thresholding to a multiple-channel array. The function is typically used to get a bi-level (binary) image out of a grayscale image ( compare could be also used for this purpose) or for removing a noise, that is, filtering out pixels with too small or too large values. There are several types of thresholding supported by the function. They are determined by type parameter.
            </summary>
            <param name="src">Input array (multiple-channel, 8-bit or 32-bit floating point).</param>
            <param name="dst">Output array of the same size and type and the same number of channels as src.</param>
            <param name="threshold">Threshold value</param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="thresholdType">Thresholding type </param>
            <returns>The computed threshold value if Otsu's or Triangle methods used.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AdaptiveThreshold(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.AdaptiveThresholdType,Emgu.CV.CvEnum.ThresholdType,System.Int32,System.Double)">
            <summary>
            Transforms grayscale image to binary image. 
            Threshold calculated individually for each pixel. 
            For the method CV_ADAPTIVE_THRESH_MEAN_C it is a mean of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel
            neighborhood, subtracted by param1. 
            For the method CV_ADAPTIVE_THRESH_GAUSSIAN_C it is a weighted sum (gaussian) of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel neighborhood, subtracted by param1.
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="adaptiveType">Adaptive_method </param>
            <param name="thresholdType">Thresholding type. must be one of CV_THRESH_BINARY, CV_THRESH_BINARY_INV  </param>
            <param name="blockSize">The size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, ... </param>
            <param name="param1">Constant subtracted from mean or weighted mean. It may be negative. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindContours(Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.RetrType,Emgu.CV.CvEnum.ChainApproxMethod,System.Drawing.Point)">
            <summary>
            Retrieves contours from the binary image and returns the number of retrieved contours. The pointer firstContour is filled by the function. It will contain pointer to the first most outer contour or IntPtr.Zero if no contours is detected (if the image is completely black). Other contours may be reached from firstContour using h_next and v_next links. The sample in cvDrawContours discussion shows how to use contours for connected component detection. Contours can be also used for shape analysis and object recognition - see squares.c in OpenCV sample directory
            The function modifies the source image content
            </summary>
            <param name="image">The source 8-bit single channel image. Non-zero pixels are treated as 1s, zero pixels remain 0s - that is image treated as binary. To get such a binary image from grayscale, one may use cvThreshold, cvAdaptiveThreshold or cvCanny. The function modifies the source image content</param>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology.</param>
            <param name="mode">Retrieval mode</param>
            <param name="method">Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). </param>
            <param name="offset">Offset, by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context</param>
            <returns>The number of contours</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindContourTree(Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.CvEnum.ChainApproxMethod,System.Drawing.Point)">
            <summary>
            Retrieves contours from the binary image as a contour tree. The pointer firstContour is filled by the function. It is provided as a convenient way to obtain the hierarchy value as int[,].
            The function modifies the source image content
            </summary>
            <param name="image">The source 8-bit single channel image. Non-zero pixels are treated as 1s, zero pixels remain 0s - that is image treated as binary. To get such a binary image from grayscale, one may use cvThreshold, cvAdaptiveThreshold or cvCanny. The function modifies the source image content</param>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="method">Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). </param>
            <param name="offset">Offset, by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context</param>
            <returns>The contour hierarchy</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindContoursLinkRuns(Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArray)">
            <summary>
            Find contours using link runs algorithm.
            This function implements an algorithm different from FindContours:
            - doesn't allocate temporary image internally, thus it has reduced memory consumption;
            - supports CV_8UC1 images only;
            - outputs 2-level hierarhy only;
            - doesn't support approximation change other than CHAIN_APPROX_SIMPLE
            </summary>
            <param name="image">The source 8-bit single channel image. Non-zero pixels are treated as 1s, zero pixels remain 0s - that is image treated as binary.</param>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvtColor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Type,System.Type)">
            <summary>
            Converts input image from one color space to another. The function ignores colorModel and channelSeq fields of IplImage header, so the source image color space should be specified correctly (including order of the channels in case of RGB space, e.g. BGR means 24-bit format with B0 G0 R0 B1 G1 R1 ... layout, whereas RGB means 24-bit format with R0 G0 B0 R1 G1 B1 ... layout). 
            </summary>
            <param name="src">The source 8-bit (8u), 16-bit (16u) or single-precision floating-point (32f) image</param>
            <param name="dest">The destination image of the same data type as the source one. The number of channels may be different</param>
            <param name="srcColor">Source color type. </param>
            <param name="destColor">Destination color type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvtColor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorConversion,System.Int32)">
            <summary>
            Converts input image from one color space to another. The function ignores colorModel and channelSeq fields of IplImage header, so the source image color space should be specified correctly (including order of the channels in case of RGB space, e.g. BGR means 24-bit format with B0 G0 R0 B1 G1 R1 ... layout, whereas RGB means 24-bit format with R0 G0 B0 R1 G1 B1 ... layout). 
            </summary>
            <param name="src">The source 8-bit (8u), 16-bit (16u) or single-precision floating-point (32f) image</param>
            <param name="dst">The destination image of the same data type as the source one. The number of channels may be different</param>
            <param name="code">Color conversion operation that can be specifed using CV_src_color_space2dst_color_space constants </param>
            <param name="dstCn">number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code .</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvtColorTwoPlane(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorConversion)">
            <summary>
            Converts an image from one color space to another where the source image is stored in two planes.
            </summary>
            <param name="src1">8-bit image (CV_8U) of the Y plane.</param>
            <param name="src2">Image containing interleaved U/V plane.</param>
            <param name="dst">Output image.</param>
            <param name="code">Specifies the type of conversion. It can take any of the following values:
            COLOR_YUV2BGR_NV12
            COLOR_YUV2RGB_NV12
            COLOR_YUV2BGRA_NV12
            COLOR_YUV2RGBA_NV12
            COLOR_YUV2BGR_NV21
            COLOR_YUV2RGB_NV21
            COLOR_YUV2BGRA_NV21
            COLOR_YUV2RGBA_NV21
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Demosaicing(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorConversion,System.Int32)">
            <summary>
            main function for all demosaicing processes
            </summary>
            <param name="src">Input image: 8-bit unsigned or 16-bit unsigned</param>
            <param name="dst">Output image of the same size and depth as src</param>
            <param name="code">Color space conversion code</param>
            <param name="dstCn">Number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughCircles(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.HoughModes,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in grayscale image using some modification of Hough transform
            </summary>
            <param name="image">The input 8-bit single-channel grayscale image</param>
            <param name="circles">The storage for the circles detected. It can be a memory storage (in this case a sequence of circles is created in the storage and returned by the function) or single row/single column matrix (CvMat*) of type CV_32FC3, to which the circles' parameters are written. The matrix header is modified by the function so its cols or rows will contain a number of lines detected. If circle_storage is a matrix and the actual number of lines exceeds the matrix size, the maximum possible number of circles is returned. Every circle is encoded as 3 floating-point numbers: center coordinates (x,y) and the radius</param>
            <param name="method">Currently, the only implemented method is CV_HOUGH_GRADIENT</param>
            <param name="dp">Resolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice smaller width and height, etc</param>
            <param name="minDist">Minimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed</param>
            <param name="param1">The first method-specific parameter. In case of CV_HOUGH_GRADIENT it is the higher threshold of the two passed to Canny edge detector (the lower one will be twice smaller). </param>
            <param name="param2">The second method-specific parameter. In case of CV_HOUGH_GRADIENT it is accumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first</param>
            <param name="minRadius">Minimal radius of the circles to search for</param>
            <param name="maxRadius">Maximal radius of the circles to search for. By default the maximal radius is set to max(image_width, image_height). </param>
            <returns>Pointer to the sequence of circles</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughCircles(Emgu.CV.IInputArray,Emgu.CV.CvEnum.HoughModes,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in a grayscale image using the Hough transform
            </summary>
            <param name="image">8-bit, single-channel, grayscale input image.</param>
            <param name="method">Detection method to use. Currently, the only implemented method is CV_HOUGH_GRADIENT , which is basically 21HT</param>
            <param name="dp">Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height.</param>
            <param name="minDist">Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed.</param>
            <param name="param1">First method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the higher threshold of the two passed to the Canny() edge detector (the lower one is twice smaller).</param>
            <param name="param2">Second method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first.</param>
            <param name="minRadius"> Minimum circle radius.</param>
            <param name="maxRadius">Maximum circle radius.</param>
            <returns>The circles detected</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughLines(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines in a binary image using the standard Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image. The image may be modified by the function.</param>
            <param name="lines">Output vector of lines. Each line is represented by a two-element vector</param>
            <param name="rho">Distance resolution of the accumulator in pixels.</param>
            <param name="theta">Angle resolution of the accumulator in radians.</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes (&gt; threshold)</param>
            <param name="srn">For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive.</param>
            <param name="stn"> For the multi-scale Hough transform, it is a divisor for the distance resolution theta</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughLinesP(Emgu.CV.IInputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image. The image may be modified by the function.</param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes</param>
            <param name="minLineLength">Minimum line length. Line segments shorter than that are rejected.</param>
            <param name="maxGap">Maximum allowed gap between points on the same line to link them.</param>
            <returns>The found line segments</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughLinesP(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image. The image may be modified by the function.</param>
            <param name="lines"> Output vector of lines. Each line is represented by a 4-element vector (x1, y1, x2, y2)</param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes</param>
            <param name="minLineLength">Minimum line length. Line segments shorter than that are rejected.</param>
            <param name="maxGap">Maximum allowed gap between points on the same line to link them.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Moments(Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characeteristics including 7 Hu invariants.
            </summary>
            <param name="arr">Image (1-channel or 3-channel with COI set) or polygon (CvSeq of points or a vector of points)</param>
            <param name="binaryImage">(For images only) If the flag is true, all the zero pixel values are treated as zeroes, all the others are treated as 1s</param>
            <returns>The moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MatchTemplate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.TemplateMatchingType,Emgu.CV.IInputArray)">
            <summary>
            This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is WxH and templ is wxh then result must be W-w+1xH-h+1.</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
            <param name="mask">Mask of searched template. It must have the same datatype and size with templ. It is not set by default.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MatchShapes(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.ContoursMatchType,System.Double)">
            <summary>
            Compares two shapes. The 3 implemented methods all use Hu moments
            </summary>
            <param name="contour1">First contour or grayscale image</param>
            <param name="contour2">Second contour or grayscale image</param>
            <param name="method">Comparison method</param>
            <param name="parameter">Method-specific parameter (is not used now)</param>
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetStructuringElement(Emgu.CV.CvEnum.ElementShape,System.Drawing.Size,System.Drawing.Point)">
            <summary>
            Returns a structuring element of the specified size and shape for morphological operations.
            </summary>
            <param name="shape">Element shape</param>
            <param name="ksize">Size of the structuring element.</param>
            <param name="anchor">Anchor position within the element. The value (-1, -1) means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted.</param>
            <returns>The structuring element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MorphologyEx(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.MorphOp,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Performs advanced morphological transformations.
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="kernel">Structuring element.</param>
            <param name="operation">Type of morphological operation.</param>
            <param name="iterations">Number of times erosion and dilation are applied.</param>
            <param name="borderType">Pixel extrapolation method.</param>
            <param name="anchor">Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</param>
            <param name="borderValue">Border value in case of a constant border. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EqualizeHist(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            The algorithm normalizes brightness and increases contrast of the image
            </summary>
            <param name="src">The input 8-bit single-channel image</param>
            <param name="dst">The output image of the same size and the same data type as src</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcHist(Emgu.CV.IInputArrayOfArrays,System.Int32[],Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32[],System.Single[],System.Boolean)">
            <summary>
            Calculates a histogram of a set of arrays.
            </summary>
            <param name="images">Source arrays. They all should have the same depth, CV_8U, CV_16U or CV_32F , and the same size. Each of them can have an arbitrary number of channels.</param>
            <param name="channels">List of the channels used to compute the histogram. </param>
            <param name="mask">Optional mask. If the matrix is not empty, it must be an 8-bit array of the same size as images[i] . The non-zero mask elements mark the array elements counted in the histogram.</param>
            <param name="hist">Output histogram</param>
            <param name="histSize">Array of histogram sizes in each dimension.</param>
            <param name="ranges">Array of the dims arrays of the histogram bin boundaries in each dimension.</param>
            <param name="accumulate">Accumulation flag. If it is set, the histogram is not cleared in the beginning when it is allocated. This feature enables you to compute a single histogram from several sets of arrays, or to update the histogram in time.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcBackProject(Emgu.CV.IInputArrayOfArrays,System.Int32[],Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single[],System.Double)">
            <summary>
            Calculates the back projection of a histogram.
            </summary>
            <param name="images">Source arrays. They all should have the same depth, CV_8U or CV_32F , and the same size. Each of them can have an arbitrary number of channels.</param>
            <param name="channels">Number of source images.</param>
            <param name="hist">Input histogram that can be dense or sparse.</param>
            <param name="backProject">Destination back projection array that is a single-channel array of the same size and depth as images[0] .</param>
            <param name="ranges">Array of arrays of the histogram bin boundaries in each dimension.</param>
            <param name="scale"> Optional scale factor for the output back projection.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CompareHist(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.HistogramCompMethod)">
            <summary>
            Compares two histograms.
            </summary>
            <param name="h1">First compared histogram.</param>
            <param name="h2">Second compared histogram of the same size as H1 .</param>
            <param name="method">Comparison method</param>
            <returns>The distance between the histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Accumulate(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Adds the whole image or its selected region to accumulator sum
            </summary>
            <param name="src">Input image, 1- or 3-channel, 8-bit or 32-bit floating point. (each channel of multi-channel image is processed independently). </param>
            <param name="dst">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point. </param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AccumulateSquare(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Adds the input <paramref name="src"/> or its selected region, raised to power 2, to the accumulator sqsum
            </summary>
            <param name="src">Input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently)</param>
            <param name="dst">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AccumulateProduct(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Adds product of 2 images or thier selected regions to accumulator acc
            </summary>
            <param name="src1">First input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently)</param>
            <param name="src2">Second input image, the same format as the first one</param>
            <param name="dst">Accumulator of the same number of channels as input images, 32-bit or 64-bit floating-point</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AccumulateWeighted(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Double,Emgu.CV.IInputArray)">
            <summary>
            Calculates weighted sum of input <paramref name="src"/> and the accumulator acc so that acc becomes a running average of frame sequence:
            acc(x,y)=(1-<paramref name="alpha"/>) * acc(x,y) + <paramref name="alpha"/> * image(x,y) if mask(x,y)!=0
            where <paramref name="alpha"/> regulates update speed (how fast accumulator forgets about previous frames). 
            </summary>
            <param name="src">Input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently). </param>
            <param name="dst">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point. </param>
            <param name="alpha">Weight of input image</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CornerHarris(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Runs the Harris edge detector on image. Similarly to cvCornerMinEigenVal and cvCornerEigenValsAndVecs, for each pixel it calculates 2x2 gradient covariation matrix M over block_size x block_size neighborhood. Then, it stores
            det(M) - k*trace(M)^2
            to the destination image. Corners in the image can be found as local maxima of the destination image.
            </summary>
            <param name="image">Input image</param>
            <param name="harrisResponse">Image to store the Harris detector responces. Should have the same size as image </param>
            <param name="blockSize">Neighborhood size </param>
            <param name="apertureSize">Aperture parameter for Sobel operator (see cvSobel). format. In the case of floating-point input format this parameter is the number of the fixed float filter used for differencing. </param>
            <param name="k">Harris detector free parameter.</param>
            <param name="borderType">Pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CornerSubPix(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </summary>
            <param name="image">Input image</param>
            <param name="corners">Initial coordinates of the input corners and refined coordinates on output</param>
            <param name="win">Half sizes of the search window. For example, if win=(5,5) then 5*2+1 x 5*2+1 = 11 x 11 search window is used</param>
            <param name="zeroZone">Half size of the dead region in the middle of the search zone over which the summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such size</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after certain number of iteration or when a required accuracy is achieved. The criteria may specify either of or both the maximum number of iteration and the required accuracy</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Integral(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates one or more integral images for the source image 
            Using these integral images, one may calculate sum, mean, standard deviation over arbitrary up-right or rotated rectangular region of the image in a constant time.
            It makes possible to do a fast blurring or fast block correlation with variable window size etc. In case of multi-channel images sums for each channel are accumulated independently. 
            </summary>
            <param name="image">The source image, WxH, 8-bit or floating-point (32f or 64f) image.</param>
            <param name="sum">The integral image, W+1xH+1, 32-bit integer or double precision floating-point (64f). </param>
            <param name="sqsum">The integral image for squared pixel values, W+1xH+1, double precision floating-point (64f). </param>
            <param name="tiltedSum">The integral for the image rotated by 45 degrees, W+1xH+1, the same data type as sum.</param>
            <param name="sdepth">Desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or CV_64F.</param>
            <param name="sqdepth">Desired depth of the integral image of squared pixel values, CV_32F or CV_64F.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DistanceTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DistType,System.Int32,Emgu.CV.CvEnum.DistLabelType)">
            <summary>
            Calculates distance to closest zero pixel for all non-zero pixels of source image
            </summary>
            <param name="src">Source 8-bit single-channel (binary) image.</param>
            <param name="dst">Output image with calculated distances (32-bit floating-point, single-channel). </param>
            <param name="distanceType">Type of distance</param>
            <param name="maskSize">Size of distance transform mask; can be 3 or 5.
            In case of CV_DIST_L1 or CV_DIST_C the parameter is forced to 3, because 3x3 mask gives the same result as 5x5 yet it is faster.</param>
            <param name="labels">The optional output 2d array of labels of integer type and the same size as src and dst. Can be null if not needed</param>
            <param name="labelType">Type of the label array to build. If labelType==CCOMP then each connected component of zeros in src (as well as all the non-zero pixels closest to the connected component) will be assigned the same label. If labelType==PIXEL then each zero pixel (and all the non-zero pixels closest to it) gets its own label.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FloodFill(Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Drawing.Rectangle@,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.Connectivity,Emgu.CV.CvEnum.FloodFillType)">
            <summary>
            Fills a connected component with given color.
            </summary>
            <param name="src">Input 1- or 3-channel, 8-bit or floating-point image. It is modified by the function unless CV_FLOODFILL_MASK_ONLY flag is set.</param>
            <param name="seedPoint">The starting point.</param>
            <param name="newVal">New value of repainted domain pixels.</param>
            <param name="loDiff">Maximal lower brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="upDiff">Maximal upper brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="flags">The operation flags. </param>
            <param name="mask">Operation mask,
            should be singe-channel 8-bit image, 2 pixels wider and 2 pixels taller than image.
            If not IntPtr.Zero, the function uses and updates the mask, so user takes responsibility of initializing mask content.
            Floodfilling can't go across non-zero pixels in the mask, for example, an edge detector output can be used as a mask to stop filling at edges.
            Or it is possible to use the same mask in multiple calls to the function to make sure the filled area do not overlap.
            Note: because mask is larger than the filled image, pixel in mask that corresponds to (x,y) pixel in image will have coordinates (x+1,y+1).</param>
            <param name="rect">Output parameter set by the function to the minimum bounding rectangle of the repainted domain.</param>
            <param name="connectivity">Flood fill connectivity</param>
            <returns>The area of the connected component</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PyrMeanShiftFiltering(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Filters image using meanshift algorithm
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Result image</param>
            <param name="sp">The spatial window radius.</param>
            <param name="sr">The color window radius.</param>
            <param name="maxLevel">Maximum level of the pyramid for the segmentation. Use 1 as default value</param>
            <param name="termcrit">Termination criteria: when to stop meanshift iterations. Use new MCvTermCriteria(5, 1) as default value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertMaps(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Boolean)">
            <summary>
            Converts image transformation maps from one representation to another.
            </summary>
            <param name="map1">The first input map of type CV_16SC2 , CV_32FC1 , or CV_32FC2 .</param>
            <param name="map2">The second input map of type CV_16UC1 , CV_32FC1 , or none (empty matrix), respectively.</param>
            <param name="dstmap1">The first output map that has the type dstmap1type and the same size as src .</param>
            <param name="dstmap2">The second output map.</param>
            <param name="dstmap1Depth">Depth type of the first output map that should be CV_16SC2 , CV_32FC1 , or CV_32FC2.</param>
            <param name="dstmap1Channels">The number of channels in the dst map.</param>
            <param name="nninterpolation">Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EMD(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DistType,Emgu.CV.IInputArray,System.Single[],Emgu.CV.IOutputArray)">
            <summary>
            Computes the 'minimal work' distance between two weighted point configurations.
            </summary>
            <param name="signature1">First signature, a size1 x dims + 1  floating-point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-defined cost matrix is used.</param>
            <param name="signature2">Second signature of the same format as signature1 , though the number of rows may be different. The total weights may be different. In this case an extra 'dummy' point is added to either signature1 or signature2</param>
            <param name="distType"> Used metric. CV_DIST_L1, CV_DIST_L2 , and CV_DIST_C stand for one of the standard metrics. CV_DIST_USER means that a pre-calculated cost matrix cost is used.</param>
            <param name="cost">User-defined size1 x size2 cost matrix. Also, if a cost matrix is used, lower boundary lowerBound cannot be calculated because it needs a metric function.</param>
            <param name="lowerBound">Optional input/output parameter: lower boundary of a distance between the two signatures that is a distance between mass centers. The lower boundary may not be calculated if the user-defined cost matrix is used, the total weights of point configurations are not equal, or if the signatures consist of weights only (the signature matrices have a single column). </param>
            <param name="flow"> Resultant size1 x size2 flow matrix</param>
            <returns>The 'minimal work' distance between two weighted point configurations.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PhaseCorrelate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double@)">
            <summary>
            The function is used to detect translational shifts that occur between two images. The operation takes advantage of the Fourier shift theorem for detecting the translational shift in the frequency domain. It can be used for fast image registration as well as motion estimation. 
            </summary>
            <param name="src1">Source floating point array (CV_32FC1 or CV_64FC1)</param>
            <param name="src2">Source floating point array (CV_32FC1 or CV_64FC1)</param>
            <param name="window">Floating point array with windowing coefficients to reduce edge effects (optional).</param>
            <param name="response">Signal power within the 5x5 centroid around the peak, between 0 and 1 </param>
            <returns>The translational shifts that occur between two images</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CreateHanningWindow(Emgu.CV.IOutputArray,System.Drawing.Size,Emgu.CV.CvEnum.DepthType)">
            <summary>
            This function computes a Hanning window coefficients in two dimensions.
            </summary>
            <param name="dst">Destination array to place Hann coefficients in</param>
            <param name="winSize">The window size specifications</param>
            <param name="type">Created array type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Line(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image or ROI rectangle. For non-antialiased lines with integer coordinates the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.
            </summary>
            <param name="img">The image</param>
            <param name="pt1">First point of the line segment</param>
            <param name="pt2">Second point of the line segment</param>
            <param name="color">Line color</param>
            <param name="thickness">Line thickness. </param>
            <param name="lineType">Type of the line:
            8 (or 0) - 8-connected line.
            4 - 4-connected line.
            CV_AA - antialiased line. 
            </param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ArrowedLine(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32,System.Double)">
            <summary>
            Draws a arrow segment pointing from the first point to the second one.
            </summary>
            <param name="img">Image</param>
            <param name="pt1">The point the arrow starts from.</param>
            <param name="pt2">The point the arrow points to.</param>
            <param name="color">Line color.</param>
            <param name="thickness">Line thickness.</param>
            <param name="lineType">Type of the line.</param>
            <param name="shift">Number of fractional bits in the point coordinates.</param>
            <param name="tipLength">The length of the arrow tip in relation to the arrow length</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Polylines(Emgu.CV.IInputOutputArray,System.Drawing.Point[],System.Boolean,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a single or multiple polygonal curves
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array points</param>
            <param name="isClosed">
            Indicates whether the polylines must be drawn closed. 
            If !=0, the function draws the line from the last vertex of every contour to the first vertex.
            </param>
            <param name="color">Polyline color</param>
            <param name="thickness">Thickness of the polyline edges</param>
            <param name="lineType">Type of the line segments, see cvLine description</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Polylines(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,System.Boolean,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a single or multiple polygonal curves
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of pointers to polylines</param>
            <param name="isClosed">
            Indicates whether the polylines must be drawn closed. 
            If !=0, the function draws the line from the last vertex of every contour to the first vertex.
            </param>
            <param name="color">Polyline color</param>
            <param name="thickness">Thickness of the polyline edges</param>
            <param name="lineType">Type of the line segments, see cvLine description</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Rectangle(Emgu.CV.IInputOutputArray,System.Drawing.Rectangle,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a rectangle specified by a CvRect structure
            </summary>
            /// <param name="img">Image</param>
            <param name="rect">The rectangle to be drawn</param>
            <param name="color">Line color </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle.</param>
            <param name="lineType">Type of the line</param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConnectedComponents(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.LineType,Emgu.CV.CvEnum.DepthType,Emgu.CV.CvEnum.ConnectedComponentsAlgorithmsTypes)">
            <summary>
            Computes the connected components labeled image of boolean image
            </summary>
            <param name="image">The boolean image</param>
            <param name="labels">The connected components labeled image of boolean image</param>
            <param name="connectivity">4 or 8 way connectivity</param>
            <param name="labelType">Specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image</param>
            <param name="cclType">connected components algorithm type </param>
            <returns>N, the total number of labels [0, N-1] where 0 represents the background label.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConnectedComponentsWithStats(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.LineType,Emgu.CV.CvEnum.DepthType,Emgu.CV.CvEnum.ConnectedComponentsAlgorithmsTypes)">
            <summary>
            Computes the connected components labeled image of boolean image
            </summary>
            <param name="image">The boolean image</param>
            <param name="labels">The connected components labeled image of boolean image</param>
            <param name="stats">Statistics output for each label, including the background label, see below for available statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of cv::ConnectedComponentsTypes. The data type is CV_32S</param>
            <param name="centroids">Centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.</param>
            <param name="connectivity">4 or 8 way connectivity</param>
            <param name="labelType">Specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image</param>
            <param name="cclType">connected components algorithm type </param>
            <returns>N, the total number of labels [0, N-1] where 0 represents the background label.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HuMoments(Emgu.CV.Moments,Emgu.CV.IOutputArray)">
            <summary>
            Calculates seven Hu invariants
            </summary>
            <param name="hu">The output Hu moments. e.g. a Mat can be passed here.</param>
            <param name="m">The image moment</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HuMoments(Emgu.CV.Moments)">
            <summary>
            Calculates seven Hu invariants
            </summary>
            <param name="m">The image moment</param>
            <returns>The output Hu moments.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetGaussianKernel(System.Int32,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Returns Gaussian filter coefficients.
            </summary>
            <param name="ksize">Aperture size. It should be odd and positive.</param>
            <param name="sigma">Gaussian standard deviation. If it is non-positive, it is computed from ksize.</param>
            <param name="ktype">Type of filter coefficients. It can be CV_32F or CV_64F </param>
            <returns>Gaussian filter coefficients.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDerivKernels(Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,System.Boolean,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Returns filter coefficients for computing spatial image derivatives.
            </summary>
            <param name="kx">Output matrix of row filter coefficients.</param>
            <param name="ky">Output matrix of column filter coefficients.</param>
            <param name="dx">Derivative order in respect of x.</param>
            <param name="dy">Derivative order in respect of y.</param>
            <param name="ksize">Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.</param>
            <param name="normalize">Flag indicating whether to normalize (scale down) the filter coefficients or not. </param>
            <param name="ktype">Type of filter coefficients. It can be CV_32f or CV_64F .</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetGaborKernel(System.Drawing.Size,System.Double,System.Double,System.Double,System.Double,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Returns Gabor filter coefficients.
            </summary>
            <param name="ksize">Size of the filter returned.</param>
            <param name="sigma">Standard deviation of the gaussian envelope.</param>
            <param name="theta">Orientation of the normal to the parallel stripes of a Gabor function.</param>
            <param name="lambd">Wavelength of the sinusoidal factor.</param>
            <param name="gamma">Spatial aspect ratio.</param>
            <param name="psi">Phase offset.</param>
            <param name="ktype">Type of filter coefficients. It can be CV_32F or CV_64F .</param>
            <returns>Gabor filter coefficients.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectangles(Emgu.CV.Util.VectorOfRect,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectangles(Emgu.CV.Util.VectorOfRect,Emgu.CV.Util.VectorOfInt,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="weights">Weights</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectangles(Emgu.CV.Util.VectorOfRect,System.Int32,System.Double,Emgu.CV.Util.VectorOfInt,Emgu.CV.Util.VectorOfDouble)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
            <param name="weights">weights</param>
            <param name="levelWeights">level weights</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectangles(Emgu.CV.Util.VectorOfRect,Emgu.CV.Util.VectorOfInt,Emgu.CV.Util.VectorOfDouble,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="rejectLevels">reject levels</param>
            <param name="levelWeights">level weights</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectanglesMeanshift(Emgu.CV.Util.VectorOfRect,Emgu.CV.Util.VectorOfDouble,Emgu.CV.Util.VectorOfDouble,System.Double,System.Drawing.Size)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="foundWeights">found weights</param>
            <param name="foundScales">found scales</param>
            <param name="detectThreshold">detect threshold, use 0 for default</param>
            <param name="winDetSize">win det size, use (64, 128) for default</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolveLP(Emgu.CV.Mat,Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Solve given (non-integer) linear programming problem using the Simplex Algorithm (Simplex Method). 
            What we mean here by “linear programming problem” (or LP problem, for short) can be formulated as:
            Maximize c x subject to: Ax &lt;= b and x &gt;= 0 
            </summary>
            <param name="functionMatrix">This row-vector corresponds to c in the LP problem formulation (see above). It should contain 32- or 64-bit floating point numbers. As a convenience, column-vector may be also submitted, in the latter case it is understood to correspond to c^T.</param>
            <param name="constraintMatrix">m-by-n+1 matrix, whose rightmost column corresponds to b in formulation above and the remaining to A. It should containt 32- or 64-bit floating point numbers.</param>
            <param name="zMatrix">The solution will be returned here as a column-vector - it corresponds to c in the formulation above. It will contain 64-bit floating point numbers.</param>
            <returns>The return codes</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DenoiseTVL1(Emgu.CV.Mat[],Emgu.CV.Mat,System.Double,System.Int32)">
            <summary>
            Primal-dual algorithm is an algorithm for solving special types of variational problems (that is, finding a function to minimize some functional).
            As the image denoising, in particular, may be seen as the variational problem, primal-dual algorithm then can be used to perform 
            denoising and this is exactly what is implemented.
            </summary>
            <param name="observations">This array should contain one or more noised versions of the image that is to be restored.</param>
            <param name="result">Here the denoised image will be stored. There is no need to do pre-allocation of storage space, as it will be automatically allocated, if necessary.</param>
            <param name="lambda">Corresponds to  in the formulas above. As it is enlarged, the smooth (blurred) images are treated more favorably than detailed (but maybe more noised) ones. Roughly speaking, as it becomes smaller, the result will be more blur but more sever outliers will be removed.</param>
            <param name="niters">Number of iterations that the algorithm will run. Of course, as more iterations as better, but it is hard to quantitatively refine this statement, so just use the default and increase it if the results are poor.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Inpaint(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.InpaintType)">
            <summary>
            Reconstructs the selected image area from the pixel near the area boundary. The function may be used to remove dust and scratches from a scanned photo, or to remove undesirable objects from still images or video.
            </summary>
            <param name="src">The input 8-bit 1-channel or 3-channel image</param>
            <param name="mask">The inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that needs to be inpainted</param>
            <param name="dst">The output image of the same format and the same size as input</param>
            <param name="flags">The inpainting method</param>
            <param name="inpaintRadius">The radius of circular neighborhood of each point inpainted that is considered by the algorithm</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FastNlMeansDenoising(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Int32,System.Int32)">
            <summary>
            Perform image denoising using Non-local Means Denoising algorithm: 
            http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ 
            with several computational optimizations. Noise expected to be a Gaussian white noise.
            </summary>
            <param name="src">Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FastNlMeansDenoisingColored(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Perform image denoising using Non-local Means Denoising algorithm (modified for color image): 
            http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ 
            with several computational optimizations. Noise expected to be a Gaussian white noise.
            The function converts image to CIELAB colorspace and then separately denoise L and AB components with given h parameters using fastNlMeansDenoising function.
            </summary>
            <param name="src">Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="hColor">The same as h but for color components. For most images value equals 10 will be enought to remove colored noise and do not distort colors.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EdgePreservingFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.EdgePreservingFilterFlag,System.Single,System.Single)">
            <summary>
            Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing filters are used in many different applications.
            </summary>
            <param name="src">Input 8-bit 3-channel image</param>
            <param name="dst">Output 8-bit 3-channel image</param>
            <param name="flags">Edge preserving filters</param>
            <param name="sigmaS">Range between 0 to 200</param>
            <param name="sigmaR">Range between 0 to 1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DetailEnhance(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single)">
            <summary>
            This filter enhances the details of a particular image.
            </summary>
            <param name="src">Input 8-bit 3-channel image</param>
            <param name="dst">Output image with the same size and type as src</param>
            <param name="sigmaS">Range between 0 to 200</param>
            <param name="sigmaR">Range between 0 to 1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PencilSketch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Pencil-like non-photorealistic line drawing
            </summary>
            <param name="src">Input 8-bit 3-channel image</param>
            <param name="dst1">Output 8-bit 1-channel image</param>
            <param name="dst2">Output image with the same size and type as src</param>
            <param name="sigmaS">Range between 0 to 200</param>
            <param name="sigmaR">Range between 0 to 1</param>
            <param name="shadeFactor">Range between 0 to 0.1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Stylization(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single)">
            <summary>
            Stylization aims to produce digital imagery with a wide variety of effects not focused on photorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low contrast while preserving, or enhancing, high-contrast features.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR"> Range between 0 to 1.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ColorChange(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Given an original color image, two differently colored versions of this image can be mixed seamlessly.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src .</param>
            <param name="redMul">R-channel multiply factor. Multiplication factor is between .5 to 2.5.</param>
            <param name="greenMul">G-channel multiply factor. Multiplication factor is between .5 to 2.5.</param>
            <param name="blueMul">B-channel multiply factor. Multiplication factor is between .5 to 2.5.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.IlluminationChange(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single)">
            <summary>
            Applying an appropriate non-linear transformation to the gradient field inside the selection and then integrating back with a Poisson solver, modifies locally the apparent illumination of an image.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="alpha">Value ranges between 0-2.</param>
            <param name="beta">Value ranges between 0-2.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.TextureFlattening(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Int32)">
            <summary>
            By retaining only the gradients at edge locations, before integrating with the Poisson solver, one washes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge Detector is used.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="lowThreshold">Range from 0 to 100.</param>
            <param name="highThreshold">Value &gt; 100</param>
            <param name="kernelSize">The size of the Sobel kernel to be used.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Decolor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Transforms a color image to a grayscale image. It is a basic tool in digital printing, stylized black-and-white photograph rendering, and in many single channel image processing applications 
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="grayscale">Output 8-bit 1-channel image.</param>
            <param name="colorBoost">Output 8-bit 3-channel image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SeamlessClone(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Point,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CloningMethod)">
            <summary>
            Image editing tasks concern either global changes (color/intensity corrections, filters, deformations) or local changes concerned to a selection. Here we are interested in achieving local changes, ones that are restricted to a region manually selected (ROI), in a seamless and effortless manner. The extent of the changes ranges from slight distortions to complete replacement by novel content 
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="p">Point in dst image where object is placed.</param>
            <param name="blend">Output image with the same size and type as dst.</param>
            <param name="flags">Cloning method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CamShift(Emgu.CV.IInputArray,System.Drawing.Rectangle@,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Implements CAMSHIFT object tracking algorithm ([Bradski98]). First, it finds an object center using cvMeanShift and, after that, calculates the object size and orientation. 
            </summary>
            <param name="probImage">Back projection of object histogram </param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished</param>
            <returns>Circumscribed box for the object, contains object size and orientation</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MeanShift(Emgu.CV.IInputArray,System.Drawing.Rectangle@,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the object center given its back projection and initial position of search window. The iterations are made until the search window center moves by less than the given value and/or until the function has done the maximum number of iterations. 
            </summary>
            <param name="probImage">Back projection of object histogram</param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished. </param>
            <returns>The number of iterations made</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BuildOpticalFlowPyramid(Emgu.CV.IInputArray,Emgu.CV.IOutputArrayOfArrays,System.Drawing.Size,System.Int32,System.Boolean,Emgu.CV.CvEnum.BorderType,Emgu.CV.CvEnum.BorderType,System.Boolean)">
            <summary>
            Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.
            </summary>
            <param name="img">8-bit input image.</param>
            <param name="pyramid">Output pyramid.</param>
            <param name="winSize">Window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels.</param>
            <param name="maxLevel">0-based maximal pyramid level number.</param>
            <param name="withDerivatives">Set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally.</param>
            <param name="pyrBorder">The border mode for pyramid layers.</param>
            <param name="derivBorder">The border mode for gradients.</param>
            <param name="tryReuseInputImage">put ROI of input image into the pyramid if possible. You can pass false to force data copying.</param>
            <returns>Number of levels in constructed pyramid. Can be less than maxLevel.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.UpdateMotionHistory(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Double,System.Double)">
            <summary>
            Updates the motion history image as following:
            mhi(x,y)=timestamp  if silhouette(x,y)!=0
                    0          if silhouette(x,y)=0 and mhi(x,y)&lt;timestamp-duration
                    mhi(x,y)   otherwise
            That is, MHI pixels where motion occurs are set to the current timestamp, while the pixels where motion happened far ago are cleared. 
            </summary>
            <param name="silhouette">Silhouette mask that has non-zero pixels where the motion occurs. </param>
            <param name="mhi">Motion history image, that is updated by the function (single-channel, 32-bit floating-point) </param>
            <param name="timestamp">Current time in milliseconds or other units. </param>
            <param name="duration">Maximal duration of motion track in the same units as timestamp. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcMotionGradient(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32)">
             <summary>
             Calculates the derivatives Dx and Dy of mhi and then calculates gradient orientation as:
            orientation(x,y)=arctan(Dy(x,y)/Dx(x,y))
            where both Dx(x,y)' and Dy(x,y)' signs are taken into account (as in cvCartToPolar function). After that mask is filled to indicate where the orientation is valid (see delta1 and delta2 description). 
             </summary>
             <param name="mhi">Motion history image</param>
             <param name="mask">Mask image; marks pixels where motion gradient data is correct. Output parameter.</param>
             <param name="orientation">Motion gradient orientation image; contains angles from 0 to ~360. </param>
             <param name="delta1">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2). </param>
             <param name="delta2">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2).</param>
             <param name="apertureSize">Aperture size of derivative operators used by the function: CV_SCHARR, 1, 3, 5 or 7 (see cvSobel). </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SegmentMotion(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Util.VectorOfRect,System.Double,System.Double)">
            <summary>
            Finds all the motion segments and marks them in segMask with individual values each (1,2,...). It also returns a sequence of CvConnectedComp structures, one per each motion components. After than the motion direction for every component can be calculated with cvCalcGlobalOrientation using extracted mask of the particular component (using cvCmp) 
            </summary>
            <param name="mhi">Motion history image</param>
            <param name="segMask">Image where the mask found should be stored, single-channel, 32-bit floating-point</param>
            <param name="timestamp">Current time in milliseconds or other units</param>
            <param name="segThresh">Segmentation threshold; recommended to be equal to the interval between motion history "steps" or greater</param>
            <param name="boundingRects">Vector containing ROIs of motion connected components.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcGlobalOrientation(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double,System.Double)">
            <summary>
            Calculates the general motion direction in the selected region and returns the angle between 0 and 360. At first the function builds the orientation histogram and finds the basic orientation as a coordinate of the histogram maximum. After that the function calculates the shift relative to the basic orientation as a weighted sum of all orientation vectors: the more recent is the motion, the greater is the weight. The resultant angle is a circular sum of the basic orientation and the shift. 
            </summary>
            <param name="orientation">Motion gradient orientation image; calculated by the function cvCalcMotionGradient.</param>
            <param name="mask">Mask image. It may be a conjunction of valid gradient mask, obtained with cvCalcMotionGradient and mask of the region, whose direction needs to be calculated. </param>
            <param name="mhi">Motion history image.</param>
            <param name="timestamp">Current time in milliseconds or other units, it is better to store time passed to cvUpdateMotionHistory before and reuse it here, because running cvUpdateMotionHistory and cvCalcMotionGradient on large images may take some time.</param>
            <param name="duration">Maximal duration of motion track in milliseconds, the same as in cvUpdateMotionHistory</param>
            <returns>The angle</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowPyrLK(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.PointF[],System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,System.Drawing.PointF[]@,System.Byte[]@,System.Single[]@,Emgu.CV.CvEnum.LKFlowFlag,System.Double)">
            <summary>
            Calculates optical flow for a sparse feature set using iterative Lucas-Kanade method in pyramids
            </summary>
            <param name="prev">First frame, at time t</param>
            <param name="curr">Second frame, at time t + dt </param>
            <param name="prevFeatures">Array of points for which the flow needs to be found</param>
            <param name="winSize">Size of the search window of each pyramid level</param>
            <param name="level">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc</param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped</param>
            <param name="flags">Flags</param>
            <param name="currFeatures">Array of 2D points containing calculated new positions of input features in the second image</param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise</param>
            <param name="trackError">Array of double numbers containing difference between patches around the original and moved points</param>
            <param name="minEigThreshold">the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in [Bouguet00]), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowPyrLK(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.CvEnum.LKFlowFlag,System.Double)">
            <summary>
            Implements sparse iterative version of Lucas-Kanade optical flow in pyramids ([Bouguet00]). It calculates coordinates of the feature points on the current video frame given their coordinates on the previous frame. The function finds the coordinates with sub-pixel accuracy. 
            </summary>
            <remarks>Both parameters prev_pyr and curr_pyr comply with the following rules: if the image pointer is 0, the function allocates the buffer internally, calculates the pyramid, and releases the buffer after processing. Otherwise, the function calculates the pyramid and stores it in the buffer unless the flag CV_LKFLOW_PYR_A[B]_READY is set. The image should be large enough to fit the Gaussian pyramid data. After the function call both pyramids are calculated and the readiness flag for the corresponding image can be set in the next call (i.e., typically, for all the image pairs except the very first one CV_LKFLOW_PYR_A_READY is set). </remarks>
            <param name="prevImg">First frame, at time t. </param>
            <param name="nextImg">Second frame, at time t + dt .</param>
            <param name="prevPts">Array of points for which the flow needs to be found. </param>
            <param name="nextPts">Array of 2D points containing calculated new positions of input </param>
            <param name="winSize">Size of the search window of each pyramid level.</param>
            <param name="maxLevel">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc. </param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise.</param>
            <param name="err">Array of double numbers containing difference between patches around the original and moved points. Optional parameter; can be NULL </param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped.</param>
            <param name="flags">Miscellaneous flags</param>
            <param name="minEigThreshold">the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in [Bouguet00]), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowFarneback(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.OpticalflowFarnebackFlag)">
            <summary>
            Computes dense optical flow using Gunnar Farneback's algorithm
            </summary>
            <param name="prev0">The first 8-bit single-channel input image</param>
            <param name="next0">The second input image of the same size and the same type as prevImg</param>
            <param name="flowX">The computed flow image for x-velocity; will have the same size as prevImg</param>
            <param name="flowY">The computed flow image for y-velocity; will have the same size as prevImg</param>
            <param name="pyrScale">Specifies the image scale (!1) to build the pyramids for each image. pyrScale=0.5 means the classical pyramid, where each next layer is twice smaller than the previous</param>
            <param name="levels">The number of pyramid layers, including the initial image. levels=1 means that no extra layers are created and only the original images are used</param>
            <param name="winSize">The averaging window size; The larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field</param>
            <param name="iterations">The number of iterations the algorithm does at each pyramid level</param>
            <param name="polyN">Size of the pixel neighborhood used to find polynomial expansion in each pixel. The larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field. Typically, poly n=5 or 7</param>
            <param name="polySigma">Standard deviation of the Gaussian that is used to smooth derivatives that are used as a basis for the polynomial expansion. For poly n=5 you can set poly sigma=1.1, for poly n=7 a good value would be poly sigma=1.5</param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowFarneback(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.OpticalflowFarnebackFlag)">
            <summary>
            Computes dense optical flow using Gunnar Farneback's algorithm
            </summary>
            <param name="prev0">The first 8-bit single-channel input image</param>
            <param name="next0">The second input image of the same size and the same type as prevImg</param>
            <param name="flow">The computed flow image; will have the same size as prevImg and type CV 32FC2</param>
            <param name="pyrScale">Specifies the image scale (!1) to build the pyramids for each image. pyrScale=0.5 means the classical pyramid, where each next layer is twice smaller than the previous</param>
            <param name="levels">The number of pyramid layers, including the initial image. levels=1 means that no extra layers are created and only the original images are used</param>
            <param name="winSize">The averaging window size; The larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field</param>
            <param name="iterations">The number of iterations the algorithm does at each pyramid level</param>
            <param name="polyN">Size of the pixel neighborhood used to find polynomial expansion in each pixel. The larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field. Typically, poly n=5 or 7</param>
            <param name="polySigma">Standard deviation of the Gaussian that is used to smooth derivatives that are used as a basis for the polynomial expansion. For poly n=5 you can set poly sigma=1.1, for poly n=7 a good value would be poly sigma=1.5</param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindTransformECC(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.CvEnum.MotionType,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.IInputArray)">
            <summary>
            Finds the geometric transform (warp) between two images in terms of the ECC criterion
            </summary>
            <param name="templateImage">single-channel template image; CV_8U or CV_32F array.</param>
            <param name="inputImage">single-channel input image which should be warped with the final warpMatrix in order to provide an image similar to templateImage, same type as temlateImage.</param>
            <param name="warpMatrix">floating-point 2×3 or 3×3 mapping matrix (warp).</param>
            <param name="motionType">Specifying the type of motion. Use Affine for default</param>
            <param name="criteria">specifying the termination criteria of the ECC algorithm; criteria.epsilon defines the threshold of the increment in the correlation coefficient between two iterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion). Default values can use 50 iteration and 0.001 eps.</param>
            <param name="inputMask">An optional mask to indicate valid values of inputImage.</param>
            <returns>The final enhanced correlation coefficient, that is the correlation coefficient between the template image and the final warped input image.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ReadCloud(System.String,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Read point cloud from file
            </summary>
            <param name="file">The point cloud file</param>
            <param name="colors">The color of the points</param>
            <param name="normals">The normal of the points</param>
            <returns>The points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WriteCloud(System.String,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Write point cloud to file
            </summary>
            <param name="file">The point cloud file name</param>
            <param name="cloud">The point cloud</param>
            <param name="colors">The color</param>
            <param name="normals">The normals</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Compute(Emgu.CV.IStereoMatcher,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes disparity map for the specified stereo pair
            </summary>
            <param name="matcher">The stereo matcher</param>
            <param name="left">Left 8-bit single-channel image.</param>
            <param name="right">Right image of the same size and the same type as the left one.</param>
            <param name="disparity">Output disparity map. It has the same size as the input images. Some algorithms, like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Undistort(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Transforms the image to compensate radial and tangential lens distortion. 
            </summary>
            <param name="src">The input (distorted) image</param>
            <param name="dst">The output (corrected) image</param>
            <param name="cameraMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].</param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2].</param>
            <param name="newCameraMatrix">Camera matrix of the distorted image. By default it is the same as cameraMatrix, but you may additionally scale and shift the result by using some different matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InitUndistortRectifyMap(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            This function is an extended version of cvInitUndistortMap. That is, in addition to the correction of lens distortion, the function can also apply arbitrary perspective transformation R and finally it can scale and shift the image according to the new camera matrix
            </summary>
            <param name="cameraMatrix">The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1]</param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="R">The rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used</param>
            <param name="newCameraMatrix">The new camera matrix A'=[fx' 0 cx'; 0 fy' cy'; 0 0 1]</param>
            <param name="depthType">Depth type of the first output map. (The combination with <paramref name="channels"/> can be one of CV_32FC1, CV_32FC2 or CV_16SC2)</param>
            <param name="channels">Number of channels of the first output map. (The combination with <paramref name="depthType"/> can be one of CV_32FC1, CV_32FC2 or CV_16SC2)</param>
            <param name="map1">The first output map.</param>
            <param name="map2">The second output map.</param>
            <param name="size">Undistorted image size.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.UndistortPoints(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Similar to cvInitUndistortRectifyMap and is opposite to it at the same time. 
            The functions are similar in that they both are used to correct lens distortion and to perform the optional perspective (rectification) transformation. 
            They are opposite because the function cvInitUndistortRectifyMap does actually perform the reverse transformation in order to initialize the maps properly, while this function does the forward transformation. 
            </summary>
            <param name="src">The observed point coordinates</param>
            <param name="dst">The ideal point coordinates, after undistortion and reverse perspective transformation. </param>
            <param name="cameraMatrix">The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1]</param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1, 1x4, 5x1 or 1x5. </param>
            <param name="R">The rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used.</param>
            <param name="P">The new camera matrix (3x3) or the new projection matrix (3x4). P1 or P2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDefaultNewCameraMatrix(Emgu.CV.IInputArray,System.Drawing.Size,System.Boolean)">
            <summary>
            Returns the default new camera matrix.
            </summary>
            <param name="cameraMatrix">Input camera matrix.</param>
            <param name="imgsize">Camera view image size in pixels.</param>
            <param name="centerPrincipalPoint">Location of the principal point in the new camera matrix. The parameter indicates whether this location should be at the image center or not.</param>
            <returns>The default new camera matrix.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateAffine2D(System.Drawing.PointF[],System.Drawing.PointF[],Emgu.CV.IOutputArray,Emgu.CV.CvEnum.RobustEstimationAlgorithm,System.Double,System.Int32,System.Double,System.Int32)">
            <summary>
            Computes an optimal affine transformation between two 2D point sets.
            </summary>
            <param name="from">First input 2D point set containing (X,Y).</param>
            <param name="to">Second input 2D point set containing (x,y).</param>
            <param name="inliners">Output vector indicating which points are inliers (1-inlier, 0-outlier).</param>
            <param name="method">Robust method used to compute transformation. </param>
            <param name="ransacReprojThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier. Applies only to RANSAC.</param>
            <param name="maxIters">The maximum number of robust method iterations.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <param name="refineIters">Maximum number of iterations of refining algorithm (Levenberg-Marquardt). Passing 0 will disable refining, so the output matrix will be output of robust method.</param>
            <returns>Output 2D affine transformation matrix 2×3 or empty matrix if transformation could not be estimated.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateAffine2D(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.RobustEstimationAlgorithm,System.Double,System.Int32,System.Double,System.Int32)">
            <summary>
            Computes an optimal affine transformation between two 2D point sets.
            </summary>
            <param name="from">First input 2D point set containing (X,Y).</param>
            <param name="to">Second input 2D point set containing (x,y).</param>
            <param name="inliners">Output vector indicating which points are inliers (1-inlier, 0-outlier).</param>
            <param name="method">Robust method used to compute transformation. </param>
            <param name="ransacReprojThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier. Applies only to RANSAC.</param>
            <param name="maxIters">The maximum number of robust method iterations.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <param name="refineIters">Maximum number of iterations of refining algorithm (Levenberg-Marquardt). Passing 0 will disable refining, so the output matrix will be output of robust method.</param>
            <returns>Output 2D affine transformation matrix 2×3 or empty matrix if transformation could not be estimated.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateAffinePartial2D(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.RobustEstimationAlgorithm,System.Double,System.Int32,System.Double,System.Int32)">
            <summary>
            Computes an optimal limited affine transformation with 4 degrees of freedom between two 2D point sets.
            </summary>
            <param name="from">First input 2D point set.</param>
            <param name="to">Second input 2D point set.</param>
            <param name="inliners">Output vector indicating which points are inliers.</param>
            <param name="method">Robust method used to compute transformation.</param>
            <param name="ransacReprojThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier. Applies only to RANSAC.</param>
            <param name="maxIters">The maximum number of robust method iterations.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <param name="refineIters">Maximum number of iterations of refining algorithm (Levenberg-Marquardt). Passing 0 will disable refining, so the output matrix will be output of robust method.</param>
            <returns>Output 2D affine transformation (4 degrees of freedom) matrix 2×3 or empty matrix if transformation could not be estimated.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalibrateHandEye(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IInputArrayOfArrays,Emgu.CV.IInputArrayOfArrays,Emgu.CV.IInputArrayOfArrays,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.HandEyeCalibrationMethod)">
            <summary>
            Computes Hand-Eye calibration
            </summary>
            <param name="rGripper2base">
            Rotation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the robot base frame.
            This is a vector (vector&lt;Mat&gt;) that contains the rotation matrices for all the transformations from gripper frame to robot base frame.
            </param>
            <param name="tGripper2base">
            Translation part extracted from the homogeneous matrix that transforms a point expressed in the gripper frame to the robot base frame.
            This is a vector (vector&lt;Mat&gt;) that contains the translation vectors for all the transformations from gripper frame to robot base frame.
            </param>
            <param name="rTarget2cam">
            Rotation part extracted from the homogeneous matrix that transforms a point expressed in the target frame to the camera frame.
            This is a vector (vector&lt;Mat&gt;) that contains the rotation matrices for all the transformations from calibration target frame to camera frame.
            </param>
            <param name="tTarget2cam">
            Rotation part extracted from the homogeneous matrix that transforms a point expressed in the target frame to the camera frame.
            This is a vector (vector&lt;Mat&gt;) that contains the translation vectors for all the transformations from calibration target frame to camera frame.
            </param>
            <param name="rCam2gripper">
            Estimated rotation part extracted from the homogeneous matrix that transforms a point expressed in the camera frame to the gripper frame.
            </param>
            <param name="tCam2gripper">
            Estimated translation part extracted from the homogeneous matrix that transforms a point expressed in the camera frame to the gripper frame.
            </param>
            <param name="method">One of the implemented Hand-Eye calibration method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RQDecomp3x3(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes an RQ decomposition of 3x3 matrices.
            </summary>
            <param name="src">3x3 input matrix.</param>
            <param name="mtxR">Output 3x3 upper-triangular matrix.</param>
            <param name="mtxQ">Output 3x3 orthogonal matrix.</param>
            <param name="Qx">Optional output 3x3 rotation matrix around x-axis.</param>
            <param name="Qy">Optional output 3x3 rotation matrix around y-axis.</param>
            <param name="Qz">Optional output 3x3 rotation matrix around z-axis.</param>
            <returns>The euler angles</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DecomposeProjectionMatrix(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.
            </summary>
            <param name="projMatrix">3x4 input projection matrix P.</param>
            <param name="cameraMatrix">Output 3x3 camera intrinsic matrix A</param>
            <param name="rotMatrix">Output 3x3 external rotation matrix R.</param>
            <param name="transVect">Output 4x1 translation vector T.</param>
            <param name="rotMatrixX">Optional 3x3 rotation matrix around x-axis.</param>
            <param name="rotMatrixY">Optional 3x3 rotation matrix around y-axis.</param>
            <param name="rotMatrixZ">Optional 3x3 rotation matrix around z-axis.</param>
            <param name="eulerAngles">Optional three-element vector containing three Euler angles of rotation in degrees.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DecomposeEssentialMat(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Decompose an essential matrix to possible rotations and translation.
            </summary>
            <param name="e">The input essential matrix.</param>
            <param name="r1">One possible rotation matrix.</param>
            <param name="r2">Another possible rotation matrix.</param>
            <param name="t">One possible translation.</param>
            <remarks>This function decomposes the essential matrix E using svd decomposition. In general, four possible poses exist for the decomposition of E. They are [R1,t], [R1,−t], [R2,t], [R2,−t]</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DecomposeHomographyMat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArrayOfArrays)">
            <summary>
            Decompose a homography matrix to rotation(s), translation(s) and plane normal(s).
            </summary>
            <param name="h">The input homography matrix between two images.</param>
            <param name="k">The input camera intrinsic matrix.</param>
            <param name="rotations">Array of rotation matrices.</param>
            <param name="translations">Array of translation matrices.</param>
            <param name="normals">Array of plane normal matrices.</param>
            <returns>Number of solutions</returns>
        </member>
        <member name="T:Emgu.CV.CvArray`1">
            <summary>
            Wrapped CvArr 
            </summary>
            <typeparam name="TDepth">The type of elements in this CvArray</typeparam> 
        </member>
        <member name="F:Emgu.CV.CvArray`1._sizeOfElement">
            <summary>
            The size of the elements in the CvArray, it is the cached value of Marshal.SizeOf(typeof(TDepth)).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvArray`1._dataHandle">
            <summary>
            The pinned GCHandle to _array;
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.SerializationCompressionRatio">
            <summary>
            Get or set the Compression Ratio for serialization. A number between 0 - 9. 
            0 means no compression at all, while 9 means best compression
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.SizeOfElement">
            <summary>
            Get the size of element in bytes
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Ptr">
            <summary> The pointer to the internal structure </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Size">
            <summary> 
            Get the size of the array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Width">
            <summary> 
            Get the width (Cols) of the cvArray.
            If ROI is set, the width of the ROI 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Height">
            <summary> 
            Get the height (Rows) of the cvArray.
            If ROI is set, the height of the ROI 
            </summary> 
        </member>
        <member name="P:Emgu.CV.CvArray`1.NumberOfChannels">
            <summary>
            Get the number of channels of the array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Rows">
            <summary>
            The number of rows for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Cols">
            <summary>
            The number of cols for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Bytes">
            <summary>
            Get or Set an Array of bytes that represent the data in this array
            </summary>
            <remarks> Should only be used for serialization &amp; deserialization</remarks>
        </member>
        <member name="P:Emgu.CV.CvArray`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels of this cvArray</param>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Trace">
            <summary>
            Sum of diagonal elements of the matrix 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Norm">
            <summary> 
            The norm of this Array 
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DotProduct(Emgu.CV.CvArray{`0})">
            <summary>
            Calculates and returns the Euclidean dot product of two arrays.
            src1 dot src2 = sumI(src1(I)*src2(I))
            </summary>
            <remarks>In case of multiple channel arrays the results for all channels are accumulated. In particular, cvDotProduct(a,a), where a is a complex vector, will return ||a||^2. The function can process multi-dimensional arrays, row by row, layer by layer and so on.</remarks>
            <param name="otherArray">The other Array to apply dot product with</param>
            <returns>src1 dot src2</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.CheckRange(System.Double,System.Double,System.Drawing.Point@)">
            <summary>
            Check that every array element is neither NaN nor +- inf. The functions also check that each value
            is between <paramref name="min"/> and <paramref name="max"/>. in the case of multi-channel arrays each channel is processed
            independently. If some values are out of range, position of the first outlier is stored in pos, 
            and then the functions return false.
            </summary>
            <param name="min">The inclusive lower boundary of valid values range</param>
            <param name="max">The exclusive upper boundary of valid values range</param>
            <param name="position">This will be filled with the position of the first outlier</param>
            <returns>True if all values are in range</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.Reduce``1(Emgu.CV.CvArray{``0},Emgu.CV.CvEnum.ReduceDimension,Emgu.CV.CvEnum.ReduceType)">
            <summary>
            Reduces matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <remarks>
            The function can be used to compute horizontal and vertical projections of an raster image. 
            In case of CV_REDUCE_SUM and CV_REDUCE_AVG the output may have a larger element bit-depth to preserve accuracy. 
            And multi-channel arrays are also supported in these two reduction modes
            </remarks>
            <param name="array1D">The destination single-row/single-column vector that accumulates somehow all the matrix rows/columns</param>
            <param name="dim">The dimension index along which the matrix is reduce.</param>
            <param name="type">The reduction operation type</param>
            <typeparam name="TOtherDepth">The type of depth of the reduced array</typeparam>
        </member>
        <member name="M:Emgu.CV.CvArray`1.CopyTo(Emgu.CV.CvArray{`0})">
            <summary>
            Copy the current array to <paramref name="destination"/>
            </summary>
            <param name="destination">The destination Array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(Emgu.CV.Structure.MCvScalar,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="value"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="value">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(System.Double,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="value"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="value">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandUniform(Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with uniformly distributed random numbers
            </summary>
            <param name="floorValue">the inclusive lower boundary of random numbers range</param>
            <param name="ceilingValue">the exclusive upper boundary of random numbers range</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandNormal(Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with normally distributed random numbers
            </summary>
            <param name="mean">The mean value of random numbers</param>
            <param name="std">The standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetIdentity(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Initializes scaled identity matrix
            </summary>
            <param name="value">The value on the diagonal</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetZero">
            <summary>
            Set the values to zero
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetIdentity">
            <summary>
            Initialize the identity matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(System.Double)">
            <summary>
            Inplace multiply elements of the Array by <paramref name="scale"/>
            </summary>
            <param name="scale">The scale to be multiplyed</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise multiply the current Array with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to be elementwise multiplied with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DisposeObject">
            <summary>
            Free the _dataHandle if it is set
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(System.Double)">
            <summary>
            Inplace compute the elementwise minimum value 
            </summary>
            <param name="value">The value to compare with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise minimize the current Array with <paramref name="other"/>
            </summary>
            <param name="other">The other array to be elementwise minimized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(System.Double)">
            <summary>
            Inplace compute the elementwise maximum value with <paramref name="value"/>
            </summary>
            <param name="value">The value to be compare with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise maximize the current Array with <paramref name="other"/>
            </summary>
            <param name="other">The other array to be elementwise maximized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._And(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace And operation with <paramref name="otherArray"/>
            </summary>
            <param name="otherArray">The other array to perform AND operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Or(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace Or operation with <paramref name="otherArray"/>
            </summary>
            <param name="otherArray">The other array to perform OR operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Not">
            <summary> 
            Inplace compute the complement for all array elements
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.Save(System.String)">
            <summary>
            Save the CvArray as image
            </summary>
            <param name="fileName">The name of the image to save</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetSchema">
            <summary>
            Get the xml schema
            </summary>
            <returns>The xml schema</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.ReadXml(System.Xml.XmlReader)">
            <summary>
            Function to call when deserializing this object from XML
            </summary>
            <param name="reader">The xml reader</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Function to call when serializing this object to XML 
            </summary>
            <param name="writer">The xml writer</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="F:Emgu.CV.CvArray`1._cvMat">
            <summary>
            The Mat header that represent this CvArr
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Mat">
            <summary>
            Get the Mat header that represent this CvArr
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetInputArray">
            <summary>
            The unmanaged pointer to the input array.
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetOutputArray">
            <summary>
            The unmanaged pointer to the output array.
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetInputOutputArray">
            <summary>
            The unmanaged pointer to the input output array.
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.ToUMat">
            <summary>
            Get the umat representation of this mat
            </summary>
            <returns>The UMat</returns>
        </member>
        <member name="T:Emgu.CV.CvString">
            <summary>
            Wrapper for cv::String. This class support UTF-8 chars.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvString.#ctor(System.String)">
            <summary>
            Create a CvString from System.String
            </summary>
            <param name="s">The System.String object to be converted to CvString</param>
        </member>
        <member name="M:Emgu.CV.CvString.#ctor">
            <summary>
            Create an empty CvString
            </summary>
        </member>
        <member name="M:Emgu.CV.CvString.ToString">
            <summary>
            Get the string representation of the CvString
            </summary>
            <returns>The string representation of the CvString</returns>
        </member>
        <member name="P:Emgu.CV.CvString.Length">
            <summary>
            Gets the length of the string
            </summary>
            <value>
            The length of the string
            </value>
        </member>
        <member name="M:Emgu.CV.CvString.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object.
            </summary>
        </member>
        <member name="T:Emgu.CV.DirectX">
            <summary>
            DirectX interoperability
            </summary>
        </member>
        <member name="M:Emgu.CV.DirectX.ConvertToD3D11Texture2D(Emgu.CV.IInputArray,System.IntPtr)">
            <summary>
            Converts InputArray to ID3D11Texture2D. If destination texture format is DXGI_FORMAT_NV12 then input UMat expected to be in BGR format and data will be downsampled and color-converted to NV12.
            </summary>
            <param name="src">Source InputArray</param>
            <param name="pD3D11Texture2D">Destination D3D11 texture</param>
        </member>
        <member name="M:Emgu.CV.DirectX.ConvertFromD3D11Texture2D(System.IntPtr,Emgu.CV.IOutputArray)">
            <summary>
            Converts ID3D11Texture2D to OutputArray. If input texture format is DXGI_FORMAT_NV12 then data will be upsampled and color-converted to BGR format.
            </summary>
            <param name="pD3D11Texture2D">Source D3D11 texture</param>
            <param name="dst">Destination OutputArray</param>
        </member>
        <member name="M:Emgu.CV.DirectX.ConvertToD3D10Texture2D(Emgu.CV.IInputArray,System.IntPtr)">
            <summary>
            Converts InputArray to ID3D10Texture2D.
            </summary>
            <param name="src">Source InputArray</param>
            <param name="pD3D10Texture2D">Destination D3D10 texture</param>
        </member>
        <member name="M:Emgu.CV.DirectX.ConvertFromD3D10Texture2D(System.IntPtr,Emgu.CV.IOutputArray)">
            <summary>
            Converts ID3D10Texture2D to OutputArray.
            </summary>
            <param name="pD3D10Texture2D">Source D3D10 texture</param>
            <param name="dst">Destination OutputArray</param>
        </member>
        <member name="M:Emgu.CV.DirectX.ConvertToDirect3DSurface9(Emgu.CV.IInputArray,System.IntPtr,System.IntPtr)">
            <summary>
            Converts InputArray to IDirect3DSurface9
            </summary>
            <param name="src">Source InputArray</param>
            <param name="pDirect3DSurface9">Destination D3D10 texture</param>
            <param name="surfaceSharedHandle">Shared handle</param>
        </member>
        <member name="M:Emgu.CV.DirectX.ConvertFromDirect3DSurface9(System.IntPtr,Emgu.CV.IOutputArray,System.IntPtr)">
            <summary>
            Converts IDirect3DSurface9 to OutputArray.
            </summary>
            <param name="pDirect3DSurface9">Source texture</param>
            <param name="dst">Destination OutputArray</param>
            <param name="surfaceSharedHandle">Shared handle</param>
        </member>
        <member name="T:Emgu.CV.FileNode">
            <summary>
            File Storage Node class.
            The node is used to store each and every element of the file storage opened for reading. When
            XML/YAML file is read, it is first parsed and stored in the memory as a hierarchical collection of
            nodes. Each node can be a "leaf" that is contain a single number or a string, or be a collection of
            other nodes. There can be named collections (mappings) where each element has a name and it is
            accessed by a name, and ordered collections (sequences) where elements do not have names but rather
            accessed by index. Type of the file node can be determined using FileNode::type method.
            Note that file nodes are only used for navigating file storages opened for reading. When a file
            storage is opened for writing, no data is stored in memory after it is written.
            </summary>
        </member>
        <member name="T:Emgu.CV.FileNode.Type">
            <summary>
            Type of the file storage node
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.None">
            <summary>
            Empty node
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Int">
            <summary>
              an integer
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Real">
            <summary>
            Floating-point number
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Float">
            <summary>
            Synonym or Real
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Str">
            <summary>
            Text string in UTF-8 encoding
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.String">
            <summary>
            Synonym for Str
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Seq">
            <summary>
            The sequence
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Map">
            <summary>
            Mapping
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.TypeMask">
            <summary>
            The type mask
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Flow">
            <summary>
            Used only when writing. Compact representation of a sequence or mapping. Used only by YAML writer
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Uniform">
            <summary>
            Used only when reading FileStorage. If set, means that all the collection elements are numbers of the same type (real's or int's).
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Empty">
            <summary>
            Empty structure (sequence or mapping)
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Named">
            <summary>
            The node has a name (i.e. it is element of a mapping)
            </summary>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadMat(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Reads a Mat from the node
            </summary>
            <param name="mat">The Mat where the result is read into</param>
            <param name="defaultMat">The default mat.</param>
        </member>
        <member name="P:Emgu.CV.FileNode.NodeType">
            <summary>
            Gets the type of the node.
            </summary>
            <value>
            The type of the node.
            </value>
        </member>
        <member name="P:Emgu.CV.FileNode.Name">
            <summary>
            Get the node name or an empty string if the node is nameless
            </summary>
        </member>
        <member name="M:Emgu.CV.FileNode.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadString(System.String)">
            <summary>
            Reads the string from the node
            </summary>
            <param name="defaultString">The default value if one is not found in the node.</param>
            <returns>The string from the node</returns>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadInt(System.Int32)">
            <summary>
            Reads the int from the node.
            </summary>
            <param name="defaultInt">The default value if one is not found in the node.</param>
            <returns>The int from the node.</returns>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadFloat(System.Single)">
            <summary>
            Reads the float from the node.
            </summary>
            <param name="defaultFloat">The default value if one is not found in the node.</param>
            <returns>The float from the node.</returns>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadDouble(System.Double)">
            <summary>
            Reads the double from the node.
            </summary>
            <param name="defaultDouble">The default value if one is not found in the node.</param>
            <returns>The double from the node.</returns>
        </member>
        <member name="M:Emgu.CV.FileNode.GetEnumerator">
            <summary>
            Get an enumerator of the file node children
            </summary>
            <returns>An enumerator of the file node children</returns>
        </member>
        <member name="P:Emgu.CV.FileNode.IsNamed">
            <summary>
            Returns true if the node has a name
            </summary>
        </member>
        <member name="P:Emgu.CV.FileNode.IsEmpty">
            <summary>
            Returns true if the node is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.FileNode.IsNone">
            <summary>
            Returns true if the node is a "none" object
            </summary>
        </member>
        <member name="P:Emgu.CV.FileNode.IsSeq">
            <summary>
            Returns true if the node is a sequence
            </summary>
        </member>
        <member name="P:Emgu.CV.FileNode.IsMap">
            <summary>
            Returns true if the node is a mapping
            </summary>
        </member>
        <member name="P:Emgu.CV.FileNode.IsInt">
            <summary>
            Returns true if the node is an integer
            </summary>
        </member>
        <member name="P:Emgu.CV.FileNode.IsReal">
            <summary>
            Returns true if the node is a floating-point number
            </summary>
        </member>
        <member name="P:Emgu.CV.FileNode.IsString">
            <summary>
            Returns true if the node is a text string
            </summary>
        </member>
        <member name="T:Emgu.CV.FileNodeIterator">
            <summary>
            Used to iterate through sequences and mappings.
            </summary>
        </member>
        <member name="M:Emgu.CV.FileNodeIterator.#ctor">
            <summary>
            Create a blank file node iterator
            </summary>
        </member>
        <member name="M:Emgu.CV.FileNodeIterator.#ctor(Emgu.CV.FileNode,System.Boolean)">
            <summary>
            Create a FileNodeIterator from a specific node.
            </summary>
            <param name="node">the collection to iterate over</param>
            <param name="seekEnd">True if iterator needs to be set after the last element of the node</param>
        </member>
        <member name="M:Emgu.CV.FileNodeIterator.Equals(Emgu.CV.FileNodeIterator)">
            <summary>
            Check if the current iterator equals to the other.
            </summary>
            <param name="iterator">The other iterator to compares with.</param>
            <returns>True if the current iterator equals to the other</returns>
        </member>
        <member name="M:Emgu.CV.FileNodeIterator.Next">
            <summary>
            moves iterator to the next node
            </summary>
        </member>
        <member name="M:Emgu.CV.FileNodeIterator.GetFileNode">
            <summary>
            Get the currently observed element
            </summary>
            <returns>The currently observed element</returns>
        </member>
        <member name="M:Emgu.CV.FileNodeIterator.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="T:Emgu.CV.FileStorage">
            <summary>
            XML/YAML file storage class that encapsulates all the information necessary for writing or reading data to/from a file.
            </summary>
        </member>
        <member name="T:Emgu.CV.FileStorage.Mode">
            <summary>
            File storage mode
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Read">
            <summary>
            Open the file for reading
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Write">
            <summary>
            Open the file for writing
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Append">
            <summary>
            Open the file for appending
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Memory">
            <summary>
            ReadMat data from source or write data to the internal buffer
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatMask">
            <summary>
            Mask for format flags
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatAuto">
            <summary>
            Auto format
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatXml">
            <summary>
            XML format
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatYaml">
            <summary>
            YAML format
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatJson">
            <summary>
            JSON format
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Base64">
            <summary>
            Write rawdata in Base64 by default. (consider using WriteBase64)
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.WriteBase64">
            <summary>
            enable both Write and Base64
            </summary>
        </member>
        <member name="M:Emgu.CV.FileStorage.#ctor(System.String,Emgu.CV.FileStorage.Mode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.FileStorage"/> class.
            </summary>
            <param name="source">Name of the file to open or the text string to read the data from. Extension of the
            file (.xml or .yml/.yaml) determines its format (XML or YAML respectively). Also you can append .gz
            to work with compressed files, for example myHugeMatrix.xml.gz. If both FileStorage::WRITE and
            FileStorage::MEMORY flags are specified, source is used just to specify the output file format (e.g.
            mydata.xml, .yml etc.).</param>
            <param name="flags">Mode of operation.</param>
            <param name="encoding">Encoding of the file. Note that UTF-16 XML encoding is not supported currently and
            you should use 8-bit encoding instead of it.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(Emgu.CV.Mat,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific name.
            </summary>
            <param name="m">The Mat to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(System.Int32,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific name
            </summary>
            <param name="value">The value to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(System.Single,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific name
            </summary>
            <param name="value">The value to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(System.Double,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific name
            </summary>
            <param name="value">The value to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(System.String,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific name
            </summary>
            <param name="value">The value to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="P:Emgu.CV.FileStorage.IsOpened">
            <summary>
            Gets a value indicating whether this instance is opened.
            </summary>
            <value>
              <c>true</c> if the object is associated with the current file; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Emgu.CV.FileStorage.ReleaseAndGetString">
            <summary>
            Closes the file and releases all the memory buffers
            Call this method after all I/O operations with the storage are finished. If the storage was
            opened for writing data and FileStorage.Mode.Write was specified
            </summary>
            <returns>The string that represent the text in the FileStorage</returns>
        </member>
        <member name="M:Emgu.CV.FileStorage.GetRoot(System.Int32)">
            <summary>
            Gets the top-level mapping.
            </summary>
            <param name="streamIdx">Zero-based index of the stream. In most cases there is only one stream in the file.
            However, YAML supports multiple streams and so there can be several.</param>
            <returns> The top-level mapping</returns>
        </member>
        <member name="M:Emgu.CV.FileStorage.GetFirstTopLevelNode">
            <summary>
            Gets the first element of the top-level mapping.
            </summary>
            <returns>The first element of the top-level mapping.</returns>
        </member>
        <member name="M:Emgu.CV.FileStorage.GetNode(System.String)">
            <summary>
            Gets the specified element of the top-level mapping.
            </summary>
            <param name="nodeName">Name of the node.</param>
            <returns>The specified element of the top-level mapping.</returns>
        </member>
        <member name="P:Emgu.CV.FileStorage.Item(System.String)">
            <summary>
            Gets the <see cref="T:Emgu.CV.FileNode"/> with the specified node name.
            </summary>
            <value>
            The <see cref="T:Emgu.CV.FileNode"/>.
            </value>
            <param name="nodeName">Name of the node.</param>
            <returns>The file node</returns>
        </member>
        <member name="M:Emgu.CV.FileStorage.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.CV.FileStorage.Insert(System.String)">
            <summary>
            Similar to the &lt;&lt; operator in C++, we cannot have the operator overload to &lt;&lt; in C# where the second parameter is not an int. Therefore we use this function instead.
            </summary>
            <param name="value">The string value to insert.</param>
        </member>
        <member name="T:Emgu.CV.IAlgorithm">
            <summary>
            Interface to the algorithm class
            </summary>
        </member>
        <member name="P:Emgu.CV.IAlgorithm.AlgorithmPtr">
            <summary>
            Return the pointer to the algorithm object
            </summary>
            <returns>The pointer to the algorithm object</returns>
        </member>
        <member name="T:Emgu.CV.AlgorithmExtensions">
            <summary>
            Extension methods to the IAlgorithm interface
            </summary>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.Read(Emgu.CV.IAlgorithm,Emgu.CV.FileNode)">
            <summary>
            Reads algorithm parameters from a file storage.
            </summary>
            <param name="algorithm">The algorithm.</param>
            <param name="node">The node from file storage.</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.Write(Emgu.CV.IAlgorithm,Emgu.CV.FileStorage)">
            <summary>
            Stores algorithm parameters in a file storage
            </summary>
            <param name="algorithm">The algorithm.</param>
            <param name="storage">The storage.</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.Write(Emgu.CV.IAlgorithm,Emgu.CV.FileStorage,System.String)">
            <summary>
            Stores algorithm parameters in a file storage
            </summary>
            <param name="algorithm">The algorithm.</param>
            <param name="storage">The storage.</param>
            <param name="name">The name of the node</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.Save(Emgu.CV.IAlgorithm,System.String)">
            <summary>
            Save the algorithm to file
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="fileName">The file name where this algorithm will be saved to</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.SaveToString(Emgu.CV.IAlgorithm,System.String)">
            <summary>
            Save the algorithm to a string
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="format">file format, can be .xml or .yml</param>
            <returns>The algorithm as an yml string</returns>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.Clear(Emgu.CV.IAlgorithm)">
            <summary>
            Clear the algorithm
            </summary>
            <param name="algorithm">The algorithm</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.IsEmpty(Emgu.CV.IAlgorithm)">
            <summary>
            Returns true if the Algorithm is empty. e.g. in the very beginning or after unsuccessful read.
            </summary>
            <param name="algorithm">The algorithm</param>
            <returns>Returns true if the Algorithm is empty. e.g. in the very beginning or after unsuccessful read.</returns>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.Load(Emgu.CV.IAlgorithm,System.String,System.String,System.String)">
            <summary>
            Loads algorithm from the file
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="fileName">Name of the file to read.</param>
            <param name="objName">The optional name of the node to read (if empty, the first top-level node will be used)</param>
            <param name="encoding">Encoding of the file. Note that UTF-16 XML encoding is not supported currently and
            you should use 8-bit encoding instead of it.</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.LoadFromString(Emgu.CV.IAlgorithm,System.String,System.String,System.String)">
            <summary>
            Loads algorithm from a String
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="strModel">The string variable containing the model you want to load.</param>
            <param name="objName">The optional name of the node to read (if empty, the first top-level node will be used)</param>
            <param name="encoding">Encoding of the file. Note that UTF-16 XML encoding is not supported currently and
            you should use 8-bit encoding instead of it.</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.GetDefaultName(Emgu.CV.IAlgorithm)">
            <summary>
            Returns the algorithm string identifier.
            This string is used as top level xml/yml node tag when the object is saved to a file or string.
            </summary>
            <param name="algorithm">The algorithm</param>
            <returns>
            Returns the algorithm string identifier.
            This string is used as top level xml/yml node tag when the object is saved to a file or string.
            </returns>
        </member>
        <member name="T:Emgu.CV.IFileReaderMat">
            <summary>
            The inteface for reading a file into a Mat
            </summary>
        </member>
        <member name="M:Emgu.CV.IFileReaderMat.ReadFile(System.String,Emgu.CV.Mat,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            Read the file into a Mat
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="mat">The destination mat</param>
            <param name="loadType">The image loading type</param>
            <returns>True if successful</returns>
        </member>
        <member name="T:Emgu.CV.IFileWriterMat">
            <summary>
            The inteface for writing a Mat into a file.
            </summary>
        </member>
        <member name="M:Emgu.CV.IFileWriterMat.WriteFile(Emgu.CV.Mat,System.String)">
            <summary>
            Write the Mat into the file
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="mat">The mat to be written to the file</param>
            <returns>True if successful</returns>
        </member>
        <member name="T:Emgu.CV.IInputArray">
            <summary>
            This is the proxy class for passing read-only input arrays into OpenCV functions.
            </summary>
        </member>
        <member name="M:Emgu.CV.IInputArray.GetInputArray">
            <summary>
            The unmanaged pointer to the input array.
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="T:Emgu.CV.IInputArrayOfArrays">
            <summary>
            InputArrayOfArrays
            </summary>
        </member>
        <member name="T:Emgu.CV.IInputArrayExtensions">
            <summary>
            Extension methods for IInputArrays
            </summary>
        </member>
        <member name="M:Emgu.CV.IInputArrayExtensions.IsUmat(Emgu.CV.IInputArray)">
            <summary>
            Determines whether the specified input array is umat.
            </summary>
            <param name="arr">The array</param>
            <returns>True if it is a umat</returns>
        </member>
        <member name="M:Emgu.CV.IInputArrayExtensions.ForEachDuplicateChannel``1(Emgu.CV.IInputArray,System.Func{Emgu.CV.IInputArray,System.Int32,``0})">
            <summary>
            Apply converter and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <typeparam name="TReturn">The return type</typeparam>
            <param name="image">The source image</param>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.IInputArrayExtensions.ForEachDuplicateChannel(Emgu.CV.IInputArray,System.Action{Emgu.CV.IInputArray,System.Int32})">
            <summary>
            Apply converter and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <param name="image">The source image</param>
            <param name="action">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="T:Emgu.CV.IInputOutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for input/output function parameters.
            </summary>
        </member>
        <member name="M:Emgu.CV.IInputOutputArray.GetInputOutputArray">
            <summary>
            The unmanaged pointer to the input/output array
            </summary>
            <returns>Get the input output array</returns>
        </member>
        <member name="T:Emgu.CV.Image`2">
            <summary>
            An Image is a wrapper to IplImage of OpenCV. 
            </summary>
            <typeparam name="TColor">Color type of this image (either Gray, Bgr, Bgra, Hsv, Hls, Lab, Luv, Xyz, Ycc, Rgb or Rbga)</typeparam>
            <typeparam name="TDepth">Depth of this image (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="F:Emgu.CV.Image`2._numberOfChannels">
            <summary>
            The dimension of color
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor">
            <summary>
            Create an empty Image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(`1[0:,0:,0:])">
            <summary>
            Create image from the specific multi-dimensional data, where the 1st dimension is # of rows (height), the 2nd dimension is # cols (width) and the 3rd dimension is the channel
            </summary>
            <param name="data">The multi-dimensional data where the 1st dimension is # of rows (height), the 2nd dimension is # cols (width) and the 3rd dimension is the channel </param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Create an Image from unmanaged data. 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="stride">Size of aligned image row in bytes</param>
            <param name="scan0">Pointer to aligned image data, <b>where each row should be 4-align</b> </param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the scan0 parameter, however, the memory should not be released until the related Image is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Image`2.MapDataToImage(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Let this Image object use the specific Image data.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="stride">The data stride (bytes per row)</param>
            <param name="scan0">The origin of the data</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.IntPtr)">
            <summary>
            Allocate the image from the image header. 
            </summary>
            <param name="ptr">This should be only a header to the image. When the image is disposed, the cvReleaseImageHeader will be called on the pointer.</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(Emgu.CV.Mat)">
            <summary>
            Create an Image by copying data from a Mat. 
            </summary>
            <param name="mat">The Mat to copy pixel data from</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.String)">
            <summary>
            Read image from a file
            </summary>
            <param name="fileName">the name of the file that contains the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a blank Image of the specified width and height. 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Drawing.Size)">
            <summary>
            Create a blank Image of the specific size
            </summary>
            <param name="size">The size of the image</param>
        </member>
        <member name="P:Emgu.CV.Image`2.Data">
            <summary>
            Get or Set the data for this matrix. The Get function has O(1) complexity. The Set function make a copy of the data
            </summary>
            <remarks>
            If the image contains Byte and width is not a multiple of 4. The second dimension of the array might be larger than the Width of this image.  
            This is necessary since the length of a row need to be 4 align for OpenCV optimization. 
            The Set function always make a copy of the specific value. If the image contains Byte and width is not a multiple of 4. The second dimension of the array created might be larger than the Width of this image.  
            </remarks>
        </member>
        <member name="M:Emgu.CV.Image`2.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Re-allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels of this image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(Emgu.CV.Image{Emgu.CV.Structure.Gray,`1}[])">
            <summary>
            Create a multi-channel image from multiple gray scale images
            </summary>
            <param name="channels">The image channels to be merged into a single image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Image`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="P:Emgu.CV.Image`2.MIplImage">
            <summary>
            The IplImage structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.ROI">
            <summary> 
            Get or Set the region of interest for this image. To clear the ROI, set it to System.Drawing.Rectangle.Empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.NumberOfChannels">
            <summary>
            Get the number of channels for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.CvDepth">
            <summary>
            Get the equivalent opencv depth type for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.IsROISet">
            <summary> 
            Indicates if the region of interest has been set
            </summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.GetAverage">
            <summary>
            Get the average value on this image
            </summary>
            <returns>The average color of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetAverage(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Get the average value on this image, using the specific mask
            </summary>
            <param name="mask">The mask for find the average value</param>
            <returns>The average color of the masked area</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetSum">
            <summary>Get the sum for each color channel </summary>
            <returns>The sum for each color channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0)">
            <summary>
            Set every pixel of the image to the specific color 
            </summary>
            <param name="color">The color to be set</param>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Set every pixel of the image to the specific color, using a mask
            </summary>
            <param name="color">The color to be set</param>
            <param name="mask">The mask for setting color</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Copy the masked area of this image to destination
            </summary>
            <param name="dest">the destination to copy to</param>
            <param name="mask">the mask for copy</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
            Make a copy of the image using a mask, if ROI is set, only copy the ROI 
            </summary> 
            <param name="mask">the mask for coping</param>
            <returns> A copy of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(System.Drawing.Rectangle)">
            <summary>
            Make a copy of the specific ROI (Region of Interest) from the image
            </summary>
            <param name="roi">The roi to be copied</param>
            <returns>The region of interest</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Get a copy of the boxed region of the image
            </summary>
            <param name="box">The boxed region of the image</param>
            <returns>A copy of the boxed region of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.CopyBlank">
            <summary> 
            Create an image of the same size
            </summary>
            <remarks>The initial pixel in the image equals zero</remarks>
            <returns> The image of the same size</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Clone">
            <summary>
            Make a clone of the current image. All image data as well as the COI and ROI are cloned
            </summary>
            <returns>A clone of the current image. All image data as well as the COI and ROI are cloned</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Get a subimage which image data is shared with the current image.
            </summary>
            <param name="rect">The rectangle area of the sub-image</param>
            <returns>A subimage which image data is shared with the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.Drawing.Rectangle,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>Draw an Rectangle of the specific color and thickness </summary>
            <param name="rect">The rectangle to be drawn</param>
            <param name="color">The color of the rectangle </param>
            <param name="thickness">If thickness is less than 1, the rectangle is filled up </param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.Cross2DF,`0,System.Int32)">
            <summary>Draw a 2D Cross using the specific color and thickness </summary>
            <param name="cross">The 2D Cross to be drawn</param>
            <param name="color">The color of the cross </param>
            <param name="thickness">Must be &gt; 0 </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.LineSegment2DF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>Draw a line segment using the specific color and thickness </summary>
            <param name="line">The line segment to be drawn</param>
            <param name="color">The color of the line segment </param>
            <param name="thickness">The thickness of the line segment </param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.LineSegment2D,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a line segment using the specific color and thickness </summary>
            <param name="line"> The line segment to be drawn</param>
            <param name="color"> The color of the line segment </param>
            <param name="thickness"> The thickness of the line segment </param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.IConvexPolygonF,`0,System.Int32)">
            <summary> Draw a convex polygon using the specific color and thickness </summary>
            <param name="polygon"> The convex polygon to be drawn</param>
            <param name="color"> The color of the triangle </param>
            <param name="thickness"> If thickness is less than 1, the triangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.FillConvexPoly(System.Drawing.Point[],`0,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Fill the convex polygon with the specific color
            </summary>
            <param name="pts">The array of points that define the convex polygon</param>
            <param name="color">The color to fill the polygon with</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.DrawPolyline(System.Drawing.Point[],System.Boolean,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draw the polyline defined by the array of 2D points
            </summary>
            <param name="pts">A polyline defined by its point</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.DrawPolyline(System.Drawing.Point[][],System.Boolean,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draw the polylines defined by the array of array of 2D points
            </summary>
            <param name="pts">An array of polylines each represented by an array of points</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thickness of the line</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.CircleF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a Circle of the specific color and thickness </summary>
            <param name="circle"> The circle to be drawn</param>
            <param name="color"> The color of the circle </param>
            <param name="thickness"> If thickness is less than 1, the circle is filled up </param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.Ellipse,`0,System.Int32,Emgu.CV.CvEnum.LineType)">
            <summary> Draw a Ellipse of the specific color and thickness </summary>
            <param name="ellipse"> The ellipse to be draw</param>
            <param name="color"> The color of the ellipse </param>
            <param name="thickness"> If thickness is less than 1, the ellipse is filled up </param>
            <param name="lineType">Line type</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.String,System.Drawing.Point,Emgu.CV.CvEnum.FontFace,System.Double,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Boolean)">
            <summary>
            Draw the text using the specific font on the image
            </summary>
            <param name="message">The text message to be draw</param>
            <param name="fontFace">Font type.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="bottomLeft">The location of the bottom left corner of the font</param>
            <param name="color">The color of the text</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.IInputArrayOfArrays,System.Int32,`0,System.Int32,Emgu.CV.CvEnum.LineType,Emgu.CV.IInputArray,System.Int32,System.Drawing.Point)">
            <summary>
            Draws contour outlines in the image if thickness&gt;=0 or fills area bounded by the contours if thickness&lt;0
            </summary>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours </param>
            <param name="maxLevel">Maximal level for drawn contours. If 0, only contour is drawn. If 1, the contour and all contours after it on the same level are drawn. If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level. </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrieved in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.Drawing.Point[],`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Drawing.Point)">
            <summary>
            Draws contour outlines in the image if thickness&gt;=0 or fills area bounded by the contours if thickness&lt;0
            </summary>
            <param name="contours">The input contour stored as a point vector.</param>
            <param name="color">Color of the contours </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrieved in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughLinesBinary(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Apply Probabilistic Hough transform to find line segments.
            The current image must be a binary image (eg. the edges as a result of the Canny edge detector)
            </summary>
            <param name="rhoResolution">Distance resolution in pixel-related units.</param>
            <param name="thetaResolution">Angle resolution measured in radians</param>
            <param name="threshold">A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="minLineWidth">Minimum width of a line</param>
            <param name="gapBetweenLines">Minimum gap between lines</param>
            <returns>The line segments detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughLines(System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Apply Canny Edge Detector follows by Probabilistic Hough transform to find line segments in the image
            </summary>
            <param name="cannyThreshold">The threshold to find initial segments of strong edges</param>
            <param name="cannyThresholdLinking">The threshold used for edge Linking</param>
            <param name="rhoResolution">Distance resolution in pixel-related units.</param>
            <param name="thetaResolution">Angle resolution measured in radians</param>
            <param name="threshold">A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="minLineWidth">Minimum width of a line</param>
            <param name="gapBetweenLines">Minimum gap between lines</param>
            <returns>The line segments detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughCircles(`0,`0,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            First apply Canny Edge Detector on the current image,
            then apply Hough transform to find circles
            </summary>
            <param name="cannyThreshold">The higher threshold of the two passed to Canny edge detector (the lower one will be twice smaller).</param>
            <param name="accumulatorThreshold">Accumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first</param>
            <param name="dp">Resolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice smaller width and height, etc</param>
            <param name="minRadius">Minimal radius of the circles to search for</param>
            <param name="maxRadius">Maximal radius of the circles to search for</param>
            <param name="minDist">Minimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed</param>
            <returns>The circle detected for each of the channels</returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Int32)">
            <summary>
            Get or Set the specific channel of the current image.
            For Get operation, a copy of the specific channel is returned.
            For Set operation, the specific channel is copied to this image.
            </summary>
            <param name="channel">The channel to get from the current image, zero based index</param>
            <returns>The specific channel of the current image</returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the color in the <paramref name="row"/>th row (y direction) and <paramref name="column"/>th column (x direction)
            </summary>
            <param name="row">The zero-based row (y direction) of the pixel </param>
            <param name="column">The zero-based column (x direction) of the pixel</param>
            <returns>The color in the specific <paramref name="row"/> and <paramref name="column"/></returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Drawing.Point)">
            <summary>
            Get or Set the color in the <paramref name="location"/>
            </summary>
            <param name="location">the location of the pixel </param>
            <returns>the color in the <paramref name="location"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.RoiParam(System.IntPtr,System.Int64@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Return parameters based on ROI
            </summary>
            <param name="ptr">The Pointer to the IplImage</param>
            <param name="start">The address of the pointer that point to the start of the Bytes taken into consideration ROI</param>
            <param name="elementCount">ROI.Width * ColorType.Dimension</param>
            <param name="byteWidth">The number of bytes in a row taken into consideration ROI</param>
            <param name="rows">The number of rows taken into consideration ROI</param>
            <param name="widthStep">The width step required to jump to the next row</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachChannel``1(System.Func{System.IntPtr,System.Int32,``0})">
            <summary>
            Apply convertor and compute result for each channel of the image.
            </summary>
            <remarks>
            For single channel image, apply converter directly.
            For multiple channel image, set the COI for the specific channel before appling the convertor
            </remarks>
            <typeparam name="TResult">The return type</typeparam>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachDuplicateChannel``1(System.Action{Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32},Emgu.CV.Image{`0,``0})">
            <summary>
            If the image has only one channel, apply the action directly on the IntPtr of this image and <paramref name="dest"/>,
            otherwise, make copy each channel of this image to a temperary one, apply action on it and another temperory image and copy the resulting image back to image2
            </summary>
            <typeparam name="TOtherDepth">The type of the depth of the <paramref name="dest"/> image</typeparam>
            <param name="act">The function which acepts the src IntPtr, dest IntPtr and index of the channel as input</param>
            <param name="dest">The destination image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Sobel(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the image derivative by convolving the image with the appropriate kernel
            The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative.
            </summary>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="apertureSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. In all cases except 1, aperture_size xaperture_size separable kernel will be used to calculate the derivative.</param>
            <returns>The result of the sobel edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Laplace(System.Int32)">
             <summary>
             Calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator.
             Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            
             |0  1  0|
             |1 -4  1|
             |0  1  0|
             </summary>
             <param name="apertureSize">Aperture size </param>
             <returns>The Laplacian of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Canny(System.Double,System.Double)">
            <summary> Find the edges on this image and marked them in the returned image.</summary>
            <param name="thresh"> The threshhold to find initial segments of strong edges</param>
            <param name="threshLinking"> The threshold used for edge Linking</param>
            <returns> The edges found by the Canny edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Canny(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary> Find the edges on this image and marked them in the returned image.</summary>
            <param name="thresh"> The threshhold to find initial segments of strong edges</param>
            <param name="threshLinking"> The threshold used for edge Linking</param>
            <param name="apertureSize">The aperture size, use 3 for default</param>
            <param name="l2Gradient">a flag, indicating whether a more accurate norm should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default norm is enough ( L2gradient=false ).</param>
            <returns> The edges found by the Canny edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.FindCornerSubPix(System.Drawing.PointF[][],System.Drawing.Size,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </summary>
            <param name="corners">Coordinates of the input corners, the values will be modified by this function call</param>
            <param name="win">Half sizes of the search window. For example, if win=(5,5) then 5*2+1 x 5*2+1 = 11 x 11 search window is used</param>
            <param name="zeroZone">Half size of the dead region in the middle of the search zone over which the summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such size</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after certain number of iteration or when a required accuracy is achieved. The criteria may specify either of or both the maximum number of iteration and the required accuracy</param>
            <returns>Refined corner coordinates</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MatchTemplate(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.TemplateMatchingType)">
            <summary>
            The function slides through image, compares overlapped patches of size wxh with templ using the specified method and return the comparison results 
            </summary>
            <param name="template">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
            <returns>The comparison result: width = this.Width - template.Width + 1; height = this.Height - template.Height + 1 </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise AND operation with another image and return the result</summary>
            <param name="img2">The second image for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
            Perform an elementwise AND operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0)">
            <summary> Perform an binary AND operation with some color</summary>
            <param name="val">The color for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an binary AND operation with some color using a mask</summary>
            <param name="val">The color for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise OR operation with another image and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with another image, using a mask, and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0)">
            <summary> Perform an elementwise OR operation with some color</summary>
            <param name="val">The value for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with some color using a mask</summary>
            <param name="val">The color for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise XOR operation with another image and return the result</summary>
            <param name="img2">The second image for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Perform an elementwise XOR operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns>The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0)">
            <summary> 
            Perform an binary XOR operation with some color
            </summary>
            <param name="val">The value for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Perform an binary XOR operation with some color using a mask
            </summary>
            <param name="val">The color for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Not">
            <summary> 
            Compute the complement image
            </summary>
            <returns> The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise maximum value </summary>
            <param name="img2">The second image for the Max operation</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(System.Double)">
            <summary> Find the elementwise maximum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise minimum value </summary>
            <param name="img2">The second image for the Min operation</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(System.Double)">
            <summary> Find the elementwise minimum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InRange(`0,`0)">
            <summary>Checks that image elements lie between two scalars</summary>
            <param name="lower"> The inclusive lower limit of color value</param>
            <param name="higher"> The inclusive upper limit of color value</param>
            <returns> res[i,j] = 255 if <paramref name="lower"/> &lt;= this[i,j] &lt;= <paramref name="higher"/>, 0 otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InRange(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>Checks that image elements lie between values defined by two images of same size and type</summary>
            <param name="lower"> The inclusive lower limit of color value</param>
            <param name="higher"> The inclusive upper limit of color value</param>
            <returns> res[i,j] = 255 if <paramref name="lower"/>[i,j] &lt;= this[i,j] &lt;= <paramref name="higher"/>[i,j], 0 otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.CmpType)">
            <summary>
            Compare the current image with <paramref name="img2"/> and returns the comparison mask
            </summary>
            <param name="img2">The other image to compare with</param>
            <param name="cmpType">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(System.Double,Emgu.CV.CvEnum.CmpType)">
            <summary>
            Compare the current image with <paramref name="value"/> and returns the comparison mask
            </summary>
            <param name="value">The value to compare with</param>
            <param name="comparisonType">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Equals(Emgu.CV.Image{`0,`1})">
            <summary>
            Compare two images, returns true if each of the pixels are equal, false otherwise
            </summary>
            <param name="img2">The other image to compare with</param>
            <returns>true if each of the pixels for the two images are equal, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GrabCut(System.Drawing.Rectangle,System.Int32)">
            <summary>
            Use grabcut to perform background foreground segmentation.
            </summary>
            <param name="rect">The initial rectangle region for the foreground</param>
            <param name="iteration">The number of iterations to run GrabCut</param>
            <returns>The background foreground mask where 2 indicates background and 3 indicates foreground</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise subtract another image from the current image </summary>
            <param name="img2">The second image to be subtracted from the current image</param>
            <returns> The result of elementwise subtracting img2 from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Elementwise subtract another image from the current image, using a mask</summary>
            <param name="img2">The image to be subtracted from the current image</param>
            <param name="mask">The mask for the subtract operation</param>
            <returns> The result of elementwise subtracting img2 from the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(`0)">
            <summary> Elementwise subtract a color from the current image</summary>
            <param name="val">The color value to be subtracted from the current image</param>
            <returns> The result of elementwise subtracting color 'val' from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0)">
            <summary>
            result = val - this
            </summary>
            <param name="val">the value which subtract this image</param>
            <returns>val - this</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            result = val - this, using a mask
            </summary>
            <param name="val">The value which subtract this image</param>
            <param name="mask">The mask for subtraction</param>
            <returns>val - this, with mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise add another image with the current image </summary>
            <param name="img2">The image to be added to the current image</param>
            <returns> The result of elementwise adding img2 to the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Elementwise add <paramref name="img2"/> with the current image, using a mask</summary>
            <param name="img2">The image to be added to the current image</param>
            <param name="mask">The mask for the add operation</param>
            <returns> The result of elementwise adding img2 to the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(`0)">
            <summary> Elementwise add a color <paramref name="val"/> to the current image</summary>
            <param name="val">The color value to be added to the current image</param>
            <returns> The result of elementwise adding color <paramref name="val"/> from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> Elementwise multiply another image with the current image and the <paramref name="scale"/></summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <param name="scale">The scale to be multiplied</param>
            <returns> this .* img2 * scale </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise multiply <paramref name="img2"/> with the current image</summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <returns> this .* img2 </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(System.Double)">
            <summary> Elementwise multiply the current image with <paramref name="scale"/></summary>
            <param name="scale">The scale to be multiplied</param>
            <returns> The scaled image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Accumulate(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Accumulate <paramref name="img2"/> to the current image using the specific mask
            </summary>
            <param name="img2">The image to be added to the current image</param>
            <param name="mask">the mask</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Accumulate(Emgu.CV.Image{`0,`1})">
            <summary>
            Accumulate <paramref name="img2"/> to the current image using the specific mask
            </summary>
            <param name="img2">The image to be added to the current image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AddWeighted(Emgu.CV.Image{`0,`1},System.Double,System.Double,System.Double)">
            <summary> 
            Return the weighted sum such that: res = this * alpha + img2 * beta + gamma
            </summary>
            <param name="img2">img2 in: res = this * alpha + img2 * beta + gamma </param>
            <param name="alpha">alpha in: res = this * alpha + img2 * beta + gamma</param>
            <param name="beta">beta in: res = this * alpha + img2 * beta + gamma</param>
            <param name="gamma">gamma in: res = this * alpha + img2 * beta + gamma</param>
            <returns>this * alpha + img2 * beta + gamma</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.AccumulateWeighted(Emgu.CV.Image{`0,`1},System.Double,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
            Update Running Average. <i>this</i> = (1-alpha)*<i>this</i> + alpha*img, using the mask
            </summary>
            <param name="img">Input image, 1- or 3-channel, Byte or Single (each channel of multi-channel image is processed independently). </param>
            <param name="alpha">The weight of <paramref name="img"/></param>
            <param name="mask">The mask for the running average</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AbsDiff(Emgu.CV.Image{`0,`1})">
            <summary> 
            Computes absolute different between <i>this</i> image and the other image
            </summary>
            <param name="img2">The other image to compute absolute different with</param>
            <returns> The image that contains the absolute different value</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.AbsDiff(`0)">
            <summary> 
            Computes absolute different between <i>this</i> image and the specific color
            </summary>
            <param name="color">The color to compute absolute different with</param>
            <returns> The image that contains the absolute different value</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Pow(System.Double)">
            <summary>
            Raises every element of input array to p
            dst(I)=src(I)^p, if p is integer
            dst(I)=abs(src(I))^p, otherwise
            </summary>
            <param name="power">The exponent of power</param>
            <returns>The power image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Exp">
            <summary>
            Calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            </summary>
            <remarks>Maximum relative error is ~7e-6. Currently, the function converts denormalized values to zeros on output.</remarks>
            <returns>The exponent image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Log">
            <summary>
            Calculates natural logarithm of absolute value of every element of input array
            </summary>
            <returns>Natural logarithm of absolute value of every element of input array</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,Emgu.CV.CvEnum.Inter)">
            <summary>
            Scale the image to the specific size 
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="interpolationType">The type of interpolation</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,Emgu.CV.CvEnum.Inter,System.Boolean)">
            <summary>
            Scale the image to the specific size
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="interpolationType">The type of interpolation</param>
            <param name="preserveScale">if true, the scale is preservered and the resulting image has maximum width(height) possible that is &lt;= <paramref name="width"/> (<paramref name="height"/>), if false, this function is equaivalent to Resize(int width, int height)</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Double,Emgu.CV.CvEnum.Inter)">
            <summary>
            Scale the image to the specific size: width *= scale; height *= scale  
            </summary>
            <param name="scale">The scale to resize</param>
            <param name="interpolationType">The type of interpolation</param>
            <returns>The scaled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpAffine(Emgu.CV.Mat,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpAffine(Emgu.CV.Mat,System.Int32,System.Int32,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="width">The width of the resulting image</param>
            <param name="height">the height of the resulting image</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpPerspective``1(Emgu.CV.Matrix{``0},Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <typeparam name="TMapDepth">The depth type of <paramref name="mapMatrix"/>, should be either float or double</typeparam>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpPerspective``1(Emgu.CV.Matrix{``0},System.Int32,System.Int32,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="width">The width of the resulting image</param>
            <param name="height">the height of the resulting image</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderType">Border type</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <typeparam name="TMapDepth">The depth type of <paramref name="mapMatrix"/>, should be either float or double</typeparam>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,`0,System.Boolean)">
            <summary>
            Rotate this image the specified <paramref name="angle"/>
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with which to fill the background</param>
            <param name="crop">If set to true the image is cropped to its original size, possibly losing corners information. If set to false the result image has different size than original and all rotation information is preserved</param>
            <returns>The rotated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,System.Drawing.PointF,Emgu.CV.CvEnum.Inter,`0,System.Boolean)">
            <summary>
            Rotate this image the specified <paramref name="angle"/>
            </summary>
            <param name="angle">The angle of rotation in degrees. Positive means clockwise.</param>
            <param name="background">The color with with to fill the background</param>
            <param name="crop">If set to true the image is cropped to its original size, possibly losing corners information. If set to false the result image has different size than original and all rotation information is preserved</param>
            <param name="center">The center of rotation</param>
            <param name="interpolationMethod">The interpolation method</param>
            <returns>The rotated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.LogPolar(System.Drawing.PointF,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp)">
            <summary>
            Convert the image to log polar, simulating the human foveal vision
            </summary>
            <param name="center">The transformation center, where the output precision is maximal</param>
            <param name="magnitude">Magnitude scale parameter</param>
            <param name="interpolationType">interpolation type</param>
            <param name="warpType">Warp type</param>
            <returns>The converted image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2">
            <summary> Convert the current image to the specific color and depth </summary>
            <typeparam name="TOtherColor"> The type of color to be converted to </typeparam>
            <typeparam name="TOtherDepth"> The type of pixel depth to be converted to </typeparam>
            <returns> Image of the specific color and depth </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertFrom``2(Emgu.CV.Image{``0,``1})">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <typeparam name="TSrcColor">The color type of the source image</typeparam>
            <typeparam name="TSrcDepth">The color depth of the source image</typeparam>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertFrom(Emgu.CV.IInputArray)">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertScale``1(System.Double,System.Double)">
            <summary> Convert the current image to the specific depth, at the same time scale and shift the values of the pixel</summary>
            <param name="scale"> The value to be multiplied with the pixel </param>
            <param name="shift"> The value to be added to the pixel</param>
            <typeparam name="TOtherDepth"> The type of depth to convert to</typeparam>
            <returns> Image of the specific depth, val = val * scale + shift </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrDown">
            <summary>
            Performs downsampling step of Gaussian pyramid decomposition. 
            First it convolves <i>this</i> image with the specified filter and then downsamples the image 
            by rejecting even rows and columns.
            </summary>
            <returns> The down-sampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrUp">
            <summary>
            Performs up-sampling step of Gaussian pyramid decomposition. 
            First it up-samples <i>this</i> image by injecting even zero rows and columns and then convolves 
            result with the specified filter multiplied by 4 for interpolation. 
            So the resulting image is four times larger than the source image.
            </summary>
            <returns> The up-sampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.BuildPyramid(System.Int32)">
            <summary>
            Compute the image pyramid
            </summary>
            <param name="maxLevel">The number of level's for the pyramid; Level 0 referes to the current image, level n is computed by calling the PyrDown() function on level n-1</param>
            <returns>The image pyramid</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InPaint(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Double)">
            <summary> Use inpaint to recover the intensity of the pixels which location defined by <paramref name="mask"/> on <i>this</i> image </summary>
            <param name="mask">The inpainting mask. Non-zero pixels indicate the area that needs to be inpainted</param>
            <param name="radius">The radius of circular neighborhood of each point inpainted that is considered by the algorithm</param>
            <returns> The inpainted image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MorphologyEx(Emgu.CV.CvEnum.MorphOp,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Perform advanced morphological transformations using erosion and dilation as basic operations.
            </summary>
            <param name="kernel">Structuring element</param>
            <param name="anchor">Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</param>
            <param name="operation">Type of morphological operation</param>
            <param name="iterations">Number of times erosion and dilation are applied</param>
            <param name="borderType">Border type</param>
            <param name="borderValue">Border value</param>
            <returns>The result of the morphological operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._MorphologyEx(Emgu.CV.CvEnum.MorphOp,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Perform inplace advanced morphological transformations using erosion and dilation as basic operations.
            </summary>
            <param name="kernel">Structuring element</param>
            <param name="anchor">Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</param>
            <param name="operation">Type of morphological operation</param>
            <param name="iterations">Number of times erosion and dilation are applied</param>
            <param name="borderType">Border type</param>
            <param name="borderValue">Border value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image using a 3x3 rectangular structuring element.
            Erosion are applied several (iterations) times
            </summary>
            <param name="iterations">The number of erode iterations</param>
            <returns> The eroded image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image using a 3x3 rectangular structuring element.
            Dilation are applied several (iterations) times
            </summary>
            <param name="iterations">The number of dilate iterations</param>
            <returns> The dilated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Erosion are applied several (iterations) times
            </summary>
            <param name="iterations">The number of erode iterations</param>
        </member>
        <member name="M:Emgu.CV.Image`2._Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Dilation are applied several (iterations) times
            </summary>
            <param name="iterations">The number of dilate iterations</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Action(System.Action{`1})">
            <summary> 
            perform an generic action based on each element of the image
            </summary>
            <param name="action">The action to be applied to each element of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Action``1(Emgu.CV.Image{`0,``0},System.Action{`1,``0})">
            <summary>
            Perform an generic operation based on the elements of the two images
            </summary>
            <typeparam name="TOtherDepth">The depth of the second image</typeparam>
            <param name="img2">The second image to perform action on</param>
            <param name="action">An action such that the first parameter is the a single channel of a pixel from the first image, the second parameter is the corresponding channel of the correspondind pixel from the second image </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(System.Func{`1,System.Int32,System.Int32,``0})">
            <summary> 
            Compute the element of a new image based on the value as well as the x and y positions of each pixel on the image
            </summary>
            <param name="converter">The function to be applied to the image pixels</param>
            <typeparam name="TOtherDepth">The depth type to convert the image to.</typeparam>
            <returns>The result image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(System.Func{`1,``0})">
            <summary> Compute the element of the new image based on element of this image</summary>
            <typeparam name="TOtherDepth">The depth type of the result image</typeparam>
            <param name="converter">The function to be applied to the image pixels</param>
            <returns>The result image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2(Emgu.CV.Image{`0,``0},System.Func{`1,``0,``1})">
            <summary> Compute the element of the new image based on the elements of the two image</summary>
            <typeparam name="TDepth2">The depth type of img2</typeparam>
            <typeparam name="TDepth3">The depth type of the result image</typeparam>
            <param name="img2">The second image</param>
            <param name="converter">The function to be applied to the image pixels</param>
            <returns>The result image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``3(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},System.Func{`1,``0,``1,``2})">
            <summary> Compute the element of the new image based on the elements of the three image</summary>
            <typeparam name="TDepth2">The depth type of img2</typeparam>
            <typeparam name="TDepth3">The depth type of img3</typeparam>
            <typeparam name="TDepth4">The depth type of the result image</typeparam>
            <param name="img2">The second image</param>
            <param name="img3">The third image</param>
            <param name="converter">The function to be applied to the image pixels</param>
            <returns>The result image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``4(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},Emgu.CV.Image{`0,``2},System.Func{`1,``0,``1,``2,``3})">
            <summary> Compute the element of the new image based on the elements of the four image</summary>
            <typeparam name="TDepth2">The depth type of img2</typeparam>
            <typeparam name="TDepth3">The depth type of img3</typeparam>
            <typeparam name="TDepth4">The depth type of img4</typeparam>
            <typeparam name="TDepth5">The depth type of the result image</typeparam>
            <param name="img2">The second image</param>
            <param name="img3">The third image</param>
            <param name="img4">The fourth image</param>
            <param name="converter">The function to be applied to the image pixels</param>
            <returns>The result image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.DisposeObject">
            <summary>
            Release all unmanaged memory associate with the image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an element wise AND operation on the two images
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="img2">The second image to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Perform an element wise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an element wise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Perform an element wise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an element wise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary> Perform an element wise OR operation with another image and return the result</summary>
            <param name="img1">The first image to apply bitwise OR operation</param>
            <param name="img2">The second image to apply bitwise OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> 
            Perform an binary OR operation with some color
            </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(System.Double,Emgu.CV.Image{`0,`1})">
            <summary> 
            Perform an binary OR operation with some color
            </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},`0)">
            <summary> 
            Perform an binary OR operation with some color
            </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(`0,Emgu.CV.Image{`0,`1})">
            <summary> 
            Perform an binary OR operation with some color
            </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_OnesComplement(Emgu.CV.Image{`0,`1})">
            <summary>Compute the complement image</summary>
            <param name="image">The image to be inverted</param>
            <returns>The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Element wise add <paramref name="img1"/> with <paramref name="img2"/>
            </summary>
            <param name="img1">The first image to be added</param>
            <param name="img2">The second image to be added</param>
            <returns>The sum of the two images</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Element wise add <paramref name="img1"/> with <paramref name="val"/>
            </summary>
            <param name="img1">The image to be added</param>
            <param name="val">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Element wise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Element wise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Element wise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Element wise subtract another image from the current image
            </summary>
            <param name="image1">The image to be subtracted</param>
            <param name="image2">The second image to be subtracted from <paramref name="image1"/></param>
            <returns> The result of element wise subtracting img2 from <paramref name="image1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Element wise subtract another image from the current image
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> The result of element wise subtracting <paramref name="value"/> from <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Element wise subtract another image from the current image
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> <paramref name="value"/> - <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            <paramref name="value"/> - <paramref name="image"/>
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramref name="value"/> - <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Element wise subtract another image from the current image
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramref name="image"/> - <paramref name="value"/>   </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="image"/> * <paramref name="scale"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="image"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/>*<paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="scale"/>*<paramref name="image"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},Emgu.CV.ConvolutionKernelF)">
            <summary>
            Perform the convolution with <paramref name="kernel"/> on <paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="kernel">The kernel</param>
            <returns>Result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="image"/> / <paramref name="scale"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The division scale</param>
            <returns><paramref name="image"/> / <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/> / <paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The scale</param>
            <returns><paramref name="scale"/> / <paramref name="image"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBlur(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Summation over a pixel param1 x param2 neighborhood. If scale is true, the result is subsequent scaled by 1/(param1 x param2)
            </summary>
            <param name="width">The width of the window</param>
            <param name="height">The height of the window</param>
            <param name="scale">If true, the result is subsequent scaled by 1/(param1 x param2)</param>
            <returns>The result of blur</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothMedian(System.Int32)">
            <summary>
            Finding median of <paramref name="size"/>x<paramref name="size"/> neighborhood 
            </summary>
            <param name="size">The size (width &amp; height) of the window</param>
            <returns>The result of median smooth</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBilateral(System.Int32,System.Int32,System.Int32)">
            <summary>
            Applying bilateral 3x3 filtering
            </summary>
            <param name="colorSigma">Color sigma</param>
            <param name="spaceSigma">Space sigma</param>
            <param name="kernelSize">The size of the bilateral kernel</param>
            <returns>The result of bilateral smooth</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothGaussian(System.Int32)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref name="kernelSize"/> x <paramref name="kernelSize"/>)</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothGaussian(System.Int32,System.Int32,System.Double,System.Double)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma1"> The standard deviation of the Gaussian kernel in the horizontal dimension</param>
            <param name="sigma2"> The standard deviation of the Gaussian kernel in the vertical dimension</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._SmoothGaussian(System.Int32)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref name="kernelSize"/> x <paramref name="kernelSize"/>)</param>
        </member>
        <member name="M:Emgu.CV.Image`2._SmoothGaussian(System.Int32,System.Int32,System.Double,System.Double)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma1"> The standard deviation of the Gaussian kernel in the horizontal dimension</param>
            <param name="sigma2"> The standard deviation of the Gaussian kernel in the vertical dimension</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Convolution(Emgu.CV.ConvolutionKernelF,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary> 
            Performs a convolution using the specific <paramref name="kernel"/> 
            </summary>
            <param name="kernel">The convolution kernel</param>
            <param name="delta">The optional value added to the filtered pixels before storing them in dst</param>
            <param name="borderType">The pixel extrapolation method.</param>
            <returns>The result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral">
            <summary>
            Calculates integral images for the source image
            </summary>
            <returns>The integral image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral(Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@)">
            <summary>
            Calculates integral images for the source image
            </summary>
            <param name="sum">The integral image</param>
            <param name="squareSum">The integral image for squared pixel values</param>
            <returns>The integral image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral(Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@)">
            <summary>
            Calculates one or more integral images for the source image
            </summary>
            <param name="sum">The integral image</param>
            <param name="squareSum">The integral image for squared pixel values</param>
            <param name="titledSum">The integral for the image rotated by 45 degrees</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdAdaptive(`0,Emgu.CV.CvEnum.AdaptiveThresholdType,Emgu.CV.CvEnum.ThresholdType,System.Int32,`0)">
            <summary>
            Transforms grayscale image to binary image. 
            Threshold calculated individually for each pixel. 
            For the method CV_ADAPTIVE_THRESH_MEAN_C it is a mean of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel
            neighborhood, subtracted by param1. 
            For the method CV_ADAPTIVE_THRESH_GAUSSIAN_C it is a weighted sum (gaussian) of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel neighborhood, subtracted by param1.
            </summary>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="adaptiveType">Adaptive_method </param>
            <param name="thresholdType">Thresholding type. must be one of CV_THRESH_BINARY, CV_THRESH_BINARY_INV  </param>
            <param name="blockSize">The size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, ... </param>
            <param name="param1">Constant subtracted from mean or weighted mean. It may be negative. </param>
            <returns>The result of the adaptive threshold</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBase(Emgu.CV.Image{`0,`1},`0,`0,Emgu.CV.CvEnum.ThresholdType)">
            <summary> 
            The base threshold method shared by public threshold functions 
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZero(`0)">
            <summary> Threshold the image such that: dst(x,y) = src(x,y), if src(x,y)&gt;threshold;  0, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <returns> dst(x,y) = src(x,y), if src(x,y)&gt;threshold;  0, otherwise </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZeroInv(`0)">
            <summary> 
            Threshold the image such that: dst(x,y) = 0, if src(x,y)&gt;threshold;  src(x,y), otherwise 
            </summary>
            <param name="threshold">The threshold value</param>
            <returns>The image such that: dst(x,y) = 0, if src(x,y)&gt;threshold;  src(x,y), otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdTrunc(`0)">
            <summary>
            Threshold the image such that: dst(x,y) = threshold, if src(x,y)&gt;threshold; src(x,y), otherwise 
            </summary>
            <param name="threshold">The threshold value</param>
            <returns>The image such that: dst(x,y) = threshold, if src(x,y)&gt;threshold; src(x,y), otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinary(`0,`0)">
            <summary> 
            Threshold the image such that: dst(x,y) = max_value, if src(x,y)&gt;threshold; 0, otherwise 
            </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
            <returns>The image such that: dst(x,y) = max_value, if src(x,y)&gt;threshold; 0, otherwise </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image such that: dst(x,y) = 0, if src(x,y)&gt;threshold;  max_value, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
            <returns>The image such that: dst(x,y) = 0, if src(x,y)&gt;threshold;  max_value, otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZero(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = src(x,y), if src(x,y)&gt;threshold;  0, otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZeroInv(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)&gt;threshold;  src(x,y), otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdTrunc(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = threshold, if src(x,y)&gt;threshold; src(x,y), otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinary(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = max_value, if src(x,y)&gt;threshold; 0, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)&gt;threshold;  max_value, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AvgSdv(`0@,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <param name="average">The avg color</param>
            <param name="sdv">The standard deviation for each channel</param>
            <param name="mask">The operation mask</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AvgSdv(`0@,Emgu.CV.Structure.MCvScalar@)">
            <summary>
            Calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <param name="avg">The avg color</param>
            <param name="sdv">The standard deviation for each channel</param>
        </member>
        <member name="M:Emgu.CV.Image`2.CountNonzero">
            <summary>
            Count the non Zero elements for each channel
            </summary>
            <returns>Count the non Zero elements for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Flip(Emgu.CV.CvEnum.FlipType)">
            <summary> Return a flipped copy of the current image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2._Flip(Emgu.CV.CvEnum.FlipType)">
            <summary> Inplace flip the image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConcateVertical(Emgu.CV.Image{`0,`1})">
            <summary>
            Concate the current image with another image vertically.
            </summary>
            <param name="otherImage">The other image to concate</param>
            <returns>A new image that is the vertical concatening of this image and <paramref name="otherImage"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConcateHorizontal(Emgu.CV.Image{`0,`1})">
            <summary>
            Concate the current image with another image horizontally. 
            </summary>
            <param name="otherImage">The other image to concate</param>
            <returns>A new image that is the horizontal concatening of this image and <paramref name="otherImage"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetMoments(System.Boolean)">
            <summary>
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characteristics including 7 Hu invariants.
            </summary>
            <param name="binary">If the flag is true, all the zero pixel values are treated as zeroes, all the others are treated as 1's</param>
            <returns>spatial and central moments up to the third order</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._GammaCorrect(System.Double)">
            <summary>
            Gamma corrects this image inplace. The image must have a depth type of Byte.
            </summary>
            <param name="gamma">The gamma value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Save(System.String)">
            <summary>
            Save this image to the specific file. 
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
            <remarks>The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format.</remarks>
        </member>
        <member name="M:Emgu.CV.Image`2._EqualizeHist">
            <summary>
            The algorithm inplace normalizes brightness and increases contrast of the image.
            For color images, a HSV representation of the image is first obtained and the V (value) channel is histogram normalized
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadImageFromMat(Emgu.CV.Mat)">
            <summary>
            This function load the image data from Mat
            </summary>
            <param name="mat">The Mat</param>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadImageFromIplImagePtr(System.IntPtr)">
            <summary>
            This function load the image data from the iplImage pointer
            </summary>
            <param name="iplImage">The pointer to the iplImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.FromIplImagePtr(System.IntPtr)">
            <summary>
            Get the managed image from an unmanaged IplImagePointer
            </summary>
            <param name="iplImage">The pointer to the iplImage</param>
            <returns>The managed image from the iplImage pointer</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ToJpegData(System.Int32)">
            <summary>
            Get the jpeg representation of the image
            </summary>
            <param name="quality">The jpeg quality</param>
            <returns>An byte array that contains the image as jpeg data</returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Size">
            <summary> 
            Get the size of the array
            </summary>
        </member>
        <member name="T:Emgu.CV.ImageConstants">
            <summary>
            Constants used by the image class
            </summary>
        </member>
        <member name="F:Emgu.CV.ImageConstants.RoiOffset">
            <summary>
            Offset of roi
            </summary>
        </member>
        <member name="T:Emgu.CV.ImageDataReleaseMode">
            <summary>
            Image data release mode
            </summary>
        </member>
        <member name="F:Emgu.CV.ImageDataReleaseMode.ReleaseHeaderOnly">
            <summary>
            Release just the header
            </summary>
        </member>
        <member name="F:Emgu.CV.ImageDataReleaseMode.ReleaseIplImage">
            <summary>
            Release the IplImage
            </summary>
        </member>
        <member name="T:Emgu.CV.InputArray">
            <summary>
            This is the proxy class for passing read-only input arrays into OpenCV functions.
            </summary>
            <summary>
            This is the proxy class for passing read-only input arrays into OpenCV functions.
            </summary>
        </member>
        <member name="T:Emgu.CV.InputArray.Type">
            <summary>
            Input array type
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.KindShift">
            <summary>
            kind shift
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.FixedType">
            <summary>
            Fixed type
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.FixedSize">
            <summary>
            Fixed size
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.KindMask">
            <summary>
            Kind mask
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.Mat">
            <summary>
            Mat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.Matx">
            <summary>
            Matx
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVector">
            <summary>
            StdVector
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVectorVector">
            <summary>
            StdVectorVector
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVectorMat">
            <summary>
            StdVectorMat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.Expr">
            <summary>
            Expr
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.OpenglBuffer">
            <summary>
            Opengl buffer
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.CudaHostMem">
            <summary>
            Cuda Host Mem
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.CudaGpuMat">
            <summary>
            Cuda GpuMat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.UMat">
            <summary>
            UMat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVectorUMat">
            <summary>
            StdVectorUMat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdBoolVector">
            <summary>
            StdBoolVector
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVectorCudaGpuMat">
            <summary>
            StdVectorCudaGpuMat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray._parent">
            <summary>
            A reference to the Parent object
            </summary>
        </member>
        <member name="M:Emgu.CV.InputArray.#ctor(System.IntPtr,System.Object)">
            <summary>
            Create a Input array from an existing unmanaged inputArray pointer
            </summary>
            <param name="inputArrayPtr">The unmanaged pointer the the InputArray</param>
            <param name="parent">The parent object to keep reference to</param>
        </member>
        <member name="M:Emgu.CV.InputArray.GetEmpty">
            <summary>
            Get an empty input array
            </summary>
            <returns>An empty input array</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetMat(System.Int32)">
            <summary>
            Get the Mat from the input array
            </summary>
            <param name="idx">The index, in case if this is an VectorOfMat</param>
            <returns>The Mat</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetUMat(System.Int32)">
            <summary>
            Get the UMat from the input array
            </summary>
            <param name="idx">The index, in case if this is an VectorOfUMat</param>
            <returns>The UMat</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetSize(System.Int32)">
            <summary>
            Get the size of the input array
            </summary>
            <param name="idx">The optional index</param>
            <returns>The size of the input array</returns>
        </member>
        <member name="P:Emgu.CV.InputArray.IsEmpty">
            <summary>
            Return true if the input array is empty
            </summary>
        </member>
        <member name="M:Emgu.CV.InputArray.GetDepth(System.Int32)">
            <summary>
            Get the depth type
            </summary>
            <param name="idx">The optional index</param>
            <returns>The depth type</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetDims(System.Int32)">
            <summary>
            Get the number of dimensions
            </summary>
            <param name="i">The optional index</param>
            <returns>The dimensions</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetChannels(System.Int32)">
            <summary>
            Get the number of channels
            </summary>
            <param name="idx">The optional index</param>
            <returns>The number of channels</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Copy this Input array to another.
            </summary>
            <param name="arr">The destination array.</param>
            <param name="mask">The optional mask.</param>
        </member>
        <member name="M:Emgu.CV.InputArray.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this InputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.IsMat">
            <summary>
            True if the input array is a Mat
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.IsUMat">
            <summary>
            True if the input array is an UMat
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.IsMatVector">
            <summary>
            True if the input array is a vector of Mat
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.IsUMatVector">
            <summary>
            True if the input array is a vector of UMat
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.IsMatx">
            <summary>
            True if the input array is a Matx
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.Kind">
            <summary>
            The type of the input array
            </summary>
        </member>
        <member name="M:Emgu.CV.InputArray.GetGpuMat">
            <summary>
            Get the GpuMat from the input array
            </summary>
            <returns>The GpuMat</returns>
        </member>
        <member name="T:Emgu.CV.InputOutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for input/output function parameters.
            </summary>
        </member>
        <member name="M:Emgu.CV.InputOutputArray.#ctor(System.IntPtr,System.Object)">
            <summary>
            Create an InputOutputArray from an existing unmanaged inputOutputArray pointer
            </summary>
            <param name="inputOutputArrayPtr">The pointer to the existing inputOutputArray</param>
            <param name="parent">The parent object to keep reference to</param>
        </member>
        <member name="M:Emgu.CV.InputOutputArray.GetEmpty">
            <summary>
            Get an empty InputOutputArray
            </summary>
            <returns>An empty InputOutputArray</returns>
        </member>
        <member name="M:Emgu.CV.InputOutputArray.DisposeObject">
            <summary>
            Release all the memory associated with this InputOutputArray
            </summary>
        </member>
        <member name="T:Emgu.CV.IOutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for output function parameters.
            </summary>
        </member>
        <member name="M:Emgu.CV.IOutputArray.GetOutputArray">
            <summary>
            The unmanaged pointer to the output array
            </summary>
            <returns>Get the output array</returns>
        </member>
        <member name="T:Emgu.CV.IOutputArrayOfArrays">
            <summary>
            OutputArrayOfArrays
            </summary>
        </member>
        <member name="T:Emgu.CV.Map`2">
            <summary>
            A Map is similar to an Image, except that the location of the pixels is defined by 
            its area and resolution
            </summary>
            <typeparam name="TColor">The color of this map</typeparam>
            <typeparam name="TDepth">The depth of this map</typeparam>
        </member>
        <member name="P:Emgu.CV.Map`2.Area">
            <summary>
            Get the area of this map as a rectangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Map`2.Resolution">
            <summary>
            Get the resolution of this map as a 2D point
            </summary>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Drawing.RectangleF,System.Drawing.PointF,`0)">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle.
            </summary>
            <param name="area">The area this map covers.</param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
            <param name="color"> The initial color of the map</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Drawing.RectangleF,System.Drawing.PointF)">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle. The initial value of the map is 0.0
            </summary>
            <param name="area">The area this map covers.</param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
        </member>
        <member name="M:Emgu.CV.Map`2.MapPointToImagePoint(Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Map a point to a position in the internal image
            </summary>
            <param name="pt">The point on the map</param>
            <returns>The point on the image</returns>
        </member>
        <member name="M:Emgu.CV.Map`2.MapPointToImagePoint(System.Drawing.PointF)">
            <summary>
            Map a point to a position in the internal image
            </summary>
            <param name="pt">The point on the map</param>
            <returns>The point on the image</returns>
        </member>
        <member name="M:Emgu.CV.Map`2.ImagePointToMapPoint(System.Drawing.Point)">
            <summary>
            Map an image point to a Map point
            </summary>
            <param name="pt">The point on image</param>
            <returns>The point on map</returns>
        </member>
        <member name="M:Emgu.CV.Map`2.Copy(System.Drawing.RectangleF)">
            <summary>
            Get a copy of the map in the specific area
            </summary>
            <param name="area">the area of the map to be retrieve</param>
            <returns>The area of the map</returns>
        </member>
        <member name="P:Emgu.CV.Map`2.ROI">
            <summary> 
            Get or Set the region of interest for this map. To clear the ROI, set it to System.Drawing.RectangleF.Empty
            </summary>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(System.Drawing.RectangleF,`0,System.Int32)">
            <summary>
            Draw a rectangle in the map
            </summary>
            <param name="rect">The rectangle to draw</param>
            <param name="color">The color for the rectangle</param>
            <param name="thickness">The thickness of the rectangle, any value less than or equal to 0 will result in a filled rectangle</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.Structure.LineSegment2DF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draw a line segment in the map
            </summary>
            <param name="line">The line to be draw</param>
            <param name="color">The color for the line</param>
            <param name="thickness">The thickness of the line</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.Structure.CircleF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a Circle of the specific color and thickness </summary>
            <param name="circle"> The circle to be drawn</param>
            <param name="color"> The color of the circle </param>
            <param name="thickness"> If thickness is less than 1, the circle is filled up </param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.IConvexPolygonF,`0,System.Int32)">
            <summary> Draw a convex polygon of the specific color and thickness </summary>
            <param name="polygon"> The convex polygon to be drawn</param>
            <param name="color"> The color of the convex polygon </param>
            <param name="thickness"> If thickness is less than 1, the triangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(System.String,System.Drawing.Point,Emgu.CV.CvEnum.FontFace,System.Double,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Boolean)">
            <summary>
            Draw the text using the specific font on the image
            </summary>
            <param name="message">The text message to be draw</param>
            <param name="fontFace">Font type.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="bottomLeft">The location of the bottom left corner of the font</param>
            <param name="color">The color of the text</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:Emgu.CV.Map`2.DrawPolyline(System.Drawing.PointF[],System.Boolean,`0,System.Int32)">
            <summary>
            Draw the polyline defined by the array of 2D points
            </summary>
            <param name="pts">the points that defines the poly line</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Map`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="T:Emgu.CV.Mat">
            <summary>
            The equivalent of cv::Mat
            </summary>
        </member>
        <member name="T:Emgu.CV.Mat.MatJsonConverter">
            <summary>
            Class used for Json Serialized the Mat class
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.MatJsonConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Emgu.CV.Mat.MatJsonConverter.Write(System.Text.Json.Utf8JsonWriter,Emgu.CV.Mat,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Mat.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Mat.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="P:Emgu.CV.Mat.Bytes">
            <summary>
            Gets or sets the data as byte array.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="M:Emgu.CV.Mat.CopyTo``1(``0[])">
            <summary>
            Copy data from this Mat to the managed array
            </summary>
            <typeparam name="T">The type of managed data array</typeparam>
            <param name="data">The managed array where data will be copied to.</param>
        </member>
        <member name="M:Emgu.CV.Mat.SetTo``1(``0[])">
            <summary>
            Copy data from managed array to this Mat
            </summary>
            <typeparam name="T">The type of managed data array</typeparam>
            <param name="data">The managed array where data will be copied from</param>
        </member>
        <member name="F:Emgu.CV.Mat._parent">
            <summary>
            An option parent object to keep reference to
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor">
            <summary>
            Create an empty cv::Mat
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Create a mat of the specific type.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Drawing.Size,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Create a mat of the specific type.
            </summary>
            <param name="size">Size of the Mat</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Mat header from existing data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Int32[],Emgu.CV.CvEnum.DepthType,System.IntPtr,System.IntPtr[])">
            <summary>
            Create multi-dimension mat using existing data.
            </summary>
            <param name="sizes">The sizes of each dimension</param>
            <param name="type">The type of data</param>
            <param name="data">The pointer to the unmanaged data</param>
            <param name="steps">The steps</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Drawing.Size,Emgu.CV.CvEnum.DepthType,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Mat header from existing data
            </summary>
            <param name="size">Size of the Mat</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.String,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            Load the Mat from file
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="loadType">File loading method</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(Emgu.CV.Mat,System.Drawing.Rectangle)">
            <summary>
            Create a mat header for the specific ROI
            </summary>
            <param name="mat">The mat where the new Mat header will share data from</param>
            <param name="roi">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(Emgu.CV.Mat,Emgu.CV.Structure.Range,Emgu.CV.Structure.Range)">
            <summary>
            Create a mat header for the specific ROI
            </summary>
            <param name="mat">The mat where the new Mat header will share data from</param>
            <param name="rowRange">The region of interest</param>
            <param name="colRange">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.Mat.GetUMat(Emgu.CV.CvEnum.AccessType,Emgu.CV.UMat.Usage)">
            <summary>
            Convert this Mat to UMat
            </summary>
            <param name="access">Access type</param>
            <param name="usageFlags">Usage flags</param>
            <returns>The UMat</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Create(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="rows">New number of rows.</param>
            <param name="cols">New number of columns.</param>
            <param name="type">New matrix element depth type.</param>
            <param name="channels">New matrix number of channels</param>
        </member>
        <member name="P:Emgu.CV.Mat.Size">
            <summary>
            The size of this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Rows">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Cols">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.DataPointer">
            <summary>
            Pointer to the beginning of the raw data
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetDataPointer(System.Int32[])">
            <summary>
            Get a pointer to the raw data given the specific index
            </summary>
            <param name="index">The index to the Mat data</param>
            <returns>A pointer to the raw data given the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Mat.GetData(System.Boolean)">
            <summary>
            Get a copy of the data values as an array
            </summary>
            <param name="jagged">If true, a jagged array will returned. Otherwise it will return a regular array.</param>
            <returns>a copy of the data values as an array</returns>
        </member>
        <member name="M:Emgu.CV.Mat.GetRawData(System.Int32[])">
            <summary>
            Gets the binary data from the specific indices.
            </summary>
            <param name="indices">The indices.</param>
            <returns>The raw data in byte</returns>
            <exception cref="T:System.NotImplementedException">Indices of length more than 2 is not implemented</exception>
        </member>
        <member name="P:Emgu.CV.Mat.Step">
            <summary>
            Step
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.ElementSize">
            <summary>
            The size of the elements in this matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Copy the data in this cv::Mat to an output array
            </summary>
            <param name="m">The output array to copy to</param>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
        </member>
        <member name="M:Emgu.CV.Mat.ConvertTo(Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Double,System.Double)">
            <summary>
            Converts an array to another data type with optional scaling.
            </summary>
            <param name="m">Output matrix; if it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="rtype">Desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input.</param>
            <param name="alpha">Optional scale factor.</param>
            <param name="beta">Optional delta added to the scaled values.</param>
        </member>
        <member name="M:Emgu.CV.Mat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns>A new mat header that has different shape</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Reshape(System.Int32,System.Int32[])">
            <summary>
            Changes the shape and/or the number of channels of a matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="newDims">Array with new matrix size by all dimensions. If some sizes are zero, the original sizes in those dimensions are presumed.</param>
            <returns>A new mat header that has different shape</returns>
        </member>
        <member name="M:Emgu.CV.Mat.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetInputArray">
            <summary>
            Pointer to the InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Mat.GetOutputArray">
            <summary>
            Pointer to the OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Mat.GetInputOutputArray">
            <summary>
            Pointer to the InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Mat.Width">
            <summary>
            Get the width of the mat
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Height">
            <summary>
            Get the height of the mat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetValueRange">
            <summary>
            Get the minimum and maximum value across all channels of the mat
            </summary>
            <returns>The range that contains the minimum and maximum values</returns>
        </member>
        <member name="M:Emgu.CV.Mat.ToImage``2(System.Boolean)">
            <summary>
            Convert this Mat to Image
            </summary>
            <typeparam name="TColor">The type of Color</typeparam>
            <typeparam name="TDepth">The type of Depth</typeparam>
            <param name="tryShareData">If true, we will try to see if we can create an Image object that shared the pixel memory with this Mat.</param>
            <returns>The image</returns>
        </member>
        <member name="M:Emgu.CV.Mat.SetTo(Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray)">
            <summary>
            Set the mat to the specific value
            </summary>
            <param name="value">The value to set to</param>
            <param name="mask">Optional mask</param>
        </member>
        <member name="M:Emgu.CV.Mat.SetTo(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Set the mat to the specific value
            </summary>
            <param name="value">The value to set to</param>
            <param name="mask">Optional mask</param>
        </member>
        <member name="M:Emgu.CV.Mat.Eye(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Returns an identity matrix of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <returns>An identity matrix of the specified size and type.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Diag(System.Int32)">
            <summary>
            Extracts a diagonal from a matrix. The method makes a new header for the specified matrix diagonal. The new matrix is represented as a single-column matrix. Similarly to Mat::row and Mat::col, this is an O(1) operation.
            </summary>
            <param name="d">Index of the diagonal, with the following values: d=0 is the main diagonal; d &lt; 0 is a diagonal from the lower half. For example, d=-1 means the diagonal is set immediately below the main one; d &gt; 0 is a diagonal from the upper half. For example, d=1 means the diagonal is set immediately above the main one.</param>
            <returns>A diagonal from a matrix</returns>
        </member>
        <member name="M:Emgu.CV.Mat.T">
            <summary>
            Transposes a matrix.
            </summary>
            <returns>The transposes of the matrix.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Zeros(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <returns>A zero array of the specified size and type.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Ones(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Returns an array of all 1's of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <returns>An array of all 1's of the specified size and type.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.Mat.Row(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row.
            </summary>
            <param name="y">A 0-based row index.</param>
            <returns>A matrix header for the specified matrix row.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Col(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns>A matrix header for the specified matrix column.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Save(System.String)">
            <summary>
            Save this image to the specific file. 
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
            <remarks>The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format.</remarks>
        </member>
        <member name="M:Emgu.CV.Mat.Clone">
            <summary>
            Make a clone of the current Mat
            </summary>
            <returns>A clone of the current Mat</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.Mat.Equals(Emgu.CV.Mat)">
            <summary>
            Compares two Mats and check if they are equal
            </summary>
            <param name="other">The other mat to compare with</param>
            <returns>True if the two Mats are equal</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Dot(Emgu.CV.IInputArray)">
            <summary>
            Computes a dot-product of two vectors.
            </summary>
            <param name="m">Another dot-product operand</param>
            <returns>The dot-product of two vectors.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Cross(Emgu.CV.IInputArray)">
            <summary>
            Computes a cross-product of two 3-element vectors.
            </summary>
            <param name="m">Another cross-product operand.</param>
            <returns>Cross-product of two 3-element vectors.</returns>
        </member>
        <member name="P:Emgu.CV.Mat.SizeOfDimension">
            <summary>
            Get an array of the size of the dimensions. e.g. if the mat is 9x10x11, the array of {9, 10, 11} will be returned.
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetSpan``1(System.Int32)">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <param name="size">The size of the Span. If it is less than or equals to 0, the full span is used.</param>
            <typeparam name="T">The type of the elements in the span.</typeparam>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseAnd(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Perform an element wise AND operation on the two mats
            </summary>
            <param name="mat1">The first mat to AND</param>
            <param name="mat2">The second mat to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseAnd(Emgu.CV.Mat,System.Double)">
            <summary>
            Perform an element wise AND operation using a mat and a scalar
            </summary>
            <param name="mat1">The first image to AND</param>
            <param name="val">The value to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseAnd(System.Double,Emgu.CV.Mat)">
            <summary>
            Perform an element wise AND operation using a mat and a color
            </summary>
            <param name="mat1">The first mat to AND</param>
            <param name="val">The value to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseAnd(Emgu.CV.Mat,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Perform an element wise AND operation using a mat and a scalar
            </summary>
            <param name="mat1">The first mat to AND</param>
            <param name="val">The value to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseAnd(Emgu.CV.Structure.MCvScalar,Emgu.CV.Mat)">
            <summary>
            Perform an element wise AND operation using a mat and a scalar
            </summary>
            <param name="mat1">The first mat to AND</param>
            <param name="val">The scalar to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseOr(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary> Perform an element wise OR operation with another mat and return the result</summary>
            <param name="mat1">The first mat to apply bitwise OR operation</param>
            <param name="mat2">The second mat to apply bitwise OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseOr(Emgu.CV.Mat,System.Double)">
            <summary> 
            Perform an binary OR operation with some value
            </summary>
            <param name="mat1">The mat to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseOr(System.Double,Emgu.CV.Mat)">
            <summary> 
            Perform an binary OR operation with some color
            </summary>
            <param name="mat1">The mat to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseOr(Emgu.CV.Mat,Emgu.CV.Structure.MCvScalar)">
            <summary> 
            Perform an binary OR operation with some scalar
            </summary>
            <param name="mat1">The mat to OR</param>
            <param name="val"> The value to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_BitwiseOr(Emgu.CV.Structure.MCvScalar,Emgu.CV.Mat)">
            <summary> 
            Perform an binary OR operation with some scalar
            </summary>
            <param name="mat1">The mat to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_OnesComplement(Emgu.CV.Mat)">
            <summary>Compute the complement Mat</summary>
            <param name="mat">The mat to be inverted</param>
            <returns>The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Addition(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Element wise add <paramref name="mat1"/> with <paramref name="mat2"/>
            </summary>
            <param name="mat1">The first image to be added</param>
            <param name="mat2">The second image to be added</param>
            <returns>The sum of the two images</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Addition(System.Double,Emgu.CV.Mat)">
            <summary>
            Element wise add <paramref name="mat1"/> with <paramref name="value"/>
            </summary>
            <param name="mat1">The mat to be added</param>
            <param name="value">The value to be added</param>
            <returns>The mat plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Addition(Emgu.CV.Mat,System.Double)">
            <summary>
            Element wise add <paramref name="mat"/> with <paramref name="value"/>
            </summary>
            <param name="mat">The mat to be added</param>
            <param name="value">The value to be added</param>
            <returns>The images plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Addition(Emgu.CV.Mat,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Element wise add <paramref name="mat"/> with <paramref name="value"/>
            </summary>
            <param name="mat">The mat to be added</param>
            <param name="value">The value to be added</param>
            <returns>The mat plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Addition(Emgu.CV.Structure.MCvScalar,Emgu.CV.Mat)">
            <summary>
            Element wise add <paramref name="mat"/> with <paramref name="value"/>
            </summary>
            <param name="mat">The mat to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Subtraction(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Element wise subtract another mat from the current mat
            </summary>
            <param name="mat1">The mat to be subtracted from.</param>
            <param name="mat2">The second image to be subtracted from <paramref name="mat1"/></param>
            <returns> The result of element wise subtracting img2 from <paramref name="mat1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Subtraction(Emgu.CV.Mat,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Element wise subtract another mat from the current mat
            </summary>
            <param name="mat">The mat to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> The result of element wise subtracting <paramref name="value"/> from <paramref name="mat"/> </returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Subtraction(Emgu.CV.Structure.MCvScalar,Emgu.CV.Mat)">
            <summary>
            Element wise subtract value from the current mat
            </summary>
            <param name="mat">The mat to be subtracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> <paramref name="value"/> - <paramref name="mat"/> </returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Subtraction(System.Double,Emgu.CV.Mat)">
            <summary>
            <paramref name="value"/> - <paramref name="mat"/>
            </summary>
            <param name="mat">The mat to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramref name="value"/> - <paramref name="mat"/> </returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Subtraction(Emgu.CV.Mat,System.Double)">
            <summary>
            Element wise subtract value from the current mat
            </summary>
            <param name="mat">The mat to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramref name="mat"/> - <paramref name="value"/>   </returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Multiply(Emgu.CV.Mat,System.Double)">
            <summary>
             <paramref name="mat"/> * <paramref name="scale"/>
            </summary>
            <param name="mat">The mat</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="mat"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Multiply(System.Double,Emgu.CV.Mat)">
            <summary>
              <paramref name="scale"/>*<paramref name="mat"/>
            </summary>
            <param name="mat">The mat</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="scale"/>*<paramref name="mat"/></returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Division(Emgu.CV.Mat,System.Double)">
            <summary>
             <paramref name="mat"/> / <paramref name="scale"/>
            </summary>
            <param name="mat">The mat</param>
            <param name="scale">The division scale</param>
            <returns><paramref name="mat"/> / <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Mat.op_Division(System.Double,Emgu.CV.Mat)">
            <summary>
              <paramref name="scale"/> / <paramref name="mat"/>
            </summary>
            <param name="mat">The mat</param>
            <param name="scale">The scale</param>
            <returns><paramref name="scale"/> / <paramref name="mat"/></returns>
        </member>
        <member name="P:Emgu.CV.Mat.IsContinuous">
            <summary>
            True if the data is continues
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.IsSubmatrix">
            <summary>
            True if the matrix is a submatrix of another matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Depth">
            <summary>
            Depth type
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.IsEmpty">
            <summary>
            True if the Mat is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.NumberOfChannels">
            <summary>
            Number of channels
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.PopBack(System.Int32)">
            <summary>
            The method removes one or more rows from the bottom of the matrix
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.CV.Mat.PushBack(Emgu.CV.Mat)">
            <summary>
            Adds elements to the bottom of the matrix
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="P:Emgu.CV.Mat.Total">
            <summary>
            The method returns the number of array elements (a number of pixels if the array represents an image)
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Dims">
            <summary>
            The matrix dimensionality
            </summary>
        </member>
        <member name="T:Emgu.CV.MatND`1">
            <summary>
            A MatND is a wrapper to cvMatND of OpenCV. 
            </summary>
            <typeparam name="TDepth">The type of depth</typeparam>
        </member>
        <member name="M:Emgu.CV.MatND`1.#ctor(System.Int32[])">
            <summary>
            Create a N-dimensional matrix 
            </summary>
            <param name="sizes">The size for each dimension</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            This function is not implemented for MatND
            </summary>
            <param name="rows">Not implemented</param>
            <param name="cols">Not implemented</param>
            <param name="numberOfChannels">Not implemented</param>
        </member>
        <member name="P:Emgu.CV.MatND`1.NumberOfChannels">
            <summary>
            This function is not implemented for MatND
            </summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.CvDepth">
            <summary>
            Get the depth representation for Open CV
            </summary>
        </member>
        <member name="M:Emgu.CV.MatND`1.DisposeObject">
            <summary>
            Release the matrix and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.MatND`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.ReadXml(System.Xml.XmlReader)">
            <summary>
            Not Implemented
            </summary>
            <param name="reader">The XmlReader</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Not Implemented
            </summary>
            <param name="writer">The XmlWriter</param>
        </member>
        <member name="P:Emgu.CV.MatND`1.MCvMatND">
            <summary>
            The MCvMatND structure
            </summary>
        </member>
        <member name="M:Emgu.CV.MatND`1.Convert``1">
            <summary>
            Convert this matrix to different depth
            </summary>
            <typeparam name="TOtherDepth">The depth type to convert to</typeparam>
            <returns>Matrix of different depth</returns>
        </member>
        <member name="M:Emgu.CV.MatND`1.Equals(Emgu.CV.MatND{`0})">
            <summary>
            Check if the two MatND are equal
            </summary>
            <param name="other">The other MatND to compares to</param>
            <returns>True if the two MatND equals</returns>
        </member>
        <member name="T:Emgu.CV.Matrix`1">
            <summary> 
            A Matrix is a wrapper to cvMat of OpenCV. 
            </summary>
            <typeparam name="TDepth">Depth of this matrix (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor">
            <summary>
            The default constructor which allows Data to be set later on
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <param name="step">The step (row stride in bytes)</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="channels">The number of channels</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <param name="step">The step (row stride in bytes)</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a matrix of the specific size
            </summary>
            <param name="rows">The number of rows (<b>height</b>)</param>
            <param name="cols">The number of cols (<b>width</b>)</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Drawing.Size)">
            <summary>
            Create a matrix of the specific size
            </summary>
            <param name="size">The size of the matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a matrix of the specific size and channels
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="channels">The number of channels</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(`0[0:,0:])">
            <summary> 
            Create a matrix using the specific data. 
            </summary>
            <param name="data">The data will be used as the Matrix data storage. You need to make sure that the data object live as long as this Matrix object</param>
            <remarks>The data will be used as the Matrix data storage. You need to make sure that the data object live as long as this Matrix object</remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(`0[])">
            <summary>
            Create a matrix using the specific <paramref name="data"/>
            </summary>
            <param name="data">the data for this matrix</param>
        </member>
        <member name="P:Emgu.CV.Matrix`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Data">
            <summary>
            Get or Set the data for this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.NumberOfChannels">
            <summary>
            Get the number of channels for this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.MCvMat">
            <summary>
            The MCvMat structure format  
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Det">
            <summary>
            Returns determinant of the square matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Sum">
            <summary>
            Return the sum of the elements in this matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.CopyBlank">
            <summary>
            Return a matrix of the same size with all elements equals 0
            </summary>
            <returns>A matrix of the same size with all elements equals 0</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Clone">
            <summary>
            Make a copy of this matrix
            </summary>
            <returns>A copy if this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Reshape(System.Int32,System.Int32)">
            <summary>
            Get reshaped matrix which also share the same data with the current matrix
            </summary>
            <param name="newChannels">the new number of channles</param>
            <param name="newRows">The new number of rows</param>
            <returns>A reshaped matrix which also share the same data with the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Convert``1(System.Double,System.Double)">
            <summary>
            Convert this matrix to different depth
            </summary>
            <typeparam name="TOtherDepth">The depth type to convert to</typeparam>
            <param name="scale">the scaling factor to apply during conversion (defaults to 1.0 -- no scaling)</param>
            <param name="shift">the shift factor to apply during conversion (defaults to 0.0 -- no shifting)</param>
            <returns>Matrix of different depth</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Transpose">
            <summary> Returns the transpose of this matrix</summary>
            <returns>The transpose of this matrix</returns>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the value in the specific <paramref name="row"/> and <paramref name="col"/>
            </summary>
            <param name="row">the row of the element</param>
            <param name="col">the col of the element</param>
            <returns>The element on the specific <paramref name="row"/> and <paramref name="col"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels for this matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Get a submatrix corresponding to a specified rectangle
            </summary>
            <param name="rect">the rectangle area of the sub-matrix</param>
            <returns>A submatrix corresponding to a specified rectangle</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetRow(System.Int32)">
            <summary>
            Get the specific row of the matrix
            </summary>
            <param name="row">the index of the row to be reterived</param>
            <returns>the specific row of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetRows(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the matrix corresponding to a specified row span of the input array
            </summary>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <param name="deltaRow">Index step in the row span. That is, the function extracts every delta_row-th row from start_row and up to (but not including) end_row</param>
            <returns>A matrix corresponding to a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetCol(System.Int32)">
            <summary>
            Get the specific column of the matrix
            </summary>
            <param name="col">the index of the column to be reterived</param>
            <returns>the specific column of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetCols(System.Int32,System.Int32)">
            <summary>
            Get the Matrix, corresponding to a specified column span of the input array
            </summary>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <param name="startCol">Zero-based index of the selected column</param>
            <returns>the specific column span of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetDiag(System.Int32)">
            <summary>
            Return the specific diagonal elements of this matrix
            </summary>
            <param name="diag">Array diagonal. Zero corresponds to the main diagonal, -1 corresponds to the diagonal above the main etc., 1 corresponds to the diagonal below the main etc</param>
            <returns>The specific diagonal elements of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetDiag">
            <summary>
            Return the main diagonal element of this matrix
            </summary>
            <returns>The main diagonal element of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.RemoveRows(System.Int32,System.Int32)">
            <summary>
            Return the matrix without a specified row span of the input array
            </summary>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <returns>The matrix without a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.RemoveCols(System.Int32,System.Int32)">
            <summary>
            Return the matrix without a specified column span of the input array
            </summary>
            <param name="startCol">Zero-based index of the starting column (inclusive) of the span</param>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <returns>The matrix without a specified column span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.ConcateVertical(Emgu.CV.Matrix{`0})">
            <summary>
            Concate the current matrix with another matrix vertically. If this matrix is n1 x m and <paramref name="otherMatrix"/> is n2 x m, the resulting matrix is (n1+n2) x m.
            </summary>
            <param name="otherMatrix">The other matrix to concate</param>
            <returns>A new matrix that is the vertical concatening of this matrix and <paramref name="otherMatrix"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.ConcateHorizontal(Emgu.CV.Matrix{`0})">
            <summary>
            Concate the current matrix with another matrix horizontally. If this matrix is n x m1 and <paramref name="otherMatrix"/> is n x m2, the resulting matrix is n x (m1 + m2).
            </summary>
            <param name="otherMatrix">The other matrix to concate</param>
            <returns>A matrix that is the horizontal concatening of this matrix and <paramref name="otherMatrix"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.MinMax(System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,Emgu.CV.IInputArray)">
            <summary>
            Returns the min / max locations and values for the matrix
            </summary>
            <param name="minValue">The minimum value</param>
            <param name="maxValue">The maximum value</param>
            <param name="minLocation">The minimum location</param>
            <param name="maxLocation">The maximum location</param>
            <param name="mask">The optional mask</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Add(Emgu.CV.Matrix{`0})">
            <summary> Elementwise add another matrix with the current matrix </summary>
            <param name="mat2">The matrix to be added to the current matrix</param>
            <returns> The result of elementwise adding mat2 to the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Add(`0)">
            <summary> Elementwise add a color <paramref name="val"/> to the current matrix</summary>
            <param name="val">The value to be added to the current matrix</param>
            <returns> The result of elementwise adding <paramref name="val"/> from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Sub(Emgu.CV.Matrix{`0})">
            <summary> Elementwise subtract another matrix from the current matrix </summary>
            <param name="mat2"> The matrix to be subtracted to the current matrix</param>
            <returns> The result of elementwise subtracting mat2 from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Sub(`0)">
            <summary> Elementwise subtract a color <paramref name="val"/> to the current matrix</summary>
            <param name="val"> The value to be subtracted from the current matrix</param>
            <returns> The result of elementwise subtracting <paramref name="val"/> from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.SubR(`0)">
            <summary>
            result = val - this
            </summary>
            <param name="val">The value which subtract this matrix</param>
            <returns>val - this</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Mul(System.Double)">
            <summary> Multiply the current matrix with <paramref name="scale"/></summary>
            <param name="scale">The scale to be multiplied</param>
            <returns> The scaled matrix </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Mul(Emgu.CV.Matrix{`0})">
            <summary> Multiply the current matrix with <paramref name="mat2"/></summary>
            <param name="mat2">The matrix to be multiplied</param>
            <returns> Result matrix of the multiplication </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            Elementwise add <paramref name="mat1"/> with <paramref name="mat2"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="mat2">The Matrix to be added</param>
            <returns>The elementwise sum of the two matrices</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            Elementwise add <paramref name="mat1"/> with <paramref name="val"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="val">The value to be added</param>
            <returns>The matrix plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="val"/> + <paramref name="mat1"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="val">The value to be added</param>
            <returns>The matrix plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="val"/> - <paramref name="mat1"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="val">The value to be subtracted</param>
            <returns><paramref name="val"/> - <paramref name="mat1"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="mat1"/> - <paramref name="mat2"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="mat2">The matrix to subtract</param>
            <returns><paramref name="mat1"/> - <paramref name="mat2"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> - <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="val">The value to be subtracted</param>
            <returns><paramref name="mat1"/> - <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> * <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be multiplied</param>
            <param name="val">The value to be multiplied</param>
            <returns><paramref name="mat1"/> * <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
             <paramref name="val"/> * <paramref name="mat1"/> 
            </summary>
            <param name="mat1">The matrix to be multiplied</param>
            <param name="val">The value to be multiplied</param>
            <returns> <paramref name="val"/> * <paramref name="mat1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Division(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> / <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be divided</param>
            <param name="val">The value to be divided</param>
            <returns><paramref name="mat1"/> / <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="mat1"/> * <paramref name="mat2"/> 
            </summary>
            <param name="mat1">The Matrix to be multiplied</param>
            <param name="mat2">The Matrix to be multiplied</param>
            <returns><paramref name="mat1"/> * <paramref name="mat2"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.DisposeObject">
            <summary>
            Release the matrix and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Cmp(Emgu.CV.Matrix{`0},Emgu.CV.CvEnum.CmpType)">
            <summary>
            This function compare the current matrix with <paramref name="mat2"/> and returns the comparison mask
            </summary>
            <param name="mat2">The other matrix to compare with</param>
            <param name="type">Comparison type</param>
            <returns>The comparison mask</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Split">
            <summary>
            Get all channels for the multi channel matrix
            </summary>
            <returns>Each individual channel of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Equals(Emgu.CV.Matrix{`0})">
            <summary>
            Return true if every element of this matrix equals elements in <paramref name="mat2"/>
            </summary>
            <param name="mat2">The other matrix to compare with</param>
            <returns>true if every element of this matrix equals elements in <paramref name="mat2"/></returns>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Size">
            <summary> 
            Get the size of the array
            </summary>
        </member>
        <member name="T:Emgu.CV.Moments">
            <summary>
            The equivalent of cv::Moments
            </summary>
        </member>
        <member name="M:Emgu.CV.Moments.#ctor">
            <summary>
            Create an empty Moment object
            </summary>
        </member>
        <member name="M:Emgu.CV.Moments.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.GravityCenter">
            <summary>
            The Gravity Center of this Moment
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M00">
            <summary>
            Spatial Moment M00
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M10">
            <summary>
            Spatial Moment M10
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M01">
            <summary>
            Spatial Moment M01
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M20">
            <summary>
            Spatial Moment M20
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M11">
            <summary>
            Spatial Moment M11
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M02">
            <summary>
            Spatial Moment M02
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M30">
            <summary>
            Spatial Moment M30
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M21">
            <summary>
            Spatial Moment M21
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M12">
            <summary>
            Spatial Moment M12
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.M03">
            <summary>
            Spatial Moment M03
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Mu20">
            <summary>
            Central Moment Mu20
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Mu11">
            <summary>
            Central Moment Mu11
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Mu02">
            <summary>
            Central Moment Mu02
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Mu30">
            <summary>
            Central Moment Mu30
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Mu21">
            <summary>
            Central Moment Mu21
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Mu12">
            <summary>
            Central Moment Mu12
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Mu03">
            <summary>
            Central Moment Mu03
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Nu20">
            <summary>
            Central Normalized Moment Nu20
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Nu11">
            <summary>
            Central Normalized Moment Nu11
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Nu02">
            <summary>
            Central Normalized Moment Nu02
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Nu30">
            <summary>
            Central Normalized Moment Nu30
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Nu21">
            <summary>
            Central Normalized Moment Nu21
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Nu12">
            <summary>
            Central Normalized Moment Nu12
            </summary>
        </member>
        <member name="P:Emgu.CV.Moments.Nu03">
            <summary>
            Central Normalized Moment Nu03
            </summary>
        </member>
        <member name="T:Emgu.CV.NativeMatFileIO">
            <summary>
            Native implementation to read files into Mat or Images.
            </summary>
        </member>
        <member name="M:Emgu.CV.NativeMatFileIO.ReadFileToMat(System.String,Emgu.CV.Mat,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            Read a file into Mat using native implementations
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="mat">The Mat to read the file into</param>
            <param name="loadType">The image load type.</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Emgu.CV.NativeMatFileIO.WriteMatToFile(Emgu.CV.Mat,System.String)">
            <summary>
            Write a Mat into a file using native implementations
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="mat">The Mat to be written</param>
            <returns>True if successful</returns>
        </member>
        <member name="T:Emgu.CV.OutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for output function parameters. 
            </summary>
        </member>
        <member name="M:Emgu.CV.OutputArray.#ctor(System.IntPtr,System.Object)">
            <summary>
            Create an OutputArray from an existing unmanaged outputArray pointer
            </summary>
            <param name="outputArrayPtr">The pointer to the unmanaged outputArray</param>
            <param name="parent">The parent object to keep reference to</param>
        </member>
        <member name="M:Emgu.CV.OutputArray.GetEmpty">
            <summary>
            Get an empty output array
            </summary>
            <returns>An empty output array</returns>
        </member>
        <member name="M:Emgu.CV.OutputArray.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this output array.
            </summary>
        </member>
        <member name="P:Emgu.CV.OutputArray.FixedSize">
            <summary>
            True if the output array is fixed size
            </summary>
        </member>
        <member name="P:Emgu.CV.OutputArray.FixedType">
            <summary>
            True if the output array is fixed type
            </summary>
        </member>
        <member name="P:Emgu.CV.OutputArray.Needed">
            <summary>
            True if the output array is needed
            </summary>
        </member>
        <member name="T:Emgu.CV.RNG">
            <summary>
            Random Number Generator.
            </summary>
        </member>
        <member name="T:Emgu.CV.RNG.DistType">
            <summary>
            Distribution type
            </summary>
        </member>
        <member name="F:Emgu.CV.RNG.DistType.Uniform">
            <summary>
            Uniform distribution
            </summary>
        </member>
        <member name="F:Emgu.CV.RNG.DistType.Normal">
            <summary>
            Normal distribution
            </summary>
        </member>
        <member name="M:Emgu.CV.RNG.#ctor">
            <summary>
            Create a Random Number Generator.
            </summary>
        </member>
        <member name="M:Emgu.CV.RNG.#ctor(System.UInt64)">
            <summary>
            Create a Random Number Generator using a seed.
            </summary>
            <param name="state">64-bit value used to initialize the RNG</param>
        </member>
        <member name="M:Emgu.CV.RNG.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.CV.RNG.Fill(Emgu.CV.IInputOutputArray,Emgu.CV.RNG.DistType,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Fills arrays with random numbers.
            </summary>
            <param name="mat">2D or N-dimensional matrix; currently matrices with more than 4 channels are not supported by the methods, use Mat::reshape as a possible workaround.</param>
            <param name="distType">distribution type</param>
            <param name="a">First distribution parameter; in case of the uniform distribution, this is an inclusive lower boundary, in case of the normal distribution, this is a mean value.</param>
            <param name="b">Second distribution parameter; in case of the uniform distribution, this is a non-inclusive upper boundary, in case of the normal distribution, this is a standard deviation (diagonal of the standard deviation matrix or the full standard deviation matrix).</param>
            <param name="saturateRange">Pre-saturation flag; for uniform distribution only; if true, the method will first convert a and b to the acceptable value range (according to the mat datatype) and then will generate uniformly distributed random numbers within the range [saturate(a), saturate(b)), if saturateRange=false, the method will generate uniformly distributed random numbers in the original range [a, b) and then will saturate them</param>
        </member>
        <member name="M:Emgu.CV.RNG.Fill(Emgu.CV.IInputOutputArray,Emgu.CV.RNG.DistType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,System.Boolean)">
            <summary>
            Fills arrays with random numbers.
            </summary>
            <param name="mat">2D or N-dimensional matrix; currently matrices with more than 4 channels are not supported by the methods, use Mat::reshape as a possible workaround.</param>
            <param name="distType">distribution type</param>
            <param name="a">First distribution parameter; in case of the uniform distribution, this is an inclusive lower boundary, in case of the normal distribution, this is a mean value.</param>
            <param name="b">Second distribution parameter; in case of the uniform distribution, this is a non-inclusive upper boundary, in case of the normal distribution, this is a standard deviation (diagonal of the standard deviation matrix or the full standard deviation matrix).</param>
            <param name="saturateRange">Pre-saturation flag; for uniform distribution only; if true, the method will first convert a and b to the acceptable value range (according to the mat datatype) and then will generate uniformly distributed random numbers within the range [saturate(a), saturate(b)), if saturateRange=false, the method will generate uniformly distributed random numbers in the original range [a, b) and then will saturate them</param>
        </member>
        <member name="M:Emgu.CV.RNG.Gaussian(System.Double)">
            <summary>
            Returns the next random number sampled from the Gaussian distribution.
            </summary>
            <param name="sigma">standard deviation of the distribution.</param>
            <returns>Returns the next random number from the Gaussian distribution N(0,sigma) . That is, the mean value of the returned random numbers is zero and the standard deviation is the specified sigma .</returns>
        </member>
        <member name="M:Emgu.CV.RNG.Next">
            <summary>
            The method updates the state using the MWC algorithm and returns the next 32-bit random number.
            </summary>
            <returns>The next 32-bit random number</returns>
        </member>
        <member name="M:Emgu.CV.RNG.Uniform(System.Int32,System.Int32)">
            <summary>
            Returns uniformly distributed integer random number from [a,b) range
            </summary>
            <param name="a">Lower inclusive boundary of the returned random number.</param>
            <param name="b">Upper non-inclusive boundary of the returned random number.</param>
            <returns>Uniformly distributed integer random number from [a,b) range</returns>
        </member>
        <member name="M:Emgu.CV.RNG.Uniform(System.Single,System.Single)">
            <summary>
            Returns uniformly distributed random float number from [a,b) range
            </summary>
            <param name="a">Lower inclusive boundary of the returned random number.</param>
            <param name="b">Upper non-inclusive boundary of the returned random number.</param>
            <returns>Uniformly distributed random float number from [a,b) range</returns>
        </member>
        <member name="M:Emgu.CV.RNG.Uniform(System.Double,System.Double)">
            <summary>
            Returns uniformly distributed random double number from [a,b) range
            </summary>
            <param name="a">Lower inclusive boundary of the returned random number.</param>
            <param name="b">Upper non-inclusive boundary of the returned random number.</param>
            <returns>Uniformly distributed random double number from [a,b) range</returns>
        </member>
        <member name="T:Emgu.CV.ScalarArray">
            <summary>
            An implementation of IInputArray intented to convert data to IInputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.ScalarArray.#ctor(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create an InputArray from MCvScalar
            </summary>
            <param name="scalar">The MCvScalar to be converted to InputArray</param>
        </member>
        <member name="M:Emgu.CV.ScalarArray.#ctor(System.Double)">
            <summary>
            Create an InputArray from a double value
            </summary>
            <param name="scalar">The double value to be converted to InputArray</param>
        </member>
        <member name="M:Emgu.CV.ScalarArray.op_Explicit(System.Double)~Emgu.CV.ScalarArray">
            <summary>
            Convert double scalar to InputArray
            </summary>
            <param name="scalar">The double scalar</param>
            <returns>The InputArray</returns>
        </member>
        <member name="M:Emgu.CV.ScalarArray.op_Explicit(Emgu.CV.Structure.MCvScalar)~Emgu.CV.ScalarArray">
            <summary>
            Convert MCvScalar to InputArray
            </summary>
            <param name="scalar">The MCvScalar</param>
            <returns>The InputArray</returns>
        </member>
        <member name="M:Emgu.CV.ScalarArray.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.ScalarArray.GetInputArray">
            <summary>
            The pointer to the input array
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="T:Emgu.CV.SparseMatrix`1">
            <summary>
            Create a sparse matrix
            </summary>
            <typeparam name="TDepth">The type of elements in this matrix</typeparam>
        </member>
        <member name="M:Emgu.CV.SparseMatrix`1.#ctor(System.Int32[])">
            <summary>
            Create a sparse matrix of the specific dimension
            </summary>
            <param name="dimension">The dimension of the sparse matrix</param>
        </member>
        <member name="P:Emgu.CV.SparseMatrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the value in the specific <paramref name="row"/> and <paramref name="col"/>
            </summary>
            <param name="row">the row of the element</param>
            <param name="col">the col of the element</param>
            <returns>The element on the specific <paramref name="row"/> and <paramref name="col"/></returns>
        </member>
        <member name="M:Emgu.CV.SparseMatrix`1.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this sparse matrix
            </summary>
        </member>
        <member name="T:Emgu.CV.TimedImage`2">
            <summary> 
            The Image which contains time stamp which specified what time this image is created 
            </summary>
            <typeparam name="TColor">The color of this map</typeparam>
            <typeparam name="TDepth">The depth of this map</typeparam>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor">
            <summary>
            Create a empty Image 
            </summary>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height, depth and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an empty Image of the specified width and height
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="P:Emgu.CV.TimedImage`2.Timestamp">
            <summary> 
            The time this image is captured
            </summary>
        </member>
        <member name="T:Emgu.CV.UMat">
            <summary>
            The equivalent of cv::Mat, should only be used if you know what you are doing.
            In most case you should use the Matrix class instead
            </summary>
        </member>
        <member name="T:Emgu.CV.UMat.UMatJsonConverter">
            <summary>
            Class used for Json Serialized the Mat class
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.UMatJsonConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Emgu.CV.UMat.UMatJsonConverter.Write(System.Text.Json.Utf8JsonWriter,Emgu.CV.UMat,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.UMat.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.UMat.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="T:Emgu.CV.UMat.Usage">
            <summary>
            Allocation usage.
            </summary>
        </member>
        <member name="F:Emgu.CV.UMat.Usage.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Emgu.CV.UMat.Usage.AllocateHostMemory">
            <summary>
            Buffer allocation policy is platform and usage specific 
            </summary>
        </member>
        <member name="F:Emgu.CV.UMat.Usage.AllocateDeviceMemory">
            <summary>
            Buffer allocation policy is platform and usage specific 
            </summary>
        </member>
        <member name="F:Emgu.CV.UMat.Usage.AllocateSharedMemory">
            <summary>
            Buffer allocation policy is platform and usage specific 
            It is not equal to: AllocateHostMemory | AllocateDeviceMemory
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Bytes">
            <summary>
            Get or Set the raw image data
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(Emgu.CV.UMat.Usage)">
            <summary>
            Create an empty cv::UMat
            </summary>
            <param name="usage">Allocation Usage</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.UMat.Usage)">
            <summary>
            Create a umat of the specific type.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <param name="usage">Allocation Usage</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(System.Drawing.Size,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.UMat.Usage)">
            <summary>
            Create a umat of the specific type.
            </summary>
            <param name="size">Size of the UMat</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <param name="usage">Allocation Usage</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(Emgu.CV.UMat,System.Drawing.Rectangle)">
            <summary>
            Get the Umat header for the specific roi of the parent
            </summary>
            <param name="parent">The parent Umat</param>
            <param name="roi">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(Emgu.CV.UMat,Emgu.CV.Structure.Range,Emgu.CV.Structure.Range)">
            <summary>
            Create a umat header for the specific ROI
            </summary>
            <param name="umat">The umat where the new UMat header will share data from</param>
            <param name="rowRange">The region of interest</param>
            <param name="colRange">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.UMat.Create(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.UMat.Usage)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="rows">New number of rows.</param>
            <param name="cols">New number of columns.</param>
            <param name="type">New matrix element depth type.</param>
            <param name="channels">New matrix number of channels</param>
            <param name="usage">Allocation Usage</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(System.String,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            Read a UMat from file.
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="loadType">The read mode</param>
        </member>
        <member name="P:Emgu.CV.UMat.Size">
            <summary>
            The size of this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Rows">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Cols">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.ElementSize">
            <summary>
            The size of the elements in this matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Copy the data in this umat to the other mat
            </summary>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
            <param name="m">The input array to copy to</param>
        </member>
        <member name="M:Emgu.CV.UMat.SetTo(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value">Assigned scalar converted to the actual array type.</param>
            <param name="mask">Operation mask of the same size as the umat.</param>
        </member>
        <member name="M:Emgu.CV.UMat.SetTo(Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value">Assigned scalar value.</param>
            <param name="mask">Operation mask of the same size as the umat.</param>
        </member>
        <member name="M:Emgu.CV.UMat.GetMat(Emgu.CV.CvEnum.AccessType)">
            <summary>
            Return the Mat representation of the UMat
            </summary>
            <param name="access">The access type</param>
            <returns>The Mat representation of the UMat</returns>
        </member>
        <member name="M:Emgu.CV.UMat.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.GetInputArray">
            <summary>
            Pointer to the InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.UMat.GetOutputArray">
            <summary>
            Pointer to the OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.UMat.GetInputOutputArray">
            <summary>
            Pointer to the InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="M:Emgu.CV.UMat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns>A new mat header that has different shape</returns>
        </member>
        <member name="M:Emgu.CV.UMat.ToImage``2">
            <summary>
            Convert this Mat to Image
            </summary>
            <typeparam name="TColor">The type of Color</typeparam>
            <typeparam name="TDepth">The type of Depth</typeparam>
            <returns>The image</returns>
        </member>
        <member name="M:Emgu.CV.UMat.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.UMat.ConvertTo(Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Double,System.Double)">
            <summary>
            Converts an array to another data type with optional scaling.
            </summary>
            <param name="m">Output matrix; if it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="rtype">Desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input.</param>
            <param name="alpha">Optional scale factor.</param>
            <param name="beta">Optional delta added to the scaled values.</param>
        </member>
        <member name="M:Emgu.CV.UMat.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.UMat.Save(System.String)">
            <summary>
            Save this image to the specific file. 
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
            <remarks>The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format.</remarks>
        </member>
        <member name="M:Emgu.CV.UMat.Clone">
            <summary>
            Make a clone of the current UMat.
            </summary>
            <returns>A clone of the current UMat.</returns>
        </member>
        <member name="M:Emgu.CV.UMat.Equals(Emgu.CV.UMat)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Emgu.CV.UMat.CopyTo``1(``0[])">
            <summary>
            Copy data from this Mat to the managed array
            </summary>
            <typeparam name="T">The type of managed data array</typeparam>
            <param name="data">The managed array where data will be copied to.</param>
        </member>
        <member name="M:Emgu.CV.UMat.SetTo``1(``0[])">
            <summary>
            Copy data from managed array to this Mat
            </summary>
            <typeparam name="T">The type of managed data array</typeparam>
            <param name="data">The managed array where data will be copied from</param>
        </member>
        <member name="M:Emgu.CV.UMat.Dot(Emgu.CV.IInputArray)">
            <summary>
            Computes the dot product of two mats
            </summary>
            <param name="mat">The matrix to compute dot product with</param>
            <returns>The dot product</returns>
        </member>
        <member name="M:Emgu.CV.UMat.Row(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row.
            </summary>
            <param name="y">A 0-based row index.</param>
            <returns>A matrix header for the specified matrix row.</returns>
        </member>
        <member name="M:Emgu.CV.UMat.Col(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns>A matrix header for the specified matrix column.</returns>
        </member>
        <member name="M:Emgu.CV.UMat.GetData(System.Boolean)">
            <summary>
            Get a copy of the data values as an array
            </summary>
            <param name="jagged">If true, a jagged array will returned. Otherwise it will return a regular array.</param>
            <returns>a copy of the data values as an array</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseAnd(Emgu.CV.UMat,Emgu.CV.UMat)">
            <summary>
            Perform an element wise AND operation on the two mats
            </summary>
            <param name="mat1">The first mat to AND</param>
            <param name="mat2">The second mat to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseAnd(Emgu.CV.UMat,System.Double)">
            <summary>
            Perform an element wise AND operation using a mat and a scalar
            </summary>
            <param name="mat1">The first image to AND</param>
            <param name="val">The value to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseAnd(System.Double,Emgu.CV.UMat)">
            <summary>
            Perform an element wise AND operation using a mat and a color
            </summary>
            <param name="mat1">The first mat to AND</param>
            <param name="val">The value to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseAnd(Emgu.CV.UMat,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Perform an element wise AND operation using a mat and a scalar
            </summary>
            <param name="mat1">The first mat to AND</param>
            <param name="val">The value to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseAnd(Emgu.CV.Structure.MCvScalar,Emgu.CV.UMat)">
            <summary>
            Perform an element wise AND operation using a mat and a scalar
            </summary>
            <param name="mat1">The first mat to AND</param>
            <param name="val">The scalar to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseOr(Emgu.CV.UMat,Emgu.CV.UMat)">
            <summary> Perform an element wise OR operation with another mat and return the result</summary>
            <param name="mat1">The first mat to apply bitwise OR operation</param>
            <param name="mat2">The second mat to apply bitwise OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseOr(Emgu.CV.UMat,System.Double)">
            <summary> 
            Perform an binary OR operation with some value
            </summary>
            <param name="mat1">The mat to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseOr(System.Double,Emgu.CV.UMat)">
            <summary> 
            Perform an binary OR operation with some color
            </summary>
            <param name="mat1">The mat to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseOr(Emgu.CV.UMat,Emgu.CV.Structure.MCvScalar)">
            <summary> 
            Perform an binary OR operation with some scalar
            </summary>
            <param name="mat1">The mat to OR</param>
            <param name="val"> The value to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_BitwiseOr(Emgu.CV.Structure.MCvScalar,Emgu.CV.UMat)">
            <summary> 
            Perform an binary OR operation with some scalar
            </summary>
            <param name="mat1">The mat to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_OnesComplement(Emgu.CV.UMat)">
            <summary>Compute the complement Mat</summary>
            <param name="mat">The mat to be inverted</param>
            <returns>The complement image</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Addition(Emgu.CV.UMat,Emgu.CV.UMat)">
            <summary>
            Element wise add <paramref name="mat1"/> with <paramref name="mat2"/>
            </summary>
            <param name="mat1">The first mat to be added</param>
            <param name="mat2">The second mat to be added</param>
            <returns>The sum of the two images</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Addition(System.Double,Emgu.CV.UMat)">
            <summary>
            Element wise add <paramref name="mat1"/> with <paramref name="value"/>
            </summary>
            <param name="mat1">The mat to be added</param>
            <param name="value">The value to be added</param>
            <returns>The mat plus the value</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Addition(Emgu.CV.UMat,System.Double)">
            <summary>
            Element wise add <paramref name="mat"/> with <paramref name="value"/>
            </summary>
            <param name="mat">The mat to be added</param>
            <param name="value">The value to be added</param>
            <returns>The images plus the value</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Addition(Emgu.CV.UMat,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Element wise add <paramref name="mat"/> with <paramref name="value"/>
            </summary>
            <param name="mat">The mat to be added</param>
            <param name="value">The value to be added</param>
            <returns>The mat plus the value</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Addition(Emgu.CV.Structure.MCvScalar,Emgu.CV.UMat)">
            <summary>
            Element wise add <paramref name="mat"/> with <paramref name="value"/>
            </summary>
            <param name="mat">The mat to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Subtraction(Emgu.CV.UMat,Emgu.CV.UMat)">
            <summary>
            Element wise subtract another mat from the current mat
            </summary>
            <param name="mat1">The mat to be subtracted from.</param>
            <param name="mat2">The second image to be subtracted from <paramref name="mat1"/></param>
            <returns> The result of element wise subtracting img2 from <paramref name="mat1"/> </returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Subtraction(Emgu.CV.UMat,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Element wise subtract another mat from the current mat
            </summary>
            <param name="mat">The mat to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> The result of element wise subtracting <paramref name="value"/> from <paramref name="mat"/> </returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Subtraction(Emgu.CV.Structure.MCvScalar,Emgu.CV.UMat)">
            <summary>
            Element wise subtract value from the current mat
            </summary>
            <param name="mat">The mat to be subtracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> <paramref name="value"/> - <paramref name="mat"/> </returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Subtraction(System.Double,Emgu.CV.UMat)">
            <summary>
            <paramref name="value"/> - <paramref name="mat"/>
            </summary>
            <param name="mat">The mat to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramref name="value"/> - <paramref name="mat"/> </returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Subtraction(Emgu.CV.UMat,System.Double)">
            <summary>
            Element wise subtract value from the current mat
            </summary>
            <param name="mat">The mat to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramref name="mat"/> - <paramref name="value"/>   </returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Multiply(Emgu.CV.UMat,System.Double)">
            <summary>
             <paramref name="mat"/> * <paramref name="scale"/>
            </summary>
            <param name="mat">The mat</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="mat"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Multiply(System.Double,Emgu.CV.UMat)">
            <summary>
              <paramref name="scale"/>*<paramref name="mat"/>
            </summary>
            <param name="mat">The mat</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="scale"/>*<paramref name="mat"/></returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Division(Emgu.CV.UMat,System.Double)">
            <summary>
             <paramref name="mat"/> / <paramref name="scale"/>
            </summary>
            <param name="mat">The mat</param>
            <param name="scale">The division scale</param>
            <returns><paramref name="mat"/> / <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.UMat.op_Division(System.Double,Emgu.CV.UMat)">
            <summary>
              <paramref name="scale"/> / <paramref name="mat"/>
            </summary>
            <param name="mat">The mat</param>
            <param name="scale">The scale</param>
            <returns><paramref name="scale"/> / <paramref name="mat"/></returns>
        </member>
        <member name="P:Emgu.CV.UMat.IsContinuous">
            <summary>
            True if the data is continues
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.IsSubmatrix">
            <summary>
            True if the matrix is a submatrix of another matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Depth">
            <summary>
            Depth type
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.IsEmpty">
            <summary>
            True if the matrix is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.NumberOfChannels">
            <summary>
            Number of channels
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Total">
            <summary>
            The method returns the number of array elements (a number of pixels if the array represents an image)
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Dims">
            <summary>
            The matrix dimensionality
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoCapture">
            <summary> 
            Capture images from either camera or video file. 
            </summary>
            <remarks>VideoCapture class is NOT implemented in Open CV for Android, iOS or UWP platforms</remarks>
        </member>
        <member name="T:Emgu.CV.VideoCapture.API">
            <summary>
            VideoCapture API backends identifier.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Any">
            <summary>
            Auto detect
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Vfw">
            <summary>
            Video For Windows (obsolete, removed)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.V4L">
            <summary>
            V4L/V4L2 capturing support
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.V4L2">
            <summary>
            Same as CAP_V4L
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Firewire">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.IEEE1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.DC1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.CMU1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.QT">
            <summary>
             QuickTime (obsolete, removed)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Unicap">
            <summary>
            Unicap drivers (obsolete, removed)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.DShow">
            <summary>
            DirectShow (via videoInput)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Pvapi">
            <summary>
            PvAPI, Prosilica GigE SDK
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.OpenNI">
            <summary>
            OpenNI (for Kinect)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.OpenNIAsus">
            <summary>
            OpenNI (for Asus Xtion)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Android">
            <summary>
            Android - not used
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.XiApi">
            <summary>
            XIMEA Camera API
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.AVFoundation">
            <summary>
            AVFoundation framework for iOS (OS X Lion will have the same API)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Giganetix">
            <summary>
             Smartek Giganetix GigEVisionSDK
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Msmf">
            <summary>
            Microsoft Media Foundation (via videoInput)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Winrt">
            <summary>
            Microsoft Windows Runtime using Media Foundation
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.IntelPerc">
            <summary>
            Intel Perceptual Computing SDK
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Openni2">
            <summary>
            OpenNI2 (for Kinect)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Openni2Asus">
            <summary>
            OpenNI2 (for Asus Xtion and Occipital Structure sensors)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Gphoto2">
            <summary>
            gPhoto2 connection
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Gstreamer">
            <summary>
            GStreamer
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Ffmpeg">
            <summary>
            Open and record video file or stream using the FFMPEG library
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Images">
            <summary>
            OpenCV Image Sequence (e.g. img_%02d.jpg)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Aravis">
            <summary>
            Aravis SDK
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.OpencvMjpeg">
            <summary>
            Built-in OpenCV MotionJPEG codec
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.IntelMfx">
            <summary>
            Intel MediaSDK
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.API.Xine">
            <summary>
            XINE engine (Linux)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture._flipType">
            <summary>
            the type of flipping
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoCapture.CaptureModuleType">
            <summary>
            The type of capture source
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.CaptureModuleType.Camera">
            <summary>
            Capture from camera
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.CaptureModuleType.Highgui">
            <summary>
            Capture from file using HighGUI
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.CaptureSource">
            <summary>
            Get the type of the capture module
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.FlipType">
            <summary>
            Get and set the flip type. If null, no flipping will be done.
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.FlipHorizontal">
            <summary>
            Get or Set if the captured image should be flipped horizontally
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.FlipVertical">
            <summary>
            Get or Set if the captured image should be flipped vertically
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.Width">
            <summary> The width of this capture</summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.Height">
            <summary> The height of this capture </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.#ctor(System.Int32,Emgu.CV.VideoCapture.API,System.Tuple{Emgu.CV.CvEnum.CapProp,System.Int32}[])">
            <summary> Create a capture using the specific camera</summary>
            <param name="camIndex"> The index of the camera to create capture from, starting from 0</param>
            <param name="captureApi">The preferred Capture API backends to use. Can be used to enforce a specific reader implementation if multiple are available.</param>
            <param name="captureProperties">Optional capture properties. e.g. new Tuple&lt;CvEnum.CapProp&gt;(CvEnum.CapProp.HwAcceleration, (int) VideoAccelerationType.Any)</param>
        </member>
        <member name="M:Emgu.CV.VideoCapture.#ctor(System.String,Emgu.CV.VideoCapture.API,System.Tuple{Emgu.CV.CvEnum.CapProp,System.Int32}[])">
            <summary>
            Create a capture from file or a video stream
            </summary>
            <param name="fileName">The name of a file, or an url pointed to a stream.</param>
            <param name="captureApi">The preferred Capture API backends to use. Can be used to enforce a specific reader implementation if multiple are available.</param>
            <param name="captureProperties">Optional capture properties. e.g. new Tuple&lt;CvEnum.CapProp&gt;(CvEnum.CapProp.HwAcceleration, (int) VideoAccelerationType.Any)</param>
        </member>
        <member name="M:Emgu.CV.VideoCapture.DisposeObject">
            <summary>
            Release the resource for this capture
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Get(Emgu.CV.CvEnum.CapProp)">
            <summary>
            Obtain the capture property
            </summary>
            <param name="index">The index for the property</param>
            <returns>Value for the specified property. Value 0 is returned when querying a property that is
            not supported by the backend used by the VideoCapture instance.</returns>
            <remarks>Reading / writing properties involves many layers. Some unexpected result might happens
            along this chain: "VideoCapture -> API Backend -> Operating System -> Device Driver -> Device Hardware"
            The returned value might be different from what really used by the device or it could be encoded
            using device dependent rules(eg.steps or percentage). Effective behaviour depends from device
            driver and API Backend
            </remarks>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Set(Emgu.CV.CvEnum.CapProp,System.Double)">
            <summary>
            Sets the specified property of video capture
            </summary>
            <param name="property">Property identifier</param>
            <param name="value">Value of the property</param>
            <returns>True if the property is supported by backend used by the VideoCapture instance.</returns>
            <remarks>Even if it returns true this doesn't ensure that the property value has been accepted by the capture device.</remarks>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Grab">
            <summary>
            Grab a frame
            </summary>
            <returns>True on success</returns>
        </member>
        <member name="E:Emgu.CV.VideoCapture.ImageGrabbed">
            <summary>
            The event to be called when an image is grabbed
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Start(Emgu.Util.ExceptionHandler)">
            <summary>
            Start the grab process in a separate thread. Once started, use the ImageGrabbed event handler and RetrieveGrayFrame/RetrieveBgrFrame to obtain the images.
            </summary>
            <param name="eh">An exception handler. If provided, it will be used to handle exception in the capture thread.</param>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Pause">
            <summary>
            Pause the grab process if it is running.
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Stop">
            <summary>
            Stop the grabbing thread
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Retrieve(Emgu.CV.IOutputArray,System.Int32)">
            <summary> 
            Decodes and returns the grabbed video frame.
            </summary>
            <param name="image">The video frame is returned here. If no frames has been grabbed the image will be empty.</param>
            <param name="flag">It could be a frame index or a driver specific flag</param>
            <returns>False if no frames has been grabbed</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Read(Emgu.CV.IOutputArray)">
            <summary>
            First call Grab() function follows by Retrieve()
            </summary>
            <param name="m">The output array where the image will be read into.</param>
            <returns>False if no frames has been grabbed</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Read(Emgu.CV.Mat)">
            <summary>
            Same to cv::VideoCapture &gt;gt; cv::Mat function
            </summary>
            <param name="mat">The Mat to be written to. If no more frame is available, the resulting Mat will be empty.</param>
            <returns>False if no frames has been grabbed</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Read(Emgu.CV.UMat)">
            <summary>
            Same to cv::VideoCapture &gt;gt; cv::UMat function
            </summary>
            <param name="umat">The UMat to be written to. If no more frame is available, the resulting UMat will be empty.</param>
            <returns>False if no frames has been grabbed</returns>
        </member>
        <member name="P:Emgu.CV.VideoCapture.BackendName">
            <summary>
            The name of the backend used by this VideoCapture
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.WaitAny(Emgu.CV.Util.VectorOfVideoCapture,Emgu.CV.Util.VectorOfInt,System.Int32)">
            <summary>
            Wait for ready frames from VideoCapture.
            </summary>
            <param name="streams">input video streams</param>
            <param name="readyIndex">stream indexes with grabbed frames (ready to use .retrieve() to fetch actual frame)</param>
            <param name="timeoutNs">number of nanoseconds (0 - infinite)</param>
            <returns>true if streamReady is not empty</returns>
            <remarks>The primary use of the function is in multi-camera environments. The method fills the ready state vector, grabs video frame, if camera is ready.
            After this call use VideoCapture::retrieve() to decode and fetch frame data.</remarks>
        </member>
        <member name="M:Emgu.CV.VideoCapture.QueryFrame">
            <summary> 
            Capture a Bgr image frame
            </summary>
            <returns> A Bgr image frame. If no more frames are available, null will be returned.</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.QuerySmallFrame">
            <summary> 
             Capture a Bgr image frame that is half width and half height. 
             Mainly used by WCF when sending image to remote locations in a bandwidth conservative scenario 
            </summary>
            <remarks>Internally, this is a cvQueryFrame operation follow by a cvPyrDown</remarks>
            <returns> A Bgr image frame that is half width and half height</returns>
        </member>
        <member name="P:Emgu.CV.VideoCapture.IsOpened">
            <summary>
            True if the camera is opened
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.ExceptionMode">
            <summary>
            If True, methods raise exceptions if not successful instead of returning an error code
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Release">
            <summary>
            The method is automatically called by subsequent VideoCapture.Open and by VideoCapture destructor.
            </summary>
        </member>
        <member name="T:Emgu.CV.Backend">
            <summary>
            The backend for video
            </summary>
        </member>
        <member name="M:Emgu.CV.Backend.#ctor(System.Int32)">
            <summary>
            Create a backend given its id
            </summary>
            <param name="id">The id of the backend</param>
        </member>
        <member name="P:Emgu.CV.Backend.ID">
            <summary>
            The ID of the backend.
            </summary>
        </member>
        <member name="P:Emgu.CV.Backend.Name">
            <summary>
            The name of the backend
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoWriter">
            <summary>
            Create a video writer that write images to video format
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Drawing.Size,System.Boolean)">
            <summary>
            Create a video writer using the specific information.
            On windows, it will open a codec selection dialog.
            On linux, it will use the default codec for the specified filename
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="fps">frame rate per second</param>
            <param name="size">the size of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Double,System.Drawing.Size,System.Boolean)">
            <summary>
            Create a video writer using the specific information
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="compressionCode">Compression code. Usually computed using CvInvoke.CV_FOURCC. 
            On windows use -1 to open a codec selection dialog.
            On Linux, use CvInvoke.CV_FOURCC('I', 'Y', 'U', 'V') for default codec for the specific file name.
            </param>
            <param name="fps">frame rate per second</param>
            <param name="size">the size of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Int32,System.Double,System.Drawing.Size,System.Boolean)">
            <summary>
            Create a video writer using the specific information
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="compressionCode">Compression code. Usually computed using CvInvoke.CV_FOURCC. 
            On windows use -1 to open a codec selection dialog.
            On Linux, use CvInvoke.CV_FOURCC('I', 'Y', 'U', 'V') for default codec for the specific file name.
            </param>
            <param name="fps">frame rate per second</param>
            <param name="size">the size of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
            <param name="apiPreference">Allows to specify API backends to use. Use 0 if you don't have any preference.</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Int32,System.Double,System.Drawing.Size,System.Tuple{Emgu.CV.VideoWriter.WriterProperty,System.Int32}[])">
            <summary>
            Create a video writer using the specific information
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="compressionCode">Compression code. Usually computed using CvInvoke.CV_FOURCC. 
            On windows use -1 to open a codec selection dialog.
            On Linux, use VideoWriter.Fourcc('I', 'Y', 'U', 'V') for default codec for the specific file name.
            </param>
            <param name="fps">Frame rate per second</param>
            <param name="size">The size of the frame</param>
            <param name="apiPreference">Allows to specify API backends to use. Use 0 if you don't have any specific preference.</param>
            <param name="writerProperties">Optional writer properties. e.g. new Tuple&lt;VideoWriter.WriterProperty&gt;(VideoWriter.WriterProperty.HwAcceleration, (int) VideoAccelerationType.Any)</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Write(Emgu.CV.IInputArray)">
            <summary>
            Write a single frame to the video writer
            </summary>
            <param name="frame">The frame to be written to the video writer</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Fourcc(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Generate 4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.
            </summary>
            <param name="c1">C1</param>
            <param name="c2">C2</param>
            <param name="c3">C3</param>
            <param name="c4">C4</param>
            <returns>The integer value calculated from the four cc code</returns>
        </member>
        <member name="M:Emgu.CV.VideoWriter.DisposeObject">
            <summary>
            Release the video writer and all the memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoWriter.IsOpened">
            <summary>
            Returns true if video writer has been successfully initialized.
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Set(Emgu.CV.VideoWriter.WriterProperty,System.Double)">
            <summary>
            Sets a property in the VideoWriter.
            </summary>
            <param name="prop">Property identifier</param>
            <param name="value">Value of the property.</param>
            <returns>The value of the specific property</returns>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Get(Emgu.CV.VideoWriter.WriterProperty)">
            <summary>
            Returns the specified VideoWriter property.
            </summary>
            <param name="prop">Property identifier.</param>
            <returns>The value of the specific property</returns>
        </member>
        <member name="P:Emgu.CV.VideoWriter.BackendName">
            <summary>
            The name of the backend used by this VideoWriter
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoWriter.WriterProperty">
            <summary>
            The VideoWriter property
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.Quality">
            <summary>
            Current quality (0..100%) of the encoded videostream. Can be adjusted dynamically in some codecs.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.Framebytes">
            <summary>
            (Read-only): Size of just encoded video frame. Note that the encoding order may be different from representation order.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.NStripes">
            <summary>
            Number of stripes for parallel encoding. -1 for auto detection.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.IsColor">
            <summary>
            If it is not zero, the encoder will expect and encode color frames, otherwise it will work with grayscale frames.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.Depth">
            <summary>
            Defaults to CV_8U
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.HwAcceleration">
            <summary>
            (**open-only**) Hardware acceleration type (see #VideoAccelerationType). Setting supported only via `params` parameter in VideoWriter constructor / .open() method. Default value is backend-specific.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.HwDevice">
            <summary>
            (**open-only**) Hardware device index (select GPU if multiple available)
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.HwAccelerationUseOpencl">
            <summary>
            (**open-only**) If non-zero, create new OpenCL context and bind it to current thread. The OpenCL context created with Video Acceleration context attached it (if not attached yet) for optimized GPU data copy between cv::UMat and HW accelerated encoder.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.AgastFeatureDetector">
            <summary>
            Wrapped AGAST detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.AgastFeatureDetector.Type">
            <summary>
            Agast feature type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AgastFeatureDetector.Type.AGAST_5_8">
            <summary>
            AGAST_5_8
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AgastFeatureDetector.Type.AGAST_7_12d">
            <summary>
            AGAST_7_12d
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AgastFeatureDetector.Type.AGAST_7_12s">
            <summary>
            AGAST_7_12s
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AgastFeatureDetector.Type.OAST_9_16">
            <summary>
            OAST_9_16
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.AgastFeatureDetector.#ctor(System.Int32,System.Boolean,Emgu.CV.Features2D.AgastFeatureDetector.Type)">
            <summary>
            Create AGAST using the specific values
            </summary>
            <param name="threshold">Threshold</param>
            <param name="nonmaxSuppression">Non maximum suppression</param>
            <param name="type">Type</param>
        </member>
        <member name="M:Emgu.CV.Features2D.AgastFeatureDetector.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.Features2DInvoke">
            <summary>
            Library to invoke Features2D functions
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.AKAZE">
            <summary>
            Wrapped AKAZE detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.AKAZE.DescriptorType">
            <summary>
            Type of the extracted descriptor
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AKAZE.DescriptorType.KazeUpright">
            <summary>
            The kaze upright
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AKAZE.DescriptorType.Kaze">
            <summary>
            The kaze
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AKAZE.DescriptorType.MldbUpright">
            <summary>
            Modified-Local Difference Binary (M-LDB), upright
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AKAZE.DescriptorType.Mldb">
            <summary>
            Modified-Local Difference Binary (M-LDB)
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.AKAZE.#ctor(Emgu.CV.Features2D.AKAZE.DescriptorType,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,Emgu.CV.Features2D.KAZE.Diffusivity)">
            <summary>
            Create AKAZE using the specific values
            </summary>
            <param name="descriptorType">Type of the extracted descriptor</param>
            <param name="descriptorSize">Size of the descriptor in bits. 0 -> Full size</param>
            <param name="descriptorChannels">Number of channels in the descriptor (1, 2, 3)</param>
            <param name="threshold">Detector response threshold to accept point</param>
            <param name="nOctaveLayers"> Default number of sublevels per scale level</param>
            <param name="nOctaves">Maximum octave evolution of the image</param>
            <param name="diffusivity">Diffusivity type</param>
        </member>
        <member name="M:Emgu.CV.Features2D.AKAZE.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.DistanceType">
            <summary>
            The match distance type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Inf">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.L1">
            <summary>
            Manhattan distance (city block distance)
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.L2">
            <summary>
            Squared Euclidean distance
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.L2Sqr">
            <summary>
            Euclidean distance
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Hamming">
            <summary>
            Hamming distance functor - counts the bit differences between two strings - useful for the Brief descriptor, 
            bit count of A exclusive XOR'ed with B. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Hamming2">
            <summary>
            Hamming distance functor - counts the bit differences between two strings - useful for the Brief descriptor, 
            bit count of A exclusive XOR'ed with B. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.TypeMask">
            <summary>
             bit-mask which can be used to separate norm type from norm flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Relative">
            <summary>
            Relative, flag
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.MinMax">
            <summary>
            MinMax, flag
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.BFMatcher">
            <summary>
            Wrapped BFMatcher
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.BFMatcher.#ctor(Emgu.CV.Features2D.DistanceType,System.Boolean)">
            <summary>
            Create a BFMatcher of the specific distance type
            </summary>
            <param name="distanceType">The distance type</param>
            <param name="crossCheck">Specify whether or not cross check is needed. Use false for default.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BFMatcher.DisposeObject">
            <summary>
            Release the unmanaged resource associated with the BFMatcher
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.BOWImgDescriptorExtractor">
            <summary>
            Class to compute an image descriptor using the bag of visual words. Such a computation consists of the following
            steps:
            1. Compute descriptors for a given image and its key points set.
            2. Find the nearest visual words from the vocabulary for each key point descriptor.
            3. Compute the bag-of-words image descriptor as is a normalized histogram of vocabulary words encountered in
            the image. The i-th bin of the histogram is a frequency of i-th word of the vocabulary in the given image.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.#ctor(Emgu.CV.Features2D.Feature2D,Emgu.CV.Features2D.DescriptorMatcher)">
            <summary>
            Create a BOWImgDescriptorExtractor
            </summary>
            <param name="descriptorExtractor">Descriptor extractor that is used to compute descriptors for an input image and its key points.</param>
            <param name="descriptorMatcher">Descriptor matcher that is used to find the nearest word of the trained vocabulary for each key point descriptor of the image.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.SetVocabulary(Emgu.CV.Mat)">
            <summary>
            Sets a visual vocabulary.
            </summary>
            <param name="vocabulary">The vocabulary</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.Compute(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Mat)">
            <summary>
            Computes an image descriptor using the set visual vocabulary.
            </summary>
            <param name="image">Image, for which the descriptor is computed</param>
            <param name="keypoints">Key points detected in the input image.</param>
            <param name="imgDescriptors">The output image descriptors.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.BOWKMeansTrainer">
            <summary>
            Kmeans-based class to train visual vocabulary using the bag of visual words approach.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.#ctor(System.Int32,Emgu.CV.Structure.MCvTermCriteria,System.Int32,Emgu.CV.CvEnum.KMeansInitType)">
            <summary>
            Create a new BOWKmeans trainer
            </summary>
            <param name="clusterCount">Number of clusters to split the set by.</param>
            <param name="termcrit">Specifies maximum number of iterations and/or accuracy (distance the centers move by between the subsequent iterations). Use empty termcrit for default.</param>
            <param name="attempts">The number of attempts. Use 3 for default</param>
            <param name="flags">Kmeans initialization flag. Use PPCenters for default.</param>
        </member>
        <member name="P:Emgu.CV.Features2D.BOWKMeansTrainer.DescriptorCount">
            <summary>
            Get the number of descriptors
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.Add(Emgu.CV.Mat)">
            <summary>
            Add the descriptors to the trainer
            </summary>
            <param name="descriptors">The descriptors to be added to the trainer</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.Cluster(Emgu.CV.IOutputArray)">
            <summary>
            Cluster the descriptors and return the cluster centers
            </summary>
            <param name="cluster">The cluster centers</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.Brisk">
            <summary>
            BRISK: Binary Robust Invariant Scalable Keypoints
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Brisk.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Create a BRISK keypoint detector and descriptor extractor.
            </summary>
            <param name="thresh">Feature parameters.</param>
            <param name="octaves">The number of octave layers.</param>
            <param name="patternScale">Pattern scale</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Brisk.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.DescriptorMatcher">
            <summary>
            Descriptor matcher
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DescriptorMatcher._descriptorMatcherPtr">
            <summary>
            The pointer to the Descriptor matcher
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.KnnMatch(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfDMatch,System.Int32,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Finds the k best matches for each descriptor from a query set.
            </summary>
            <param name="queryDescriptors">Query set of descriptors.</param>
            <param name="trainDescriptors">Train set of descriptors. This set is not added to the train descriptors collection stored in the class object.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
            <param name="k">Count of best matches found per each query descriptor or less if a query descriptor has less than k possible matches in total.</param>
            <param name="mask">Mask specifying permissible matches between an input query and train matrices of descriptors.</param>
            <param name="compactResult">Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.KnnMatch(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfDMatch,System.Int32,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Find the k-nearest match
            </summary>
            <param name="queryDescriptor">An n x m matrix of descriptors to be query for nearest neighbours. n is the number of descriptor and m is the size of the descriptor</param>
            <param name="k">Number of nearest neighbors to search for</param>
            <param name="mask">Can be null if not needed. An n x 1 matrix. If 0, the query descriptor in the corresponding row will be ignored.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
            <param name="compactResult">
            Parameter used when the mask (or masks) is not empty. If compactResult is
            false, the matches vector has the same size as queryDescriptors rows.If compactResult is true,
            the matches vector does not contain matches for fully masked-out query descriptors.
            </param>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.Add(Emgu.CV.IInputArray)">
            <summary>
            Add the model descriptors
            </summary>
            <param name="modelDescriptors">The model descriptors</param>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.DisposeObject">
            <summary>
            Reset the native pointer upon object disposal
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.Clear">
            <summary>
            Clears the train descriptor collections.
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.DescriptorMatcher.Empty">
            <summary>
            Returns true if there are no train descriptors in the both collections.
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.DescriptorMatcher.IsMaskSupported">
            <summary>
            Returns true if the descriptor matcher supports masking permissible matches.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.Train">
            <summary>
            Trains a descriptor matcher (for example, the flann index). In all methods to match, the method
            train() is run every time before matching.Some descriptor matchers(for example, BruteForceMatcher)
            have an empty implementation of this method.Other matchers really train their inner structures (for
            example, FlannBasedMatcher trains flann::Index ).
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.Match(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfDMatch,Emgu.CV.IInputArray)">
            <summary>
            Finds the best match for each descriptor from a query set.
            </summary>
            <param name="queryDescriptors">Query set of descriptors.</param>
            <param name="trainDescriptors">Train set of descriptors. This set is not added to the train descriptors collection stored in the class object.</param>
            <param name="matches">If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count.</param>
            <param name="mask">Mask specifying permissible matches between an input query and train matrices of descriptors.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.Match(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfDMatch,Emgu.CV.IInputArrayOfArrays)">
            <summary>
            Finds the best match for each descriptor from a query set. Train descriptors collection that was set by the Add function is used.
            </summary>
            <param name="queryDescriptors">Query set of descriptors.</param>
            <param name="matches">If a query descriptor is masked out in mask , no match is added for this descriptor. So, matches size may be smaller than the query descriptors count.</param>
            <param name="masks">Mask specifying permissible matches between an input query and train matrices of descriptors.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.RadiusMatch(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfDMatch,System.Single,Emgu.CV.IInputArrayOfArrays,System.Boolean)">
            <summary>
            For each query descriptor, finds the training descriptors not farther than the specified distance.
            </summary>
            <param name="queryDescriptors">Query set of descriptors.</param>
            <param name="trainDescriptors">Train set of descriptors. This set is not added to the train descriptors collection stored in the class object.</param>
            <param name="matches">Found matches.</param>
            <param name="maxDistance">Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)!</param>
            <param name="mask">Mask specifying permissible matches between an input query and train matrices of descriptors.</param>
            <param name="compactResult">Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.RadiusMatch(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfDMatch,System.Single,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            For each query descriptor, finds the training descriptors not farther than the specified distance.
            </summary>
            <param name="queryDescriptors">Query set of descriptors.</param>
            <param name="matches">Found matches.</param>
            <param name="maxDistance">Threshold for the distance between matched descriptors. Distance means here metric distance (e.g. Hamming distance), not the distance between coordinates (which is measured in Pixels)!</param>
            <param name="masks">Mask specifying permissible matches between an input query and train matrices of descriptors.</param>
            <param name="compactResult">Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors.</param>
        </member>
        <member name="T:Emgu.CV.Features2D.FastFeatureDetector">
            <summary>
            FAST(Features from Accelerated Segment Test) keypoint detector. 
            See Detects corners using FAST algorithm by E. Rosten ("Machine learning for high-speed corner
            detection, 2006).
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.FastFeatureDetector.DetectorType">
            <summary>
            One of the three neighborhoods as defined in the paper
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.FastFeatureDetector.DetectorType.Type5_8">
            <summary>
            The type5_8
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.FastFeatureDetector.DetectorType.Type7_12">
            <summary>
            The type7_12
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.FastFeatureDetector.DetectorType.Type9_16">
            <summary>
            The type9_16
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.FastFeatureDetector.#ctor(System.Int32,System.Boolean,Emgu.CV.Features2D.FastFeatureDetector.DetectorType)">
            <summary>
            Create a fast detector with the specific parameters
            </summary>
            <param name="threshold">Threshold on difference between intensity of center pixel and pixels on circle around
            this pixel.</param>
            <param name="nonmaxSupression">Specify if non-maximum suppression should be used.</param>
            <param name="type">One of the three neighborhoods as defined in the paper</param>
        </member>
        <member name="M:Emgu.CV.Features2D.FastFeatureDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.Feature2D">
            <summary>
            The feature 2D base class
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Feature2D._feature2D">
            <summary>
            The pointer to the Feature2D object
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.Feature2D.Feature2DPtr">
            <summary>
            Get the pointer to the Feature2D object
            </summary>
            <returns>The pointer to the Feature2D object</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.DetectAndCompute(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Detect keypoints in an image and compute the descriptors on the image from the keypoint locations.
            </summary>
            <param name="image">The image</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <param name="keyPoints">The detected keypoints will be stored in this vector</param>
            <param name="descriptors">The descriptors from the keypoints</param>
            <param name="useProvidedKeyPoints">If true, the method will skip the detection phase and will compute descriptors for the provided keypoints</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.DisposeObject">
            <summary>
            Reset the pointers
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.DetectRaw(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputArray)">
            <summary>
            Detect the features in the image
            </summary>
            <param name="keypoints">The result vector of keypoints</param>
            <param name="image">The image from which the features will be detected from</param>
            <param name="mask">The optional mask.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.Detect(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Detect the keypoints from the image
            </summary>
            <param name="image">The image to extract keypoints from</param>
            <param name="mask">The optional mask.</param>
            <returns>An array of key points</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.Compute(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IOutputArray)">
            <summary>
            Compute the descriptors on the image from the given keypoint locations.
            </summary>
            <param name="image">The image to compute descriptors from</param>
            <param name="keyPoints">The keypoints where the descriptor computation is perfromed</param>
            <param name="descriptors">The descriptors from the given keypoints</param>
        </member>
        <member name="P:Emgu.CV.Features2D.Feature2D.DescriptorSize">
            <summary>
            Get the number of elements in the descriptor.
            </summary>
            <returns>The number of elements in the descriptor</returns>
        </member>
        <member name="T:Emgu.CV.Features2D.Features2DToolbox">
            <summary>
            Tools for features 2D
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.DrawKeypoints(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.Bgr,Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType)">
            <summary>
            Draw the keypoints found on the image.
            </summary>
            <param name="image">The image</param>
            <param name="keypoints">The keypoints to be drawn</param>
            <param name="color">The color used to draw the keypoints</param>
            <param name="type">The drawing type</param>
            <param name="outImage">The image with the keypoints drawn</param> 
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.DrawMatches(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.Util.VectorOfVectorOfByte,Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType)">
            <summary>
            Draw the matched keypoints between the model image and the observed image.
            </summary>
            <param name="modelImage">The model image</param>
            <param name="modelKeypoints">The keypoints in the model image</param>
            <param name="observedImage">The observed image</param>
            <param name="observedKeyPoints">The keypoints in the observed image</param>
            <param name="matchColor">The color for the match correspondence lines</param>
            <param name="singlePointColor">The color for highlighting the keypoints</param>
            <param name="mask">The mask for the matches. Use null for all matches.</param>
            <param name="flags">The drawing type</param>
            <param name="result">The image where model and observed image is displayed side by side. Matches are drawn as indicated by the flag</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.DrawMatches(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfDMatch,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.Util.VectorOfByte,Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType)">
            <summary>
            Draw the matched keypoints between the model image and the observered image.
            </summary>
            <param name="modelImage">The model image</param>
            <param name="modelKeypoints">The keypoints in the model image</param>
            <param name="observedImage">The observed image</param>
            <param name="observedKeyPoints">The keypoints in the observed image</param>
            <param name="matchColor">The color for the match correspondence lines</param>
            <param name="singlePointColor">The color for highlighting the keypoints</param>
            <param name="mask">The mask for the matches. Use null for all matches.</param>
            <param name="flags">The drawing type</param>
            <param name="result">The image where model and observed image is displayed side by side. Matches are drawn as indicated by the flag</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.DrawMatches(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray,Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType)">
            <summary>
            Draw the matched keypoints between the model image and the observed image.
            </summary>
            <param name="modelImage">The model image</param>
            <param name="modelKeypoints">The keypoints in the model image</param>
            <param name="observedImage">The observed image</param>
            <param name="observedKeyPoints">The keypoints in the observed image</param>
            <param name="matchColor">The color for the match correspondence lines</param>
            <param name="singlePointColor">The color for highlighting the keypoints</param>
            <param name="mask">The mask for the matches. Use null for all matches.</param>
            <param name="flags">The drawing type</param>
            <param name="result">The image where model and observed image is displayed side by side. Matches are drawn as indicated by the flag</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="T:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType">
            <summary>
            Define the Keypoint draw type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType.Default">
            <summary>
            Two source image, matches and single keypoints will be drawn.
            For each keypoint only the center point will be drawn (without
            the circle around keypoint with keypoint size and orientation).
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType.NotDrawSinglePoints">
            <summary>
            Single keypoints will not be drawn.
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType.DrawRichKeypoints">
            <summary>
            For each keypoint the circle around keypoint with keypoint size and
            orientation will be drawn.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.VoteForSizeAndOrientation(Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.Mat,System.Double,System.Int32)">
            <summary>
            Eliminate the matched features whose scale and rotation do not aggree with the majority's scale and rotation.
            </summary>
            <param name="rotationBins">The numbers of bins for rotation, a good value might be 20 (which means each bin covers 18 degree)</param>
            <param name="scaleIncrement">This determines the different in scale for neighbor hood bins, a good value might be 1.5 (which means matched features in bin i+1 is scaled 1.5 times larger than matched features in bin i</param>
            <param name="modelKeyPoints">The keypoints from the model image</param>
            <param name="observedKeyPoints">The keypoints from the observed image</param>
            <param name="mask">This is both input and output. This matrix indicates which row is valid for the matches.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
            <returns> The number of non-zero elements in the resulting mask</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.GetHomographyMatrixFromMatchedFeatures(Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.Mat,System.Double)">
            <summary>
            Recover the homography matrix using RANDSAC. If the matrix cannot be recovered, null is returned.
            </summary>
            <param name="model">The model keypoints</param>
            <param name="observed">The observed keypoints</param>
            <param name="ransacReprojThreshold">
            The maximum allowed reprojection error to treat a point pair as an inlier. 
            If srcPoints and dstPoints are measured in pixels, it usually makes sense to set this parameter somewhere in the range 1 to 10.
            </param>
            <param name="mask">
            The mask matrix of which the value might be modified by the function. 
            As input, if the value is 0, the corresponding match will be ignored when computing the homography matrix. 
            If the value is 1 and RANSAC determine the match is an outlier, the value will be set to 0.
            </param>
            <returns>The homography matrix, if it cannot be found, null is returned</returns>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.VoteForUniqueness(Emgu.CV.Util.VectorOfVectorOfDMatch,System.Double,Emgu.CV.Mat)">
            <summary>
            Filter the matched Features, such that if a match is not unique, it is rejected.
            </summary>
            <param name="uniquenessThreshold">The distance different ratio which a match is consider unique, a good number will be 0.8</param>
            <param name="mask">This is both input and output. This matrix indicates which row is valid for the matches.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param> 
        </member>
        <member name="T:Emgu.CV.Features2D.FlannBasedMatcher">
            <summary>
            This matcher trains flann::Index_ on a train descriptor collection and calls its nearest search methods to find the best matches. So, this matcher may be faster when matching a large train collection than the brute force matcher. 
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.FlannBasedMatcher.#ctor(Emgu.CV.Flann.IIndexParams,Emgu.CV.Flann.SearchParams)">
            <summary>
            Create a Flann based matcher.
            </summary>
            <param name="indexParams">The type of index parameters</param>
            <param name="search">The search parameters</param>
        </member>
        <member name="M:Emgu.CV.Features2D.FlannBasedMatcher.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Flann based matcher.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.GFTTDetector">
            <summary>
             Wrapping class for feature detection using the goodFeaturesToTrack() function.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.GFTTDetector.#ctor(System.Int32,System.Double,System.Double,System.Int32,System.Boolean,System.Double)">
            <summary>
            Create a Good Feature to Track detector
            </summary>
            <remarks>The function first calculates the minimal eigenvalue for every source image pixel using cvCornerMinEigenVal function and stores them in eig_image. Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain). The next step is rejecting the corners with the minimal eigenvalue less than quality_level?max(eig_image(x,y)). Finally, the function ensures that all the corners found are distanced enough one from another by considering the corners (the most strongest corners are considered first) and checking that the distance between the newly considered feature and the features considered earlier is larger than min_distance. So, the function removes the features than are too close to the stronger features</remarks>
            <param name="maxCorners">The maximum number of features to be detected.</param>
            <param name="qualityLevel">Multiplier for the maxmin eigenvalue; specifies minimal accepted quality of image corners.</param>
            <param name="minDistance">Limit, specifying minimum possible distance between returned corners; Euclidian distance is used.</param>
            <param name="blockSize">Size of the averaging block, passed to underlying cvCornerMinEigenVal or cvCornerHarris used by the function.</param>
            <param name="useHarrisDetector">If true, will use Harris corner detector.</param>
            <param name="k">K</param>
        </member>
        <member name="M:Emgu.CV.Features2D.GFTTDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.KAZE">
            <summary>
            Wrapped KAZE detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.KAZE.Diffusivity">
            <summary>
            The diffusivity
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.PmG1">
            <summary>
            PM G1
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.PmG2">
            <summary>
            PM G2
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.Weickert">
            <summary>
            Weickert
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.Charbonnier">
            <summary>
            Charbonnier
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.KAZE.#ctor(System.Boolean,System.Boolean,System.Single,System.Int32,System.Int32,Emgu.CV.Features2D.KAZE.Diffusivity)">
            <summary>
            Create KAZE using the specific values
            </summary>
            <param name="extended">Set to enable extraction of extended (128-byte) descriptor.</param>
            <param name="upright">Set to enable use of upright descriptors (non rotation-invariant).</param>
            <param name="threshold">Detector response threshold to accept point</param>
            <param name="octaves">Maximum octave evolution of the image</param>
            <param name="sublevels">Default number of sublevels per scale level</param>
            <param name="diffusivity">Diffusivity type.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.KAZE.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.MSER">
            <summary>
            MSER detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.MSER.#ctor(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Create a MSER detector using the specific parameters
            </summary>
            <param name="delta">In the code, it compares (size_{i}-size_{i-delta})/size_{i-delta}</param>
            <param name="maxArea">Prune the area which bigger than max_area</param>
            <param name="minArea">Prune the area which smaller than min_area</param>
            <param name="maxVariation">Prune the area have similar size to its children</param>
            <param name="minDiversity">Trace back to cut off mser with diversity &lt; min_diversity</param>
            <param name="maxEvolution">For color image, the evolution steps</param>
            <param name="areaThreshold">The area threshold to cause re-initialize</param>
            <param name="minMargin">Ignore too small margin</param>
            <param name="edgeBlurSize">The aperture size for edge blur</param>
        </member>
        <member name="M:Emgu.CV.Features2D.MSER.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.MSER.DetectRegions(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfPoint,Emgu.CV.Util.VectorOfRect)">
            <summary>
            Detect MSER regions
            </summary>
            <param name="image">input image (8UC1, 8UC3 or 8UC4, must be greater or equal than 3x3)</param>
            <param name="msers">resulting list of point sets</param>
            <param name="bboxes">resulting bounding boxes</param>
        </member>
        <member name="P:Emgu.CV.Features2D.MSER.Pass2Only">
            <summary>
            Pass2 only
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.MSER.Delta">
            <summary>
            Delta
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.MSER.MinArea">
            <summary>
            Min Area
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.MSER.MaxArea">
            <summary>
            Max Area
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.ORB">
            <summary>
            Wrapped ORB detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.ORB.ScoreType">
            <summary>
            The score type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.ORB.ScoreType.Harris">
            <summary>
            Harris
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.ORB.ScoreType.Fast">
            <summary>
            Fast
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.ORB.#ctor(System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.Features2D.ORB.ScoreType,System.Int32,System.Int32)">
            <summary>
            Create a ORBDetector using the specific values
            </summary>
            <param name="numberOfFeatures">The number of desired features. </param>
            <param name="scaleFactor">Coefficient by which we divide the dimensions from one scale pyramid level to the next.</param>
            <param name="nLevels">The number of levels in the scale pyramid. </param>
            <param name="firstLevel">The level at which the image is given. If 1, that means we will also look at the image.<paramref name="scaleFactor"/> times bigger</param>
            <param name="edgeThreshold">How far from the boundary the points should be.</param>
            <param name="WTK_A">How many random points are used to produce each cell of the descriptor (2, 3, 4 ...).</param>
            <param name="scoreType">Type of the score to use.</param>
            <param name="patchSize">Patch size.</param>
            <param name="fastThreshold">FAST threshold</param>
        </member>
        <member name="M:Emgu.CV.Features2D.ORB.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.SIFT">
            <summary>
            Wrapped SIFT detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SIFT.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Create a SIFT using the specific values
            </summary>
            <param name="nFeatures">The desired number of features. Use 0 for un-restricted number of features</param>
            <param name="nOctaveLayers">The number of octave layers. Use 3 for default</param>
            <param name="contrastThreshold">Contrast threshold. Use 0.04 as default</param>
            <param name="edgeThreshold">Detector parameter. Use 10.0 as default</param>
            <param name="sigma">Use 1.6 as default</param>
        </member>
        <member name="M:Emgu.CV.Features2D.SIFT.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.SimpleBlobDetector">
            <summary>
            Simple Blob detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetector.#ctor(Emgu.CV.Features2D.SimpleBlobDetectorParams)">
            <summary>
            Create a simple blob detector
            </summary>
            <param name="parameters">The parameters for creating a simple blob detector</param>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetector.GetBlobContours">
            <summary>
            Retrieves the contours of detected blobs.
            </summary>
            <returns>
            A <see cref="T:Emgu.CV.Util.VectorOfVectorOfPoint"/> containing the contours of the detected blobs.
            </returns>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.SimpleBlobDetectorParams">
            <summary>
            Parameters for the simple blob detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetectorParams.#ctor">
            <summary>
            Create parameters for simple blob detector and use default values.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetectorParams.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this simple blob detector parameter.
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.ThresholdStep">
            <summary>
            Threshold step
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinThreshold">
            <summary>
            Min threshold
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxThreshold">
            <summary>
            Max threshold
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinDistBetweenBlobs">
            <summary>
            Min dist between blobs
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByColor">
            <summary>
            Filter by color
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.blobColor">
            <summary>
            Blob color
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByArea">
            <summary>
            Filter by area
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinArea">
            <summary>
            Min area
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxArea">
            <summary>
            Max area
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByCircularity">
            <summary>
            Filter by circularity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinCircularity">
            <summary>
            Min circularity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxCircularity">
            <summary>
            Max circularity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByInertia">
            <summary>
            Filter by inertia
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinInertiaRatio">
            <summary>
            Min inertia ratio
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxInertiaRatio">
            <summary>
            Max inertia ratio
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByConvexity">
            <summary>
            Filter by convexity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinConvexity">
            <summary>
            Min Convexity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxConvexity">
            <summary>
            Max Convexity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinRepeatability">
            <summary>
            Min Repeatability
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.CollectContours">
            <summary>
            Collect Contours
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.CenterInitType">
            <summary>
            The Kmeans center initiation types
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.Random">
            <summary>
            Random
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.Gonzales">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.Kmeanspp">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.IIndexParams">
            <summary>
            The index parameters interface
            </summary>
        </member>
        <member name="P:Emgu.CV.Flann.IIndexParams.IndexParamPtr">
            <summary>
            Gets the pointer to the index parameter.
            </summary>
            <value>
            The index parameter pointer.
            </value>
        </member>
        <member name="T:Emgu.CV.Flann.DistType">
            <summary>
            Distance Type
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.Euclidean">
            <summary>
            Euclidean
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.L2">
            <summary>
            L2
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.Manhattan">
            <summary>
            Manhattan
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.L1">
            <summary>
            L1
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.Minkowski">
            <summary>
            Minkowski
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.Max">
            <summary>
            Max
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.HistIntersect">
            <summary>
            HistIntersect
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.Hellinger">
            <summary>
            Hellinger
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.ChiSquare">
            <summary>
            ChiSquare
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.CS">
            <summary>
            CS
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.KullbackLeibler">
            <summary>
            KullbackLeibler
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.KL">
            <summary>
            KL
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.DistType.Hamming">
            <summary>
            Hamming
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.Index">
            <summary>
            Flann index
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.Index.#ctor(Emgu.CV.IInputArray,Emgu.CV.Flann.IIndexParams,Emgu.CV.Flann.DistType)">
            <summary>
            Create a flann index
            </summary>
            <param name="values">A row by row matrix of descriptors</param>
            <param name="ip">The index parameter</param>
            <param name="distType">The distance type</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.KnnSearch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Single,System.Boolean)">
            <summary>
            Perform k-nearest-neighbours (KNN) search
            </summary>
            <param name="queries">A row by row matrix of descriptors to be query for nearest neighbours</param>
            <param name="indices">The result of the indices of the k-nearest neighbours</param>
            <param name="squareDistances">The square of the Eculidean distance between the neighbours</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="checks">The number of times the tree(s) in the index should be recursively traversed. A
            higher value for this parameter would give better search precision, but also take more
            time. If automatic configuration was used when the index was created, the number of
            checks required to achieve the specified precision was also computed, in which case
            this parameter is ignored </param>
            <param name="eps">The search epsilon</param>
            <param name="sorted">If set to true, the search result is sorted</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.RadiusSearch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double,System.Int32,System.Int32,System.Single,System.Boolean)">
            <summary>
            Performs a radius nearest neighbor search for multiple query points
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="squareDistances">The square of the Eculidean distance between the neighbours</param>
            <param name="radius">The search radius</param>
            <param name="maxResults">The maximum number of results</param>
            <param name="checks">The number of times the tree(s) in the index should be recursively traversed. A
            higher value for this parameter would give better search precision, but also take more
            time. If automatic configuration was used when the index was created, the number of
            checks required to achieve the specified precision was also computed, in which case
            this parameter is ignored </param>
            <param name="eps">The search epsilon</param>
            <param name="sorted">If set to true, the search result is sorted</param>
            <returns>The number of points in the search radius</returns>
        </member>
        <member name="M:Emgu.CV.Flann.Index.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Flann Index
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.Index3D">
            <summary>
            Create index for 3D points
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.#ctor(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.Flann.IIndexParams)">
            <summary>
            Create a flann index for 3D points
            </summary>
            <param name="points">The IPosition3D array</param>
            <param name="ip">The index parameters</param>
        </member>
        <member name="T:Emgu.CV.Flann.Index3D.Neighbor">
            <summary>
            A neighbor point
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.Index3D.Neighbor.Index">
            <summary>
            The index of the point
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.Index3D.Neighbor.SquareDist">
            <summary>
            The square distance
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.NearestNeighbor(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Find the approximate nearest position in 3D
            </summary>
            <param name="position">The position to start the search from</param>
            <returns>The nearest neighbor (may be an approximation, depends in the index type).</returns>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.RadiusSearch(Emgu.CV.Structure.MCvPoint3D32f,System.Double,System.Int32)">
            <summary>
            Perform a search within the given radius
            </summary>
            <param name="position">The center of the search area</param>
            <param name="radius">The radius of the search</param>
            <param name="maxResults">The maximum number of results to return</param>
            <returns>The neighbors found</returns>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.DisposeObject">
            <summary>
            Release the resource used by this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.LinearIndexParams">
            <summary>
            When passing an object of this type, the index will perform a linear, brute-force search.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.LinearIndexParams.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.LinearIndexParams"/> class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.LinearIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.KdTreeIndexParams">
            <summary>
            When passing an object of this type the index constructed will consist of a set of randomized kd-trees which will be searched in parallel.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.KdTreeIndexParams.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.KdTreeIndexParams"/> class.
            </summary>
            <param name="trees">The number of parallel kd-trees to use. Good values are in the range [1..16]</param>
        </member>
        <member name="M:Emgu.CV.Flann.KdTreeIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.LshIndexParams">
            <summary>
            When using a parameters object of this type the index created uses multi-probe LSH (by Multi-Probe LSH: Efficient Indexing for High-Dimensional Similarity Search by Qin Lv, William Josephson, Zhe Wang, Moses Charikar, Kai Li., Proceedings of the 33rd International Conference on Very Large Data Bases (VLDB). Vienna, Austria. September 2007)
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.LshIndexParams.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.LshIndexParams"/> class.
            </summary>
            <param name="tableNumber">The number of hash tables to use (between 10 and 30 usually).</param>
            <param name="keySize">The size of the hash key in bits (between 10 and 20 usually).</param>
            <param name="multiProbeLevel">The number of bits to shift to check for neighboring buckets (0 is regular LSH, 2 is recommended).</param>
        </member>
        <member name="M:Emgu.CV.Flann.LshIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.KMeansIndexParams">
            <summary>
            When passing an object of this type the index constructed will be a hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.KMeansIndexParams.#ctor(System.Int32,System.Int32,Emgu.CV.Flann.CenterInitType,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.KMeansIndexParams"/> class.
            </summary>
            <param name="branching">The branching factor to use for the hierarchical k-means tree</param>
            <param name="iterations"> The maximum number of iterations to use in the k-means clustering stage when building the k-means tree. A value of -1 used here means that the k-means clustering should be iterated until convergence</param>
            <param name="centersInit">The algorithm to use for selecting the initial centers when performing a k-means clustering step. The possible values are CENTERS_RANDOM (picks the initial cluster centers randomly), CENTERS_GONZALES (picks the initial centers using Gonzales’ algorithm) and CENTERS_KMEANSPP (picks the initial centers using the algorithm suggested in arthur_kmeanspp_2007 )</param>
            <param name="cbIndex">This parameter (cluster boundary index) influences the way exploration is performed in the hierarchical kmeans tree. When cb_index is zero the next kmeans domain to be explored is chosen to be the one with the closest center. A value greater then zero also takes into account the size of the domain.</param>
        </member>
        <member name="M:Emgu.CV.Flann.KMeansIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.CompositeIndexParams">
            <summary>
            When using a parameters object of this type the index created combines the randomized kd-trees and the hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.CompositeIndexParams.#ctor(System.Int32,System.Int32,System.Int32,Emgu.CV.Flann.CenterInitType,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.CompositeIndexParams"/> class.
            </summary>
            <param name="trees">The number of parallel kd-trees to use. Good values are in the range [1..16]</param>
            <param name="branching">The branching factor to use for the hierarchical k-means tree</param>
            <param name="iterations"> The maximum number of iterations to use in the k-means clustering stage when building the k-means tree. A value of -1 used here means that the k-means clustering should be iterated until convergence</param>
            <param name="centersInit">The algorithm to use for selecting the initial centers when performing a k-means clustering step. The possible values are CENTERS_RANDOM (picks the initial cluster centers randomly), CENTERS_GONZALES (picks the initial centers using Gonzales’ algorithm) and CENTERS_KMEANSPP (picks the initial centers using the algorithm suggested in arthur_kmeanspp_2007 )</param>
            <param name="cbIndex">This parameter (cluster boundary index) influences the way exploration is performed in the hierarchical kmeans tree. When cb_index is zero the next kmeans domain to be explored is chosen to be the one with the closest center. A value greater then zero also takes into account the size of the domain.</param>
        </member>
        <member name="M:Emgu.CV.Flann.CompositeIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.AutotunedIndexParams">
            <summary>
            When passing an object of this type the index created is automatically tuned to offer the best performance, by choosing the optimal index type (randomized kd-trees, hierarchical kmeans, linear) and parameters for the dataset provided.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.AutotunedIndexParams.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.AutotunedIndexParams"/> class.
            </summary>
            <param name="targetPrecision"> Is a number between 0 and 1 specifying the percentage of the approximate nearest-neighbor searches that return the exact nearest-neighbor. Using a higher value for this parameter gives more accurate results, but the search takes longer. The optimum value usually depends on the application.</param>
            <param name="buildWeight">Specifies the importance of the index build time reported to the nearest-neighbor search time. In some applications it’s acceptable for the index build step to take a long time if the subsequent searches in the index can be performed very fast. In other applications it’s required that the index be build as fast as possible even if that leads to slightly longer search times.</param>
            <param name="memoryWeight">Is used to specify the trade off between time (index build time and search time) and memory used by the index. A value less than 1 gives more importance to the time spent and a value greater than 1 gives more importance to the memory usage.</param>
            <param name="sampleFraction">Is a number between 0 and 1 indicating what fraction of the dataset to use in the automatic parameter configuration algorithm. Running the algorithm on the full dataset gives the most accurate results, but for very large datasets can take longer than desired. In such case using just a fraction of the data helps speeding up this algorithm while still giving good approximations of the optimum parameters.</param>
        </member>
        <member name="M:Emgu.CV.Flann.AutotunedIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.HierarchicalClusteringIndexParams">
            <summary>
            Hierarchical Clustering Index Parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.HierarchicalClusteringIndexParams.#ctor(System.Int32,Emgu.CV.Flann.CenterInitType,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.HierarchicalClusteringIndexParams"/>.
            </summary>
            <param name="branching">branching</param>
            <param name="centersInit">Center initialization method</param>
            <param name="trees">Trees</param>
            <param name="leafSize">Leaf Size</param>
        </member>
        <member name="M:Emgu.CV.Flann.HierarchicalClusteringIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.SearchParams">
            <summary>
            Search parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.SearchParams.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.SearchParams"/> class.
            </summary>
            <param name="checks">how many leafs to visit when searching for neighbors (-1 for unlimited)</param>
            <param name="eps">Search for eps-approximate neighbors </param>
            <param name="sorted">Only for radius search, require neighbors sorted by distance </param>
        </member>
        <member name="M:Emgu.CV.Flann.SearchParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Geodetic.GeodeticCoordinate">
            <summary>
            A geodetic coordinate that is defined by its latitude, longitude and altitude
            </summary>
        </member>
        <member name="F:Emgu.CV.Geodetic.GeodeticCoordinate.Empty">
            <summary>
            Indicates the origin of the Geodetic Coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a geodetic coordinate using the specific values
            </summary>
            <param name="latitude">Latitude in radian</param>
            <param name="longitude">Longitude in radian</param>
            <param name="altitude">Altitude in meters</param>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Latitude">
            <summary>
            Latitude (phi) in radian
            </summary>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Longitude">
            <summary>
            Longitude (lambda) in radian
            </summary>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Altitude">
            <summary>
            Altitude (height) in meters
            </summary>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Addition(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Compute the sum of two GeodeticCoordinates
            </summary>
            <param name="coor1">The first coordinate to be added</param>
            <param name="coor2">The second coordinate to be added</param>
            <returns>The sum of two GeodeticCoordinates</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Subtraction(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Compute <paramref name="coor1"/> - <paramref name="coor2"/>
            </summary>
            <param name="coor1">The first coordinate</param>
            <param name="coor2">The coordinate to be subtracted</param>
            <returns><paramref name="coor1"/> - <paramref name="coor2"/></returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Multiply(Emgu.CV.Geodetic.GeodeticCoordinate,System.Double)">
            <summary>
            Compute <paramref name="coor"/> * <paramref name="scale"/>
            </summary>
            <param name="coor">The coordinate</param>
            <param name="scale">The scale to be multiplied</param>
            <returns><paramref name="coor"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.Equals(Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Check if this Geodetic coordinate equals <paramref name="other"/>
            </summary>
            <param name="other">The other coordinate to be compared with</param>
            <returns>True if two coordinates equals</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.RadianToDegree(System.Double)">
            <summary>
            Convert radian to degree
            </summary>
            <param name="radian">radian</param>
            <returns>degree</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.DegreeToRadian(System.Double)">
            <summary>
            Convert degree to radian
            </summary>
            <param name="degree">degree</param>
            <returns>radian</returns>
        </member>
        <member name="T:Emgu.CV.Reflection.ExposableMethodAttribute">
            <summary>
            Attribute used by ImageBox to generate Operation Menu
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.Exposable">
            <summary>
            Get or Set the exposable value, if true, this function will be displayed in Operation Menu of ImageBox
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.Category">
            <summary>
            The catefory of this function
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.GenericParametersOptionSizes">
            <summary>
            The size for each generic parameter Options
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.GenericParametersOptions">
            <summary>
            The options for generic parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ExposableMethodAttribute.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Emgu.CV.Reflection.GenericParameter">
            <summary>
            A generic parameter for the Operation class
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.GenericParameter.SelectedType">
            <summary>
            The selected generic parameter type
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.GenericParameter.AvailableTypes">
            <summary>
            The types that can be used
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.GenericParameter.#ctor(System.Type,System.Type[])">
            <summary>
            Create a generic parameter for the Operation class
            </summary>
            <param name="selectedType">The selected generic parameter typ</param>
            <param name="availableType">The types that can be used</param>
        </member>
        <member name="T:Emgu.CV.Reflection.ReflectColorType">
            <summary>
            A collection of reflection function that can be applied to ColorType object
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectColorType.GetDisplayColorOfChannels(Emgu.CV.IColor)">
            <summary>
            Get the display color for each channel
            </summary>
            <param name="color">The color</param>
            <returns>The display color for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectColorType.GetNamesOfChannels(Emgu.CV.IColor)">
            <summary>
            Get the names of the channels
            </summary>
            <param name="color">The color</param>
            <returns>The names of the channels</returns>
        </member>
        <member name="T:Emgu.CV.Reflection.ReflectIImage">
            <summary>
            A collection of reflection function that can be applied to IImage object
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetImageMethods(Emgu.CV.IInputArray)">
            <summary>
            Get all the methods that belongs to the IImage and Image class with ExposableMethodAttribute set true.
            </summary>
            <param name="image">The IImage object to be refelected for methods marked with ExposableMethodAttribute</param>
            <returns>All the methods that belongs to the IImage and Image class with ExposableMethodAttribute set true</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetTypeOfColor(Emgu.CV.IInputArray)">
            <summary>
            Get the color type of the image
            </summary>
            <param name="image">The image to apply reflection on</param>
            <returns>The color type of the image</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetTypeOfDepth(Emgu.CV.IInputArray)">
            <summary>
            Get the depth type of the image
            </summary>
            <param name="image">The image to apply reflection on</param>
            <returns>The depth type of the image</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetPixelColor(Emgu.CV.IInputArray,System.Drawing.Point)">
            <summary>
            Get the color at the specific location of the image
            </summary>
            <param name="image">The image to obtain pixel value from</param>
            <param name="location">The location to sample a pixel</param>
            <returns>The color at the specific location</returns>
        </member>
        <member name="T:Emgu.CV.Tiff.TiffWriter`2">
            <summary>
            A class that can be used for writing geotiff
            </summary>
            <typeparam name="TColor">The color type of the image to be written</typeparam>
            <typeparam name="TDepth">The depth type of the image to be written</typeparam>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.#ctor(System.String)">
            <summary>
            Create a tiff writer to save an image
            </summary>
            <param name="fileName">The file name to be saved</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.WriteImage(Emgu.CV.Image{`0,`1})">
            <summary>
            Write the image to the tiff file
            </summary>
            <param name="image">The image to be written</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.WriteGeoTag(System.Double[],System.Double[])">
            <summary>
            Write the geo information into the tiff file
            </summary>
            <param name="modelTiepoint">Model Tie Point, an array of size 6</param>
            <param name="modelPixelScale">Model pixel scale, an array of size 3</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.DisposeObject">
            <summary>
            Release the writer and write all data on to disk.
            </summary>
        </member>
        <member name="T:Emgu.CV.Tiff.TileTiffWriter`2">
            <summary>
            A writer for writing GeoTiff
            </summary>
            <typeparam name="TColor">The color type of the image to be written</typeparam>
            <typeparam name="TDepth">The depth type of the image to be written</typeparam>
        </member>
        <member name="M:Emgu.CV.Tiff.TileTiffWriter`2.#ctor(System.String,System.Drawing.Size,System.Drawing.Size)">
            <summary>
            Create a TitleTiffWriter.
            </summary>
            <param name="fileName">The name of the file to be written to</param>
            <param name="imageSize">The size of the image</param>
            <param name="tileSize">The tile size in pixels</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TileTiffWriter`2.WriteTile(System.Int32,System.Int32,Emgu.CV.Image{`0,`1})">
            <summary>
            Write a tile into the tile tiff
            </summary>
            <param name="rowNumber">The starting row for the tile</param>
            <param name="colNumber">The starting col for the tile</param>
            <param name="tile">The tile to be written</param>
        </member>
        <member name="P:Emgu.CV.Tiff.TileTiffWriter`2.TileSizeInBytes">
            <summary>
            Get the equivalent size for a tile of data as it would be returned in a call to TIFFReadTile or as it would be expected in a call to TIFFWriteTile. 
            </summary>
        </member>
        <member name="P:Emgu.CV.Tiff.TileTiffWriter`2.TileRowSizeInBytes">
            <summary>
            Get the number of bytes of a row of data in a tile. 
            </summary>
        </member>
        <member name="P:Emgu.CV.Tiff.TileTiffWriter`2.TileSize">
            <summary>
            Get tile size in pixels.
            </summary>
        </member>
        <member name="M:Emgu.CV.Tiff.TileTiffWriter`2.WriteImage(Emgu.CV.Image{`0,`1})">
            <summary>
            Write the whole image as tile tiff
            </summary>
            <param name="image">The image to be written</param>
        </member>
        <member name="T:Emgu.CV.Ocl.Context">
            <summary>
            This class contains ocl context information
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Context.#ctor">
            <summary>
            Create a empty OclContext object
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Context.Default">
            <summary>
            Get the default OclContext. Do not dispose this context.
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Context.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this OclContext
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Context.GetProgram(Emgu.CV.Ocl.ProgramSource,System.String,Emgu.CV.CvString)">
            <summary>
            Compile the program 
            </summary>
            <param name="prog">The program source</param>
            <param name="buildOpt">The build option</param>
            <param name="errMsg">Error message</param>
            <returns>The compiled program</returns>
        </member>
        <member name="T:Emgu.CV.Ocl.OclInvoke">
            <summary>
            Class that contains ocl functions
            </summary>
            <summary>
            Class that contains ocl functions
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
            <summary>
            Class that contains ocl functions
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.OclInvoke.TypeToString(Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Convert the DepthType to a string that represent the OpenCL value type.
            </summary>
            <param name="depthType">The depth type</param>
            <param name="channels">The number of channels</param>
            <returns>A string the repsent the OpenCL value type</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.OclInvoke.GetPlatformsInfo">
            <summary>
            Get all the platform info as a vector
            </summary>
            <returns>The vector of Platfom info</returns>
        </member>
        <member name="T:Emgu.CV.Ocl.Device">
            <summary>
            This class contains ocl device information
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Device.#ctor">
            <summary>
            Create a empty OclDevice object
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Default">
            <summary>
            Get the default OclDevice. Do not dispose this device.
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Device.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this OclDevice
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.NativeDevicePointer">
            <summary>
            Get the native device pointer
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Device.Set(System.IntPtr)">
            <summary>
            Set the native device pointer
            </summary>
            <param name="nativeDevicePointer">The native device pointer</param>
        </member>
        <member name="M:Emgu.CV.Ocl.Device.ToString">
            <summary>
            Get the string representation of this oclDevice
            </summary>
            <returns>A string representation of this oclDevice</returns>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.IsNVidia">
            <summary>
            Indicates if this is an NVidia device
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.IsIntel">
            <summary>
            Indicates if this is an Intel device
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.IsAMD">
            <summary>
            Indicates if this is an AMD device
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.AddressBits">
            <summary>
            The AddressBits
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.LinkerAvailable">
            <summary>
            Indicates if the linker is available
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.CompilerAvailable">
            <summary>
            Indicates if the compiler is available
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Available">
            <summary>
            Indicates if the device is available
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.MaxWorkGroupSize">
            <summary>
            The maximum work group size
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.MaxComputeUnits">
            <summary>
            The max compute unit
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.LocalMemSize">
            <summary>
            The local memory size
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.MaxMemAllocSize">
            <summary>
            The maximum memory allocation size
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.DeviceVersionMajor">
            <summary>
            The device major version number
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.DeviceVersionMinor">
            <summary>
            The device minor version number
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.HalfFPConfig">
            <summary>
            The device half floating point configuration
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.SingleFPConfig">
            <summary>
            The device single floating point configuration
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.DoubleFPConfig">
            <summary>
            The device double floating point configuration
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.HostUnifiedMemory">
            <summary>
            True if the device use unified memory
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.GlobalMemSize">
            <summary>
            The global memory size
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Image2DMaxWidth">
            <summary>
            The image 2d max width
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Image2DMaxHeight">
            <summary>
            The image2d max height
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Type">
            <summary>
            The ocl device type
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Name">
            <summary>
            The device name
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Version">
            <summary>
            The device version
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.VendorName">
            <summary>
            The device vendor name
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.DriverVersion">
            <summary>
            The device driver version
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Extensions">
            <summary>
            The device extensions
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.OpenCLVersion">
            <summary>
            The device OpenCL version
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.OpenCLCVersion">
            <summary>
            The device OpenCL C version
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.DeviceType">
            <summary>
            Ocl Device Type
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.Cpu">
            <summary>
            Cpu
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.Gpu">
            <summary>
            Gpu
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.Accelerator">
            <summary>
            Accerlerator
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.DGpu">
            <summary>
            DGpu
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.IGpu">
            <summary>
            IGpu
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.All">
            <summary>
            All
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.FpConfig">
            <summary>
            Floating point configuration
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.Denorm">
            <summary>
            Denorm
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.InfNan">
            <summary>
            inf, nan
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.RoundToNearest">
            <summary>
            round to nearest
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.RoundToZero">
            <summary>
            round to zero
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.RoundToInf">
            <summary>
            round to infinite
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.Fma">
            <summary>
            FMA
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.SoftFloat">
            <summary>
            soft float
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.CorrectlyRoundedDivideSqrt">
            <summary>
            Correctly rounded divide sqrt
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.Image2D">
            <summary>
            cv::ocl::Image2D
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Image2D.#ctor(Emgu.CV.UMat,System.Boolean,System.Boolean)">
            <summary>
            Create an OclImage2D object from UMat
            </summary>
            <param name="src">The UMat from which to get image properties and data</param>
            <param name="norm">Flag to enable the use of normalized channel data types</param>
            <param name="alias">Flag indicating that the image should alias the src UMat. If true, changes to the image or src will be reflected in both objects.</param>
        </member>
        <member name="M:Emgu.CV.Ocl.Image2D.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this OclImage2D
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.Kernel">
            <summary>
            An opencl kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.#ctor">
            <summary>
            Create an opencl kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Create(System.String,Emgu.CV.Ocl.ProgramSource,System.String,Emgu.CV.CvString)">
            <summary>
            Create an opencl kernel
            </summary>
            <param name="kernelName">The name of the kernel</param>
            <param name="programSource">The program source code</param>
            <param name="buildOps">The build options</param>
            <param name="errMsg">Option error message container that can be passed to this function</param>
            <returns>True if the kernel can be created</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.DisposeObject">
            <summary>
            Release the opencl kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,Emgu.CV.Ocl.Image2D)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="image2d">The ocl image</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,Emgu.CV.UMat)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="umat">The umat</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,System.Int32@)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="value">The value</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,System.Single@)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="value">The value</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,System.Double@)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="value">The value</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,Emgu.CV.Ocl.KernelArg)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="kernelArg">The kernel arg</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="data">The data</param>
            <param name="size">The size of the data in number of bytes</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Run(System.IntPtr[],System.IntPtr[],System.Boolean,Emgu.CV.Ocl.Queue)">
            <summary>
            Execute the kernel
            </summary>
            <param name="globalsize">The global size</param>
            <param name="localsize">The local size</param>
            <param name="sync">If true, the code is run synchronously (blocking)</param>
            <param name="q">Optional Opencl queue</param>
            <returns>True if the execution is sucessful</returns>
        </member>
        <member name="P:Emgu.CV.Ocl.Kernel.Empty">
            <summary>
            Indicates if the kernel is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Kernel.NativeKernelPtr">
            <summary>
            The pointer to the native kernel
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.KernelArg">
            <summary>
            OpenCL kernel arg
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.KernelArg.Flags">
            <summary>
            KernelArg flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.Local">
            <summary>
            Local
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.ReadOnly">
            <summary>
            Read only
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.WriteOnly">
            <summary>
            Write only
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.ReadWrite">
            <summary>
            Read write
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.Constant">
            <summary>
            Constant
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.PtrOnly">
            <summary>
            Ptr only
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.NoSize">
            <summary>
            No size
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.KernelArg.#ctor(Emgu.CV.Ocl.KernelArg.Flags,Emgu.CV.UMat,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Create the OCL kernel arg
            </summary>
            <param name="flags">The flags</param>
            <param name="m">The UMat</param>
            <param name="wscale">wscale</param>
            <param name="iwscale">iwscale</param>
            <param name="obj">obj</param>
            <param name="sz">sz</param>
        </member>
        <member name="M:Emgu.CV.Ocl.KernelArg.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.PlatformInfo">
            <summary>
            This class contains ocl platform information
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.PlatformInfo.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this OclInfo
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.PlatformInfo.GetDevice(System.Int32)">
            <summary>
            Get the OclDevice with the specific index
            </summary>
            <param name="d">The index of the ocl device</param>
            <returns>The ocl device with the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.PlatformInfo.ToString">
            <summary>
            Get the string that represent this oclPlatformInfo object
            </summary>
            <returns>A string that represent this oclPlatformInfo object</returns>
        </member>
        <member name="P:Emgu.CV.Ocl.PlatformInfo.Name">
            <summary>
            The platform name
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.PlatformInfo.Version">
            <summary>
            The platform version
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.PlatformInfo.Vendor">
            <summary>
            The platform vendor
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.PlatformInfo.DeviceNumber">
            <summary>
            The number of devices
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.Program">
            <summary>
            This class contains ocl Program information
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Program.#ctor">
            <summary>
            Create a empty OclProgram object
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Program.Binary">
            <summary>
            Get the program binary
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Program.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this OclProgram
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.ProgramSource">
            <summary>
            Open CL kernel program source code
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.ProgramSource.#ctor(System.String)">
            <summary>
            Create OpenCL program source code
            </summary>
            <param name="source">The source code</param>
        </member>
        <member name="P:Emgu.CV.Ocl.ProgramSource.Source">
            <summary>
            Get the source code as String
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.ProgramSource.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.Queue">
            <summary>
            An OpenCL Queue
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Queue.#ctor">
            <summary>
            OpenCL queue
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Queue.Finish">
            <summary>
            Wait for the queue to finish
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Queue.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.BinaryFileStorage`1">
            <summary>
            A raw data storage
            </summary>
            <typeparam name="T">The type of elements in the storage</typeparam>
        </member>
        <member name="F:Emgu.CV.Util.BinaryFileStorage`1._fileInfo">
            <summary>
            The file info
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.#ctor(System.String)">
            <summary>
            Create a binary File Storage
            </summary>
            <param name="fileName">The file name of the storage</param>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.#ctor(System.String,System.Int32)">
            <summary>
            Create a binary File Storage
            </summary>
            <param name="fileName">The file name of the storage</param>
            <param name="trunkSize">The data will be read in trunk of this size internally. Can be use to seed up the file read. A good number will be 4096</param>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.#ctor(System.String,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a binary File Storage with the specific data
            </summary>
            <param name="fileName">The file name of the storage, all data in the existing file will be replaced</param>
            <param name="samples">The data which will be stored in the storage</param>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.Append(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Append the samples to the end of the storage
            </summary>
            <param name="samples">The samples to be appended to the storage</param>
        </member>
        <member name="P:Emgu.CV.Util.BinaryFileStorage`1.FileName">
            <summary>
            The file name of the storage
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.Clear">
            <summary>
            Delete all data in the existing storage, if there is any.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.EstimateSize">
            <summary>
            Estimate the number of elements in this storage as the size of the storage divided by the size of the elements
            </summary>
            <returns>An estimation of the number of elements in this storage</returns>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.Peek">
            <summary>
            Get a copy of the first element in the storage. If the storage is empty, a default value will be returned
            </summary>
            <returns>A copy of the first element in the storage. If the storage is empty, a default value will be returned</returns>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.GetSubsamples(System.Int32)">
            <summary>
            Get the sub-sampled data in this storage
            </summary>
            <param name="subsampleRate">The sub-sample rate</param>
            <returns>The sub-sampled data in this storage</returns>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.GetEnumerator">
            <summary>
            Get the data in this storage
            </summary>
            <returns>The data in this storage</returns>
        </member>
        <member name="T:Emgu.CV.Util.CvException">
            <summary>
            The default exception to be thrown when error encounter in Open CV 
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.Status">
            <summary>
            The numeric code for error status
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.ErrorStr">
            <summary>
            The corresponding error string for the Status code
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.FunctionName">
            <summary>
            The name of the function the error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.ErrorMessage">
            <summary>
            A description of the error
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.FileName">
            <summary>
            The source file name where error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.Line">
            <summary>
            The line number in the souce where error is encountered
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.CvException.#ctor(System.Int32,System.String,System.String,System.String,System.Int32)">
            <summary>
            The default exception to be thrown when error is encountered in Open CV 
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
        </member>
        <member name="T:Emgu.CV.Util.CvToolbox">
            <summary>
            Utilities class
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetMatrixFromArrays``1(``0[][])">
            <summary>
            Convert arrays of data to matrix
            </summary>
            <param name="data">Arrays of data</param>
            <returns>A two dimension matrix that represent the array</returns>
            <typeparam name="T">The data type of the matrix</typeparam>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetMatrixFromPoints(Emgu.CV.Structure.MCvPoint2D64f[][])">
            <summary>
            Convert arrays of points to matrix
            </summary>
            <param name="points">Arrays of points</param>
            <returns>A two dimension matrix that represent the points</returns>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetMinMax(System.Collections.Generic.IEnumerable{Emgu.CV.Structure.MCvPoint3D64f},Emgu.CV.Structure.MCvPoint3D64f@,Emgu.CV.Structure.MCvPoint3D64f@)">
            <summary>
            Compute the minimum and maximum value from the points
            </summary>
            <param name="points">The points</param>
            <param name="min">The minimum x,y,z values</param>
            <param name="max">The maximum x,y,z values</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.CopyVector``1(``0[],System.IntPtr,System.Int32)">
            <summary>
            Copy a generic vector to the unmanaged memory
            </summary>
            <typeparam name="TData">The data type of the vector</typeparam>
            <param name="src">The source vector</param>
            <param name="dest">Pointer to the destination unmanaged memory</param>
            <param name="bytesToCopy">Specify the number of bytes to copy. If this is -1, the number of bytes equals the number of bytes in the <paramref name="src"> array</paramref></param>
            <returns>The number of bytes copied</returns>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.CopyMatrix``1(``0[][],System.IntPtr)">
            <summary>
            Copy a jagged two dimensional array to the unmanaged memory
            </summary>
            <typeparam name="TData">The data type of the jagged two dimensional</typeparam>
            <param name="source">The source array</param>
            <param name="dest">Pointer to the destination unmanaged memory</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.CopyMatrix``1(System.IntPtr,``0[][])">
            <summary>
            Copy a jagged two dimensional array from the unmanaged memory
            </summary>
            <typeparam name="D">The data type of the jagged two dimensional</typeparam>
            <param name="src">The src array</param>
            <param name="dest">Pointer to the destination unmanaged memory</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.Memcpy(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            memcpy function
            </summary>
            <param name="dest">the destination of memory copy</param>
            <param name="src">the source of memory copy</param>
            <param name="len">the number of bytes to be copied</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetColorCvtCode(System.Type,System.Type)">
            <summary>
            Given the source and destination color type, compute the color conversion code for CvInvoke.cvCvtColor function
            </summary>
            <param name="srcColorType">The source color type. Must be a type inherited from IColor</param>
            <param name="destColorType">The dest color type. Must be a type inherited from IColor</param>
            <returns>The color conversion code for CvInvoke.cvCvtColor function</returns>
        </member>
        <member name="T:Emgu.CV.Util.DataLogger">
            <summary>
            A DataLogger for unmanaged code to log data back to managed code, using callback.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger.#ctor(System.Int32)">
            <summary>
            Create a MessageLogger and register the callback function
            </summary>
            <param name="logLevel">The log level.</param>
        </member>
        <member name="E:Emgu.CV.Util.DataLogger.OnDataReceived">
            <summary>
            The event that will be raised when the unmanaged code send over data
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger.Log(System.IntPtr,System.Int32)">
            <summary>
            Log some data
            </summary>
            <param name="data">Pointer to some unmanaged data</param>
            <param name="logLevel">The logLevel. The Log function only logs when the <paramref name="logLevel"/> is greater or equals to the DataLogger's logLevel</param>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger.DisposeObject">
            <summary>
            Release the DataLogger and all the unmanaged memory associated with it.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.DataLogger`1">
            <summary>
            A generic version of the DataLogger
            </summary>
            <typeparam name="T">The supported type includes System.String and System.ValueType</typeparam>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.#ctor(System.Int32)">
            <summary>
            Create a new DataLogger
            </summary>
            <param name="logLevel">The log level.</param>
        </member>
        <member name="E:Emgu.CV.Util.DataLogger`1.OnDataReceived">
            <summary>
            The event that will be raised when the unmanaged code send over data
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.Log(`0,System.Int32)">
            <summary>
            Log some data
            </summary>
            <param name="data">The data to be logged</param>
            <param name="logLevel">The logLevel. The Log function only logs when the <paramref name="logLevel"/> is greater or equals to the DataLogger's logLevel</param>
        </member>
        <member name="P:Emgu.CV.Util.DataLogger`1.Ptr">
            <summary>
            Pointer to the unmanaged object
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.op_Implicit(Emgu.CV.Util.DataLogger{`0})~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="obj">The DataLogger</param>
            <returns>The unmanaged pointer for this DataLogger</returns>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this DataLogger
            </summary>
        </member>
        <member name="E:Emgu.CV.Util.DataLoggerHelper.OnDataReceived">
            <summary>
            The event that will be raised when the unmanaged code send over data
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.SharedPtrObject">
            <summary>
            An Unmanaged Object is a disposable object with a Ptr property pointing to the unmanaged object
            </summary>
        </member>
        <member name="F:Emgu.CV.Util.SharedPtrObject._sharedPtr">
            <summary>
            A pointer to the shared pointer to the unmanaged object
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.SharedPtrObject.SharedPtr">
            <summary>
            Pointer to the shared pointer to the unmanaged object
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.StructSize">
            <summary>
            Cache the size of various header in bytes
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.PointF">
            <summary>
            The size of PointF
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.RangF">
            <summary>
            The size of RangF
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvPoint2D64f">
            <summary>
            The size of PointF
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvMat">
            <summary>
            The size of MCvMat
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MIplImage">
            <summary>
            The size of IplImage
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvPoint3D32f">
            <summary>
            The size of MCvPoint3D32f
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvMatND">
            <summary>
            The size of MCvMatND
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.TbbTaskScheduler">
            <summary>
            This class canbe used to initiate TBB. Only usefull if it is compiled with TBB support
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.TbbTaskScheduler.#ctor">
            <summary>
            Initialize the TBB task scheduler
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.TbbTaskScheduler.DisposeObject">
            <summary>
            Release the TBB task scheduler
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.UnmanagedVector">
            <summary>
            Wrapped class of the C++ standard vector of Byte.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.UnmanagedVector.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.UnmanagedVector.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.UnmanagedVector.Position">
            <inheritdoc/>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emgu.CV.Util.UnmanagedVector.Length">
            <inheritdoc/>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="P:Emgu.CV.Util.UnmanagedVector.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Emgu.CV.Util.UnmanagedVector.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Emgu.CV.Util.UnmanagedVector.CanSeek">
            <inheritdoc/>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.Flush">
            <inheritdoc/>
        </member>
        <member name="F:Emgu.CV.Util.UnmanagedVector._disposed">
            <summary> Track whether Dispose has been called. </summary>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.Dispose">
            <summary>
            The dispose function that implements IDisposable interface
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.Dispose(System.Boolean)">
            <summary> 
            Dispose(bool disposing) executes in two distinct scenarios.
            If disposing equals true, the method has been called directly
            or indirectly by a user's code. Managed and unmanaged resources
            can be disposed.
            If disposing equals false, the method has been called by the
            runtime from inside the finalizer and you should not reference
            other objects. Only unmanaged resources can be disposed.
            </summary>
            <param name="disposing"> If disposing equals false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed. </param>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.ReleaseManagedResources">
            <summary>
            Release the managed resources. This function will be called during the disposal of the current object.
            override ride this function if you need to call the Dispose() function on any managed IDisposable object created by the current object
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="F:Emgu.CV.Util.UnmanagedVector._ptr">
            <summary>
            A pointer to the unmanaged object
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.UnmanagedVector.Ptr">
            <summary>
            Pointer to the unmanaged object
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.UnmanagedVector.op_Implicit(Emgu.CV.Util.UnmanagedVector)~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="obj">The UnmanagedObject</param>
            <returns>The unmanaged pointer for this object</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfByte">
            <summary>
            Wrapped class of the C++ standard vector of Byte.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor">
            <summary>
            Create an empty standard vector of Byte
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Int32)">
            <summary>
            Create a standard vector of Byte of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Byte[])">
            <summary>
            Create a standard vector of Byte with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.Push(System.Byte[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.Push(Emgu.CV.Util.VectorOfByte)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.ToArray">
            <summary>
            Convert the standard vector to an array of Byte
            </summary>
            <returns>An array of Byte</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Span{System.Byte})">
            <summary>
            Create a standard vector of Byte with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.Push(System.Span{System.Byte})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfColorPoint">
            <summary>
            Wrapped class of the C++ standard vector of ColorPoint.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.#ctor">
            <summary>
            Create an empty standard vector of ColorPoint
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.#ctor(System.Int32)">
            <summary>
            Create a standard vector of ColorPoint of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.#ctor(Emgu.CV.Structure.ColorPoint[])">
            <summary>
            Create a standard vector of ColorPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.Push(Emgu.CV.Structure.ColorPoint[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.Push(Emgu.CV.Util.VectorOfColorPoint)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.ToArray">
            <summary>
            Convert the standard vector to an array of ColorPoint
            </summary>
            <returns>An array of ColorPoint</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.#ctor(System.Span{Emgu.CV.Structure.ColorPoint})">
            <summary>
            Create a standard vector of ColorPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.Push(System.Span{Emgu.CV.Structure.ColorPoint})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfColorPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfColorPoint.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfColorPoint.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfColorPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfColorPoint.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfCvString">
            <summary>
            Wrapped class of the C++ standard vector of CvString.
            </summary>
            <summary>
            Wrapped class of the C++ standard vector of CvString.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor">
            <summary>
            Create an empty standard vector of CvString
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor(System.Int32)">
            <summary>
            Create an standard vector of CvString of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor(Emgu.CV.CvString[])">
            <summary>
            Create an standard vector of CvString with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Push(Emgu.CV.CvString)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Push(Emgu.CV.CvString[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Push(Emgu.CV.Util.VectorOfCvString)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.ToArray">
            <summary>
            Convert the standard vector to an array of String
            </summary>
            <returns>An array of String</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor(System.String[])">
            <summary>
            Create a VectorOfCvString object from an array of String
            </summary>
            <param name="strings">The strings to be placed in this VectorOfCvString</param>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfDMatch">
            <summary>
            Wrapped class of the C++ standard vector of DMatch.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor">
            <summary>
            Create an empty standard vector of DMatch
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(System.Int32)">
            <summary>
            Create a standard vector of DMatch of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(Emgu.CV.Structure.MDMatch[])">
            <summary>
            Create a standard vector of DMatch with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.Push(Emgu.CV.Structure.MDMatch[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.Push(Emgu.CV.Util.VectorOfDMatch)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.ToArray">
            <summary>
            Convert the standard vector to an array of DMatch
            </summary>
            <returns>An array of DMatch</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(System.Span{Emgu.CV.Structure.MDMatch})">
            <summary>
            Create a standard vector of DMatch with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.Push(System.Span{Emgu.CV.Structure.MDMatch})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfDouble">
            <summary>
            Wrapped class of the C++ standard vector of Double.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor">
            <summary>
            Create an empty standard vector of Double
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Int32)">
            <summary>
            Create a standard vector of Double of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Double[])">
            <summary>
            Create a standard vector of Double with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.Push(System.Double[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.Push(Emgu.CV.Util.VectorOfDouble)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.ToArray">
            <summary>
            Convert the standard vector to an array of Double
            </summary>
            <returns>An array of Double</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Span{System.Double})">
            <summary>
            Create a standard vector of Double with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.Push(System.Span{System.Double})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfFloat">
            <summary>
            Wrapped class of the C++ standard vector of Float.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor">
            <summary>
            Create an empty standard vector of Float
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Int32)">
            <summary>
            Create a standard vector of Float of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Single[])">
            <summary>
            Create a standard vector of Float with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.Push(System.Single[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.Push(Emgu.CV.Util.VectorOfFloat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.ToArray">
            <summary>
            Convert the standard vector to an array of Float
            </summary>
            <returns>An array of Float</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Span{System.Single})">
            <summary>
            Create a standard vector of Float with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.Push(System.Span{System.Single})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfGMat">
            <summary>
            Wrapped class of the C++ standard vector of GMat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfGMat.#ctor">
            <summary>
            Create an empty standard vector of GMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfGMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of GMat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfGMat.#ctor(Emgu.CV.GMat[])">
            <summary>
            Create an standard vector of GMat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfGMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfGMat.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfGMat.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfGMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfGMat.Push(Emgu.CV.GMat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfGMat.Push(Emgu.CV.GMat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfGMat.Push(Emgu.CV.Util.VectorOfGMat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfGMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfGMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfGMat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfInt">
            <summary>
            Wrapped class of the C++ standard vector of Int.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor">
            <summary>
            Create an empty standard vector of Int
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Int32)">
            <summary>
            Create a standard vector of Int of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Int32[])">
            <summary>
            Create a standard vector of Int with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.Push(System.Int32[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.Push(Emgu.CV.Util.VectorOfInt)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.ToArray">
            <summary>
            Convert the standard vector to an array of Int
            </summary>
            <returns>An array of Int</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Span{System.Int32})">
            <summary>
            Create a standard vector of Int with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.Push(System.Span{System.Int32})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfIntPtr">
            <summary>
            Wrapped class of the C++ standard vector of IntPtr.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.#ctor">
            <summary>
            Create an empty standard vector of IntPtr
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.#ctor(System.Int32)">
            <summary>
            Create a standard vector of IntPtr of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.#ctor(System.IntPtr[])">
            <summary>
            Create a standard vector of IntPtr with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.Push(System.IntPtr[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.Push(Emgu.CV.Util.VectorOfIntPtr)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.ToArray">
            <summary>
            Convert the standard vector to an array of IntPtr
            </summary>
            <returns>An array of IntPtr</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.#ctor(System.Span{System.IntPtr})">
            <summary>
            Create a standard vector of IntPtr with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.Push(System.Span{System.IntPtr})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfIntPtr.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfIntPtr.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfIntPtr.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfIntPtr.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfIntPtr.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfIntPtr.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfKeyPoint">
            <summary>
            Wrapped class of the C++ standard vector of KeyPoint.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor">
            <summary>
            Create an empty standard vector of KeyPoint
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(System.Int32)">
            <summary>
            Create a standard vector of KeyPoint of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(Emgu.CV.Structure.MKeyPoint[])">
            <summary>
            Create a standard vector of KeyPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.Push(Emgu.CV.Structure.MKeyPoint[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.Push(Emgu.CV.Util.VectorOfKeyPoint)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.ToArray">
            <summary>
            Convert the standard vector to an array of KeyPoint
            </summary>
            <returns>An array of KeyPoint</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(System.Span{Emgu.CV.Structure.MKeyPoint})">
            <summary>
            Create a standard vector of KeyPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.Push(System.Span{Emgu.CV.Structure.MKeyPoint})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.FilterByImageBorder(System.Drawing.Size,System.Int32)">
            <summary>
            Remove keypoints within borderPixels of an image edge.
            </summary>
            <param name="imageSize">Image size</param>
            <param name="borderSize">Border size in pixel</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.FilterByKeypointSize(System.Single,System.Single)">
            <summary>
            Remove keypoints of sizes out of range.
            </summary>
            <param name="minSize">Minimum size</param>
            <param name="maxSize">Maximum size</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.FilterByPixelsMask(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Remove keypoints from some image by mask for pixels of this image.
            </summary>
            <param name="mask">The mask</param>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfMat">
            <summary>
            Wrapped class of the C++ standard vector of Mat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.#ctor">
            <summary>
            Create an empty standard vector of Mat
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Mat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.#ctor(Emgu.CV.Mat[])">
            <summary>
            Create an standard vector of Mat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push(Emgu.CV.Mat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push(Emgu.CV.Mat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push(Emgu.CV.Util.VectorOfMat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push``1(Emgu.CV.CvArray{``0})">
            <summary>
            Convert a CvArray to Mat and push it into the vector
            </summary>
            <typeparam name="TDepth">The type of depth of the cvArray</typeparam>
            <param name="cvArray">The cvArray to be pushed into the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push``1(Emgu.CV.CvArray{``0}[])">
            <summary>
            Convert a group of CvArray to Mat and push them into the vector
            </summary>
            <typeparam name="TDepth">The type of depth of the cvArray</typeparam>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfOclPlatformInfo">
            <summary>
            Wrapped class of the C++ standard vector of OclPlatformInfo.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.#ctor">
            <summary>
            Create an empty standard vector of OclPlatformInfo
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.#ctor(System.Int32)">
            <summary>
            Create an standard vector of OclPlatformInfo of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.#ctor(Emgu.CV.Ocl.PlatformInfo[])">
            <summary>
            Create an standard vector of OclPlatformInfo with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Push(Emgu.CV.Ocl.PlatformInfo)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Push(Emgu.CV.Ocl.PlatformInfo[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Push(Emgu.CV.Util.VectorOfOclPlatformInfo)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfPoint">
            <summary>
            Wrapped class of the C++ standard vector of Point.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor">
            <summary>
            Create an empty standard vector of Point
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Int32)">
            <summary>
            Create a standard vector of Point of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Drawing.Point[])">
            <summary>
            Create a standard vector of Point with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.Push(System.Drawing.Point[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.Push(Emgu.CV.Util.VectorOfPoint)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.ToArray">
            <summary>
            Convert the standard vector to an array of Point
            </summary>
            <returns>An array of Point</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Span{System.Drawing.Point})">
            <summary>
            Create a standard vector of Point with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.Push(System.Span{System.Drawing.Point})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfPoint3D32F">
            <summary>
            Wrapped class of the C++ standard vector of Point3D32F.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor">
            <summary>
            Create an empty standard vector of Point3D32F
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(System.Int32)">
            <summary>
            Create a standard vector of Point3D32F of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(Emgu.CV.Structure.MCvPoint3D32f[])">
            <summary>
            Create a standard vector of Point3D32F with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.Push(Emgu.CV.Structure.MCvPoint3D32f[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfPoint3D32F)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.ToArray">
            <summary>
            Convert the standard vector to an array of Point3D32F
            </summary>
            <returns>An array of Point3D32F</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(System.Span{Emgu.CV.Structure.MCvPoint3D32f})">
            <summary>
            Create a standard vector of Point3D32F with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.Push(System.Span{Emgu.CV.Structure.MCvPoint3D32f})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfPointF">
            <summary>
            Wrapped class of the C++ standard vector of PointF.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor">
            <summary>
            Create an empty standard vector of PointF
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Int32)">
            <summary>
            Create a standard vector of PointF of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Drawing.PointF[])">
            <summary>
            Create a standard vector of PointF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.Push(System.Drawing.PointF[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.Push(Emgu.CV.Util.VectorOfPointF)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.ToArray">
            <summary>
            Convert the standard vector to an array of PointF
            </summary>
            <returns>An array of PointF</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Span{System.Drawing.PointF})">
            <summary>
            Create a standard vector of PointF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.Push(System.Span{System.Drawing.PointF})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfRect">
            <summary>
            Wrapped class of the C++ standard vector of Rect.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor">
            <summary>
            Create an empty standard vector of Rect
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Int32)">
            <summary>
            Create a standard vector of Rect of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Drawing.Rectangle[])">
            <summary>
            Create a standard vector of Rect with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.Push(System.Drawing.Rectangle[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.Push(Emgu.CV.Util.VectorOfRect)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.ToArray">
            <summary>
            Convert the standard vector to an array of Rect
            </summary>
            <returns>An array of Rect</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Span{System.Drawing.Rectangle})">
            <summary>
            Create a standard vector of Rect with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.Push(System.Span{System.Drawing.Rectangle})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfRotatedRect">
            <summary>
            Wrapped class of the C++ standard vector of RotatedRect.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.#ctor">
            <summary>
            Create an empty standard vector of RotatedRect
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.#ctor(System.Int32)">
            <summary>
            Create a standard vector of RotatedRect of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.#ctor(Emgu.CV.Structure.RotatedRect[])">
            <summary>
            Create a standard vector of RotatedRect with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.Push(Emgu.CV.Structure.RotatedRect[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.Push(Emgu.CV.Util.VectorOfRotatedRect)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.ToArray">
            <summary>
            Convert the standard vector to an array of RotatedRect
            </summary>
            <returns>An array of RotatedRect</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.#ctor(System.Span{Emgu.CV.Structure.RotatedRect})">
            <summary>
            Create a standard vector of RotatedRect with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.Push(System.Span{Emgu.CV.Structure.RotatedRect})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRotatedRect.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRotatedRect.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRotatedRect.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRotatedRect.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRotatedRect.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRotatedRect.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfSize">
            <summary>
            Wrapped class of the C++ standard vector of Size.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.#ctor">
            <summary>
            Create an empty standard vector of Size
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.#ctor(System.Int32)">
            <summary>
            Create a standard vector of Size of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.#ctor(System.Drawing.Size[])">
            <summary>
            Create a standard vector of Size with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.Push(System.Drawing.Size[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.Push(Emgu.CV.Util.VectorOfSize)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.ToArray">
            <summary>
            Convert the standard vector to an array of Size
            </summary>
            <returns>An array of Size</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.#ctor(System.Span{System.Drawing.Size})">
            <summary>
            Create a standard vector of Size with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.Push(System.Span{System.Drawing.Size})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfSize.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfSize.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfSize.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfSize.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfSize.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfSize.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfTriangle2DF">
            <summary>
            Wrapped class of the C++ standard vector of Triangle2DF.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor">
            <summary>
            Create an empty standard vector of Triangle2DF
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(System.Int32)">
            <summary>
            Create a standard vector of Triangle2DF of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(Emgu.CV.Structure.Triangle2DF[])">
            <summary>
            Create a standard vector of Triangle2DF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.Push(Emgu.CV.Structure.Triangle2DF[])">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.Push(Emgu.CV.Util.VectorOfTriangle2DF)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.ToArray">
            <summary>
            Convert the standard vector to an array of Triangle2DF
            </summary>
            <returns>An array of Triangle2DF</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(System.Span{Emgu.CV.Structure.Triangle2DF})">
            <summary>
            Create a standard vector of Triangle2DF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.Push(System.Span{Emgu.CV.Structure.Triangle2DF})">
            <summary>
            Push an array of values into the standard vector
            </summary>
            <param name="values">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetSpan">
            <summary>
            Returns a memory span that wraps the underlying memory buffer.
            </summary>
            <returns>A memory span that wraps the underlying memory buffer.</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetInputArray">
            <summary>
            Get the data as InputArray
            </summary>
            <returns>The input array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetOutputArray">
            <summary>
            Get the data as OutputArray
            </summary>
            <returns>The output array </returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetInputOutputArray">
            <summary>
            Get the data as InputOutputArray
            </summary>
            <returns>The input output array </returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfUMat">
            <summary>
            Wrapped class of the C++ standard vector of UMat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.#ctor">
            <summary>
            Create an empty standard vector of UMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of UMat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.#ctor(Emgu.CV.UMat[])">
            <summary>
            Create an standard vector of UMat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Push(Emgu.CV.UMat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Push(Emgu.CV.UMat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Push(Emgu.CV.Util.VectorOfUMat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfByte">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfByte.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.#ctor">
            <summary>
            Create an empty standard vector of VectorOfByte
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfByte of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.#ctor(Emgu.CV.Util.VectorOfByte[])">
            <summary>
            Create an standard vector of VectorOfByte with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfByte.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfByte.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfByte.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.Push(Emgu.CV.Util.VectorOfByte)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.Push(Emgu.CV.Util.VectorOfByte[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.Push(Emgu.CV.Util.VectorOfVectorOfByte)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfByte.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfByte.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.#ctor(System.Byte[][])">
            <summary>
            Create the standard vector of VectorOfByte 
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfByte.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of arrays of Byte
            </summary>
            <returns>Arrays of arrays of the Byte</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfDMatch">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfDMatch.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor">
            <summary>
            Create an empty standard vector of VectorOfDMatch
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfDMatch of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor(Emgu.CV.Util.VectorOfDMatch[])">
            <summary>
            Create an standard vector of VectorOfDMatch with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Push(Emgu.CV.Util.VectorOfDMatch)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Push(Emgu.CV.Util.VectorOfDMatch[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Push(Emgu.CV.Util.VectorOfVectorOfDMatch)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor(Emgu.CV.Structure.MDMatch[][])">
            <summary>
            Create the standard vector of VectorOfDMatch 
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of arrays of MDMatch
            </summary>
            <returns>Arrays of arrays of the MDMatch</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfInt">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfInt.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor">
            <summary>
            Create an empty standard vector of VectorOfInt
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfInt of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor(Emgu.CV.Util.VectorOfInt[])">
            <summary>
            Create an standard vector of VectorOfInt with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Push(Emgu.CV.Util.VectorOfInt)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Push(Emgu.CV.Util.VectorOfInt[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Push(Emgu.CV.Util.VectorOfVectorOfInt)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor(System.Int32[][])">
            <summary>
            Create the standard vector of VectorOfInt 
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of arrays of int
            </summary>
            <returns>Arrays of arrays of the int</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfMat">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfMat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfMat.#ctor">
            <summary>
            Create an empty standard vector of VectorOfMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfMat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfMat.#ctor(Emgu.CV.Util.VectorOfMat[])">
            <summary>
            Create an standard vector of VectorOfMat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfMat.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfMat.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfMat.Push(Emgu.CV.Util.VectorOfMat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfMat.Push(Emgu.CV.Util.VectorOfMat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfMat.Push(Emgu.CV.Util.VectorOfVectorOfMat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfMat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfPoint">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfPoint.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor">
            <summary>
            Create an empty standard vector of VectorOfPoint
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfPoint of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor(Emgu.CV.Util.VectorOfPoint[])">
            <summary>
            Create an standard vector of VectorOfPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Push(Emgu.CV.Util.VectorOfPoint)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Push(Emgu.CV.Util.VectorOfPoint[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Push(Emgu.CV.Util.VectorOfVectorOfPoint)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor(System.Drawing.Point[][])">
            <summary>
            Create the standard vector of VectorOfPoint 
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of arrays of Point
            </summary>
            <returns>Arrays of arrays of the Point</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfPoint3D32F">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfPoint3D32F.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor">
            <summary>
            Create an empty standard vector of VectorOfPoint3D32F
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfPoint3D32F of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor(Emgu.CV.Util.VectorOfPoint3D32F[])">
            <summary>
            Create an standard vector of VectorOfPoint3D32F with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfPoint3D32F)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfPoint3D32F[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfVectorOfPoint3D32F)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor(Emgu.CV.Structure.MCvPoint3D32f[][])">
            <summary>
            Create the standard vector of VectorOfPoint3D32F 
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of arrays of MCvPoint3D32f
            </summary>
            <returns>Arrays of arrays of the MCvPoint3D32f</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfPointF">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfPointF.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor">
            <summary>
            Create an empty standard vector of VectorOfPointF
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfPointF of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor(Emgu.CV.Util.VectorOfPointF[])">
            <summary>
            Create an standard vector of VectorOfPointF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Push(Emgu.CV.Util.VectorOfPointF)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Push(Emgu.CV.Util.VectorOfPointF[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Push(Emgu.CV.Util.VectorOfVectorOfPointF)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor(System.Drawing.PointF[][])">
            <summary>
            Create the standard vector of VectorOfPointF 
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of arrays of PointF
            </summary>
            <returns>Arrays of arrays of the PointF</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfRect">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfRect.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.#ctor">
            <summary>
            Create an empty standard vector of VectorOfRect
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfRect of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.#ctor(Emgu.CV.Util.VectorOfRect[])">
            <summary>
            Create an standard vector of VectorOfRect with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfRect.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfRect.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfRect.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.Push(Emgu.CV.Util.VectorOfRect)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.Push(Emgu.CV.Util.VectorOfRect[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.Push(Emgu.CV.Util.VectorOfVectorOfRect)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfRect.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
            <returns>The input array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
            <returns>The output array</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
            <returns>The input output array</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfRect.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.#ctor(System.Drawing.Rectangle[][])">
            <summary>
            Create the standard vector of VectorOfRect 
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfRect.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of arrays of Rectangle
            </summary>
            <returns>Arrays of arrays of the Rectangle</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVideoCapture">
            <summary>
            Wrapped class of the C++ standard vector of VideoCapture.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVideoCapture.#ctor">
            <summary>
            Create an empty standard vector of VideoCapture
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVideoCapture.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VideoCapture of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVideoCapture.#ctor(Emgu.CV.VideoCapture[])">
            <summary>
            Create an standard vector of VideoCapture with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVideoCapture.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVideoCapture.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVideoCapture.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVideoCapture.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVideoCapture.Push(Emgu.CV.VideoCapture)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVideoCapture.Push(Emgu.CV.VideoCapture[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVideoCapture.Push(Emgu.CV.Util.VectorOfVideoCapture)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVideoCapture.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVideoCapture.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVideoCapture.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.ZlibCompression">
            <summary>
            Use zlib included in OpenCV to perform in-memory binary compression and decompression
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.ZlibCompression.Compress(System.Byte[],System.Int32)">
            <summary>
            Compress the data using the specific compression level
            </summary>
            <param name="original">The data to be compressed</param>
            <param name="compressionLevel">The compression level, 0-9 where 0 mean no compression at all</param>
            <returns>The compressed bytes</returns>
        </member>
        <member name="M:Emgu.CV.Util.ZlibCompression.Uncompress(System.Byte[],System.Int32)">
            <summary>
            Uncompress the data 
            </summary>
            <param name="compressedData">The compressed data</param>
            <param name="estimatedUncompressedSize">The estimated size fo the uncompress data. Must be large enough to hold the decompressed data.</param>
            <returns>The decompressed data</returns>
        </member>
        <member name="T:Emgu.CV.Stitching.VectorOfCameraParams">
            <summary>
            Wrapped class of the C++ standard vector of CameraParams.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.VectorOfCameraParams.#ctor">
            <summary>
            Create an empty standard vector of CameraParams
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.VectorOfCameraParams.#ctor(System.Int32)">
            <summary>
            Create an standard vector of CameraParams of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Stitching.VectorOfCameraParams.#ctor(Emgu.CV.Stitching.CameraParams[])">
            <summary>
            Create an standard vector of CameraParams with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="P:Emgu.CV.Stitching.VectorOfCameraParams.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.VectorOfCameraParams.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.VectorOfCameraParams.Length">
            <summary>
            The size of memory in bytes, that is needed to hold all the items in this vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.VectorOfCameraParams.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.VectorOfCameraParams.Push(Emgu.CV.Stitching.CameraParams)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Stitching.VectorOfCameraParams.Push(Emgu.CV.Stitching.CameraParams[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Stitching.VectorOfCameraParams.Push(Emgu.CV.Stitching.VectorOfCameraParams)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="P:Emgu.CV.Stitching.VectorOfCameraParams.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.VectorOfCameraParams.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.VectorOfCameraParams.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.Blender">
            <summary>
            Blender for Image Stitching
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Blender._blenderPtr">
            <summary>
            Pointer to the native Blender object.
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Blender.BlenderPtr">
            <summary>
            Pointer to the native Blender object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.Blender.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.Blender.Prepare(System.Drawing.Point[],System.Drawing.Size[])">
            <summary>
            Prepares the blender for blending.
            </summary>
            <param name="corners">Source images top-left corners</param>
            <param name="sizes">Source image sizes</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Blender.Prepare(System.Drawing.Rectangle)">
            <summary>
            Prepares the blender for blending.
            </summary>
            <param name="dstRoi">Destination roi</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Blender.Feed(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Point)">
            <summary>
            Processes the image.
            </summary>
            <param name="img">Source image</param>
            <param name="mask">Source image mask</param>
            <param name="tl">Source image top-left corners</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Blender.Blend(Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray)">
            <summary>
            Blends and returns the final pano.
            </summary>
            <param name="dst">Final pano</param>
            <param name="dstMask">Final pano mask</param>
        </member>
        <member name="T:Emgu.CV.Stitching.StitchingInvoke">
            <summary>
            Entry points to the Open CV Stitching module.
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.BundleAdjusterBase">
            <summary>
            Base class for all camera parameters refinement methods.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.BundleAdjusterBase._bundleAdjusterPtr">
            <summary>
            Pointer to the native BundleAdjusterBase object.
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.BundleAdjusterBase.BundleAdjusterPtr">
            <summary>
            Pointer to the native BundleAdjusterBase object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BundleAdjusterBase.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.NoBundleAdjuster">
            <summary>
            Stub bundle adjuster that does nothing.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.NoBundleAdjuster.#ctor">
            <summary>
            Create a stub bundle adjuster that does nothing.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.NoBundleAdjuster.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this bundle adjuster
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.BundleAdjusterReproj">
            <summary>
            Implementation of the camera parameters refinement algorithm which minimizes sum of the reprojection
            error squares.
            It can estimate focal length, aspect ratio, principal point.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BundleAdjusterReproj.#ctor">
            <summary>
            Create an implementation of the camera parameters refinement algorithm which minimizes sum of the reprojection
            error squares.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BundleAdjusterReproj.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this bundle adjuster
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.BundleAdjusterRay">
            <summary>
            Implementation of the camera parameters refinement algorithm which minimizes sum of the distances between the rays passing through the camera center and a feature.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BundleAdjusterRay.#ctor">
            <summary>
            Create a new bundle adjuster
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BundleAdjusterRay.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this bundle adjuster
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.BundleAdjusterAffine">
            <summary>
            Bundle adjuster that expects affine transformation represented in homogeneous coordinates in R for each camera param. Implements camera parameters refinement algorithm which minimizes sum of the reprojection error squares.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BundleAdjusterAffine.#ctor">
            <summary>
            Create a new Bundle adjuster.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BundleAdjusterAffine.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this bundle adjuster
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.BundleAdjusterAffinePartial">
            <summary>
            Bundle adjuster that expects affine transformation with 4 DOF represented in homogeneous coordinates in R for each camera param. Implements camera parameters refinement algorithm which minimizes sum of the reprojection error squares.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BundleAdjusterAffinePartial.#ctor">
            <summary>
            Create a new affine bundler adjuster
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BundleAdjusterAffinePartial.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this bundle adjuster
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.CameraParams">
            <summary>
            Camera parameters used for stitching.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CameraParams.#ctor">
            <summary>
            Create a default camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CameraParams.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CameraParams.K">
            <summary>
            Construct the camera calibration matrix using the camera parameters
            </summary>
            <returns>The camera calibration matrix</returns>
        </member>
        <member name="P:Emgu.CV.Stitching.CameraParams.Focal">
            <summary>
            The focal length
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.CameraParams.Aspect">
            <summary>
            The aspect ratio
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.CameraParams.Ppx">
            <summary>
            The principal point X
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.CameraParams.Ppy">
            <summary>
            The principal point Y
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.CameraParams.R">
            <summary>
            The rotation Mat
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.Stitching.CameraParams.T">
            <summary>
            The translation Mat
            </summary>
            <returns>The result</returns>
        </member>
        <member name="T:Emgu.CV.Stitching.Estimator">
            <summary>
            Rotation estimator base class.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Estimator._estimatorPtr">
            <summary>
            Pointer to the native Estimator object.
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Estimator.EstimatorPtr">
            <summary>
            Pointer to the native Estimator object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.Estimator.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.HomographyBasedEstimator">
            <summary>
            Homography based rotation estimator.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.HomographyBasedEstimator.#ctor(System.Boolean)">
            <summary>
            Create a  new homography based rotation estimator
            </summary>
            <param name="isFocalsEstimated">Is focals estimated</param>
        </member>
        <member name="M:Emgu.CV.Stitching.HomographyBasedEstimator.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this estimator
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.AffineBasedEstimator">
            <summary>
            Affine transformation based estimator.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.AffineBasedEstimator.#ctor">
            <summary>
            Create a new affine transformation based estimator.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.AffineBasedEstimator.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this estimator
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.ExposureCompensator">
            <summary>
            Base class for all exposure compensators.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.ExposureCompensator._exposureCompensatorPtr">
            <summary>
            Pointer to the native ExposureCompensator object.
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.ExposureCompensator.ExposureCompensatorPtr">
            <summary>
            Pointer to the native ExposureCompensator object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.ExposureCompensator.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.NoExposureCompensator">
            <summary>
            Stub exposure compensator which does nothing.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.NoExposureCompensator.#ctor">
            <summary>
            Create a new stub exposure compensator which does nothing.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.NoExposureCompensator.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this exposure compensator 
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.GainCompensator">
            <summary>
            Exposure compensator which tries to remove exposure related artifacts by adjusting image intensities
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.GainCompensator.#ctor(System.Int32)">
            <summary>
            Create a new gain compensator
            </summary>
            <param name="nrFeeds">nr feeds</param>
        </member>
        <member name="M:Emgu.CV.Stitching.GainCompensator.DisposeObject">
            <summary>
            Release all unmanaged resources associated with this exposure compensator 
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.ChannelsCompensator">
            <summary>
            Exposure compensator which tries to remove exposure related artifacts by adjusting image intensities on each channel independently. 
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.ChannelsCompensator.#ctor(System.Int32)">
            <summary>
            Create a new exposure compensator
            </summary>
            <param name="nrFeeds">nr feeds</param>
        </member>
        <member name="M:Emgu.CV.Stitching.ChannelsCompensator.DisposeObject">
            <summary>
            Release all unmanaged resources associated with this exposure compensator 
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.BlocksGainCompensator">
            <summary>
            Exposure compensator which tries to remove exposure related artifacts by adjusting image block intensities
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BlocksGainCompensator.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new exposure compensator
            </summary>
            <param name="blWidth">block width</param>
            <param name="blHeight">block height</param>
            <param name="nrFeeds">nr feeds</param>
        </member>
        <member name="M:Emgu.CV.Stitching.BlocksGainCompensator.DisposeObject">
            <summary>
            Release all unmanaged resources associated with this exposure compensator 
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.BlocksChannelsCompensator">
            <summary>
            Exposure compensator which tries to remove exposure related artifacts by adjusting image block on each channel.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BlocksChannelsCompensator.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new exposure compensator
            </summary>
            <param name="blWidth">Block width</param>
            <param name="blHeight">Block height</param>
            <param name="nrFeeds">nr feeds</param>
        </member>
        <member name="M:Emgu.CV.Stitching.BlocksChannelsCompensator.DisposeObject">
            <summary>
            Release all unmanaged resources associated with this exposure compensator 
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.FeatherBlender">
            <summary>
            Simple blender which mixes images at its borders.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.FeatherBlender.#ctor(System.Single)">
            <summary>
            Create a simple blender which mixes images at its borders
            </summary>
            <param name="sharpness">Sharpness</param>
        </member>
        <member name="M:Emgu.CV.Stitching.FeatherBlender.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this blender
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.FeaturesMatcher">
            <summary>
            Features Matcher for Image Stitching
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.FeaturesMatcher._featuresMatcherPtr">
            <summary>
            Pointer to the native FeaturesMatcher object.
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.FeaturesMatcher.FeaturesMatcherPtr">
            <summary>
            Pointer to the native FeaturesMatcher object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.FeaturesMatcher.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.BestOf2NearestMatcher">
            <summary>
            Features matcher which finds two best matches for each feature and leaves the best one only if the ratio between descriptor distances is greater than the threshold match_conf.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BestOf2NearestMatcher.#ctor(System.Boolean,System.Single,System.Int32,System.Int32)">
            <summary>
            Create a new features matcher
            </summary>
            <param name="tryUseGpu">If true, will try to use gpu.</param>
            <param name="matchConf">Match confident</param>
            <param name="numMatchesThresh1">Number of matches threshold</param>
            <param name="numMatchesThresh2">Number of matches threshold</param>
        </member>
        <member name="M:Emgu.CV.Stitching.BestOf2NearestMatcher.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this blender
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.BestOf2NearestRangeMatcher">
            <summary>
            Best of 2 nearest range matcher
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.BestOf2NearestRangeMatcher.#ctor(System.Int32,System.Boolean,System.Single,System.Int32,System.Int32)">
            <summary>
            Create a new instance of BestOf2NearestRangeMatcher
            </summary>
            <param name="rangeWidth">Range width</param>
            <param name="tryUseGpu">If true, will try to use GPU</param>
            <param name="matchConf">Match confident</param>
            <param name="numMatchesThresh1">Number of matches threshold</param>
            <param name="numMatchesThresh2">Number of matches threshold</param>
        </member>
        <member name="M:Emgu.CV.Stitching.BestOf2NearestRangeMatcher.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this blender
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.AffineBestOf2NearestMatcher">
            <summary>
            Features matcher similar to BestOf2NearestMatcher which finds two best matches for each feature and leaves the best one only if the ratio between descriptor distances is greater than the threshold match_conf.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.AffineBestOf2NearestMatcher.#ctor(System.Boolean,System.Boolean,System.Single,System.Int32)">
            <summary>
            Create a new features matcher
            </summary>
            <param name="fullAffine">Full Affine</param>
            <param name="tryUseGpu">If true, will try to use gpu</param>
            <param name="matchConf">Match confident</param>
            <param name="numMatchesThresh1">Number of matches threshold</param>
        </member>
        <member name="M:Emgu.CV.Stitching.AffineBestOf2NearestMatcher.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this blender
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.MultiBandBlender">
            <summary>
            Blender which uses multi-band blending algorithm
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.MultiBandBlender.#ctor(System.Boolean,System.Int32,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Create a multiBandBlender
            </summary>
            <param name="tryGpu">If true, will try to use GPU</param>
            <param name="numBands">Number of bands</param>
            <param name="weightType">The weight type</param>
        </member>
        <member name="M:Emgu.CV.Stitching.MultiBandBlender.DisposeObject">
            <summary>
            Release all unmanaged resources associated with this blender
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.RotationWarper">
            <summary>
            Rotation-only model image warper interface.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.RotationWarper._rotationWarper">
            <summary>
            Pointer to the unmanaged RotationWarper object
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.RotationWarper.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.RotationWarper.BuildMaps(System.Drawing.Size,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Builds the projection maps according to the given camera data.
            </summary>
            <param name="srcSize">Source image size</param>
            <param name="K">Camera intrinsic parameters</param>
            <param name="R">Camera rotation matrix</param>
            <param name="xmap">Projection map for the x axis</param>
            <param name="ymap">Projection map for the y axis</param>
            <returns>Projected image minimum bounding box</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.RotationWarper.Warp(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.IOutputArray)">
            <summary>
            Projects the image.
            </summary>
            <param name="src">Source image</param>
            <param name="K">Camera intrinsic parameters</param>
            <param name="R">Camera rotation matrix</param>
            <param name="interpMode">Interpolation mode</param>
            <param name="borderMode">Border extrapolation mode</param>
            <param name="dst">Projected image</param>
            <returns>Project image top-left corner</returns>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailPlaneWarper">
            <summary>
            Warper that maps an image onto the z = 1 plane.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailPlaneWarper.#ctor(System.Single)">
            <summary>
            Construct an instance of the plane warper class.
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailPlaneWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailCylindricalWarper">
            <summary>
            Warper that maps an image onto the x\*x + z\*z = 1 cylinder.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailCylindricalWarper.#ctor(System.Single)">
            <summary>
            Construct an instance of the cylindrical warper class.
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailCylindricalWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailSphericalWarper">
            <summary>
            Warper that maps an image onto the unit sphere located at the origin.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailSphericalWarper.#ctor(System.Single)">
            <summary>
            Construct an instance of the spherical warper class.
            </summary>
            <param name="scale">Radius of the projected sphere, in pixels. An image spanning the whole sphere will have a width of 2 * scale * PI pixels.</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailSphericalWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailFisheyeWarper">
            <summary>
            Fisheye Warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailFisheyeWarper.#ctor(System.Single)">
            <summary>
            Create a fisheye warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailFisheyeWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailStereographicWarper">
            <summary>
            Stereographic Warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailStereographicWarper.#ctor(System.Single)">
            <summary>
            Create a stereographic warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailStereographicWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailCompressedRectilinearWarper">
            <summary>
            Compressed rectilinear warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailCompressedRectilinearWarper.#ctor(System.Single)">
            <summary>
            Create a compressed rectilinear warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailCompressedRectilinearWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailPaniniWarper">
            <summary>
            Panini warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailPaniniWarper.#ctor(System.Single)">
            <summary>
            Create a Panini warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailPaniniWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailPaniniPortraitWarper">
            <summary>
            Panini portrait warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailPaniniPortraitWarper.#ctor(System.Single)">
            <summary>
            Create a panini portrait warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailPaniniPortraitWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailMercatorWarper">
            <summary>
            Mercator warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailMercatorWarper.#ctor(System.Single)">
            <summary>
            Create a Mercator Warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailMercatorWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailTransverseMercatorWarper">
            <summary>
            Transverse mercator warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailTransverseMercatorWarper.#ctor(System.Single)">
            <summary>
            Create a transverse mercator warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailTransverseMercatorWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailPlaneWarperGpu">
            <summary>
            Warper that maps an image onto the z = 1 plane.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailPlaneWarperGpu.#ctor(System.Single)">
            <summary>
            Construct an instance of the plane warper class.
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailPlaneWarperGpu.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailCylindricalWarperGpu">
            <summary>
            Warper that maps an image onto the x\*x + z\*z = 1 cylinder.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailCylindricalWarperGpu.#ctor(System.Single)">
            <summary>
            Construct an instance of the cylindrical warper class.
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailCylindricalWarperGpu.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DetailSphericalWarperGpu">
            <summary>
            Warper that maps an image onto the unit sphere located at the origin.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailSphericalWarperGpu.#ctor(System.Single)">
            <summary>
            Construct an instance of the spherical warper class.
            </summary>
            <param name="scale">Radius of the projected sphere, in pixels. An image spanning the whole sphere will have a width of 2 * scale * PI pixels.</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DetailSphericalWarperGpu.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.SeamFinder">
            <summary>
            Base class for a seam estimator.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.SeamFinder._seamFinderPtr">
            <summary>
            Pointer to the native SeamFinder object.
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.SeamFinder.SeamFinderPtr">
            <summary>
            Get the pointer to the native SeamFinder object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.SeamFinder.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.NoSeamFinder">
            <summary>
            Stub seam estimator which does nothing.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.NoSeamFinder.#ctor">
            <summary>
            Create a stub seam estimator which does nothing.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.NoSeamFinder.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this seam finder
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.VoronoiSeamFinder">
            <summary>
            Voronoi diagram-based seam estimator.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.VoronoiSeamFinder.#ctor">
            <summary>
            Create a new Voronoi diagram-based seam estimator
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.VoronoiSeamFinder.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this seam finder
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DpSeamFinder">
            <summary>
            Dp Seam Finder
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.DpSeamFinder.CostFunction">
            <summary>
            The cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.DpSeamFinder.CostFunction.Color">
            <summary>
            Color
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.DpSeamFinder.CostFunction.ColorGrad">
            <summary>
            Color Grad
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.DpSeamFinder.#ctor(Emgu.CV.Stitching.DpSeamFinder.CostFunction)">
            <summary>
            Create a new DP Seam Finder
            </summary>
            <param name="costFunc">The cost function</param>
        </member>
        <member name="M:Emgu.CV.Stitching.DpSeamFinder.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this seam finder
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.GraphCutSeamFinder">
            <summary>
            Minimum graph cut-based seam estimator.
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.GraphCutSeamFinder.CostFunction">
            <summary>
            The cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.GraphCutSeamFinder.CostFunction.Color">
            <summary>
            The color
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.GraphCutSeamFinder.CostFunction.ColorGrad">
            <summary>
            The color grad
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.GraphCutSeamFinder.#ctor(Emgu.CV.Stitching.GraphCutSeamFinder.CostFunction,System.Single,System.Single)">
            <summary>
            Create a new minimum graph cut-based seam estimator.
            </summary>
            <param name="costFunc">The cost function</param>
            <param name="terminalCost">The terminal cost</param>
            <param name="badRegionPenalty">Bad Region penalty</param>
        </member>
        <member name="M:Emgu.CV.Stitching.GraphCutSeamFinder.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this seam finder
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.Stitcher">
            <summary>
            Image Stitching.
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.Stitcher.Status">
            <summary>
            The stitcher statis
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Status.Ok">
            <summary>
            Ok.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Status.ErrNeedMoreImgs">
            <summary>
            Error, need more images.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Status.ErrHomographyEstFail">
            <summary>
            Error, homography estimation failed.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Status.ErrCameraParamsAdjustFail">
            <summary>
            Error, camera parameters adjustment failed.
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.Stitcher.WaveCorrectionType">
            <summary>
            Wave correction kind
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.WaveCorrectionType.Horiz">
            <summary>
            horizontal
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.WaveCorrectionType.Vert">
            <summary>
            Vertical
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.Stitcher.Mode">
            <summary>
            Stitch mode
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Mode.Panorama">
            <summary>
            Mode for creating photo panoramas. Expects images under perspective transformation and projects resulting pano to sphere.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Mode.Scans">
            <summary>
            Mode for composing scans. Expects images under affine transformation does not compensate exposure by default.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.#ctor(Emgu.CV.Stitching.Stitcher.Mode)">
            <summary>
            Creates a Stitcher configured in one of the stitching modes.
            </summary>
            <param name="mode">Scenario for stitcher operation. This is usually determined by source of images to stitch and their transformation. </param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.Stitch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Compute the panoramic images given the images
            </summary>
            <param name="images">The input images. This can be, for example, a VectorOfMat</param>
            <param name="pano">The panoramic image</param>
            <returns>The stitching status</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.EstimateTransform(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IInputArrayOfArrays)">
            <summary>
            These functions try to match the given images and to estimate rotations of each camera.
            </summary>
            <param name="images">Input images</param>
            <param name="masks">Masks for each input image specifying where to look for keypoints (optional)</param>
            <returns>Status code</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.ComposePanorama(Emgu.CV.IOutputArray)">
            <summary>
            These functions try to match the given images and to estimate rotations of each camera.
            </summary>
            <param name="pano">Final pano</param>
            <returns>Status code</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.ComposePanorama(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IOutputArray)">
            <summary>
            These functions try to compose the given images (or images stored internally from the other function calls) into the final pano under the assumption that the image transformations were estimated before.
            </summary>
            <param name="images">Input images</param>
            <param name="pano">Final pano</param>
            <returns>Status code</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetFeaturesFinder(Emgu.CV.Features2D.Feature2D)">
            <summary>
            Set the features finder for this stitcher.
            </summary>
            <param name="finder">The features finder</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetExposureCompensator(Emgu.CV.Stitching.ExposureCompensator)">
            <summary>
            Set the exposure compensator for this stitcher.
            </summary>
            <param name="exposureCompensator">The exposure compensator</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetBundleAdjusterCompensator(Emgu.CV.Stitching.BundleAdjusterBase)">
            <summary>
            Set the bundle adjuster for this stitcher
            </summary>
            <param name="bundleAdjuster">The bundle adjuster</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetSeamFinder(Emgu.CV.Stitching.SeamFinder)">
            <summary>
            Set the seam finder for this stitcher
            </summary>
            <param name="seamFinder">The seam finder</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetEstimator(Emgu.CV.Stitching.Estimator)">
            <summary>
            Set the estimator for this stitcher
            </summary>
            <param name="estimator">The estimator</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetFeaturesMatcher(Emgu.CV.Stitching.FeaturesMatcher)">
            <summary>
            Set the features matcher for this stitcher
            </summary>
            <param name="featuresMatcher">The features matcher</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetWarper(Emgu.CV.Stitching.WarperCreator)">
            <summary>
            Set the warper creator for this stitcher.
            </summary>
            <param name="warperCreator">The warper creator</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetBlender(Emgu.CV.Stitching.Blender)">
            <summary>
            Set the blender for this stitcher
            </summary>
            <param name="blender">The blender</param>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.WaveCorrection">
            <summary>
            Get or Set a flag to indicate if the stitcher should apply wave correction
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.WaveCorrectionKind">
            <summary>
            The wave correction type.
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.PanoConfidenceThresh">
            <summary>
            Get or set the pano confidence threshold
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.CompositingResol">
            <summary>
            Get or Set the compositing resolution
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.SeamEstimationResol">
            <summary>
            Get or Set the seam estimation resolution
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.RegistrationResol">
            <summary>
            Get or set the registration resolution
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.InterpolationFlags">
            <summary>
            Get or Set the interpolation type.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.Cameras">
            <summary>
            Get the camera parameters
            </summary>
            <returns>The camera parameters</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.Component">
            <summary>
            Get the component
            </summary>
            <returns>The component</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.ResultMask">
            <summary>
            Return the mask of the panorama. The mask is a 8U UMat with the values: 0xFF (white) for pixels filled by the input images, 0 (black) for unused pixels.It can be used as the mask for inpaint.
            </summary>
            <returns>The mask of the panorama</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetTransform(Emgu.CV.IInputArrayOfArrays,Emgu.CV.Stitching.VectorOfCameraParams,System.Int32[])">
            <summary>
            These function restores camera rotation and camera intrinsics of each camera that can be got with Stitcher.Cameras() call
            </summary>
            <param name="images">Input images</param>
            <param name="cameras">Estimated rotation of cameras for each of the input images</param>
            <param name="component">Indices (0-based) of images constituting the final panorama (optional)</param>
            <returns>Status code</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.DisposeObject">
            <summary>
            Release memory associated with this stitcher
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.WorkScale">
            <summary>
            The work scale
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.WarperCreator">
            <summary>
            Image warper factories base class.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.WarperCreator._warperCreator">
            <summary>
            Pointer to the unmanaged WarperCreator object
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.WarperCreator.WarperCreatorPtr">
            <summary>
            Pointer to the unmanaged WarperCreator object
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.WarperCreator.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.PlaneWarper">
            <summary>
            Warper that maps an image onto the z = 1 plane.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PlaneWarper.#ctor">
            <summary>
            Construct an instance of the plane warper class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PlaneWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.CylindricalWarper">
            <summary>
            Warper that maps an image onto the x\*x + z\*z = 1 cylinder.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CylindricalWarper.#ctor">
            <summary>
            Construct an instance of the cylindrical warper class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CylindricalWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.SphericalWarper">
            <summary>
            Warper that maps an image onto the unit sphere located at the origin.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.SphericalWarper.#ctor">
            <summary>
            Construct an instance of the spherical warper class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.SphericalWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.FisheyeWarper">
            <summary>
            Fisheye Warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.FisheyeWarper.#ctor">
            <summary>
            Create a fisheye warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.FisheyeWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.StereographicWarper">
            <summary>
            Stereographic Warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.StereographicWarper.#ctor">
            <summary>
            Create a stereographic warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.StereographicWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.CompressedRectilinearWarper">
            <summary>
            Compressed rectilinear warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CompressedRectilinearWarper.#ctor">
            <summary>
            Create a compressed rectilinear warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CompressedRectilinearWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.PaniniWarper">
            <summary>
            Panini warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PaniniWarper.#ctor">
            <summary>
            Create a Panini warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PaniniWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.PaniniPortraitWarper">
            <summary>
            Panini portrait warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PaniniPortraitWarper.#ctor">
            <summary>
            Create a panini portrait warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PaniniPortraitWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.MercatorWarper">
            <summary>
            Mercator warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.MercatorWarper.#ctor">
            <summary>
            Create a Mercator Warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.MercatorWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.TransverseMercatorWarper">
            <summary>
            Transverse mercator warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.TransverseMercatorWarper.#ctor">
            <summary>
            Create a transverse mercator warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.TransverseMercatorWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.PlaneWarperGpu">
            <summary>
            Warper that maps an image onto the z = 1 plane.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PlaneWarperGpu.#ctor">
            <summary>
            Construct an instance of the plane warper class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PlaneWarperGpu.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.CylindricalWarperGpu">
            <summary>
            Warper that maps an image onto the x\*x + z\*z = 1 cylinder.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CylindricalWarperGpu.#ctor">
            <summary>
            Construct an instance of the cylindrical warper class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CylindricalWarperGpu.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.SphericalWarperGpu">
            <summary>
            Warper that maps an image onto the unit sphere located at the origin.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.SphericalWarperGpu.#ctor">
            <summary>
            Construct an instance of the spherical warper class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.SphericalWarperGpu.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this warper
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Bgr">
            <summary> 
            Defines a Bgr (Blue Green Red) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgr._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a BGR color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.#ctor(System.Drawing.Color)">
            <summary>
            Create a Bgr color using the System.Drawing.Color
            </summary>
            <param name="winColor">System.Drawing.Color</param>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.Equals(Emgu.CV.Structure.Bgr)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Bgra">
            <summary> 
            Defines a Bgra (Blue Green Red Alpha) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgra._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary> Create a BGRA color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
            <param name="alpha"> The alpha value for this color</param>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Alpha">
            <summary> Get or set the intensity of the alpha color channel </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.Equals(Emgu.CV.Structure.Bgra)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Gray">
            <summary> Defines a Gray color </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Gray._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.#ctor(System.Double)">
            <summary> Create a Gray color with the given intensity</summary>
            <param name="intensity"> The intensity for this color </param>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.Intensity">
            <summary> The intensity of the gray color </summary>
            <value> The intensity of the gray color</value>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.GetHashCode">
            <summary>
            Returns the hash code for this color
            </summary>
            <returns>the hash code</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.Equals(Emgu.CV.Structure.Gray)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Hls">
            <summary> 
            Defines a Hls (Hue Lightness Satuation) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Hls._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Hls color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation for this color </param>
            <param name="lightness"> The lightness for this color </param>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Hue">
            <summary> Get or set the intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Lightness">
            <summary> Get or set the intensity of the lightness color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Satuation">
            <summary> Get or set the intensity of the satuation color channel </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.Equals(Emgu.CV.Structure.Hls)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Hsv">
            <summary> 
            Defines a HSV (Hue Satuation Value) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Hsv._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a HSV color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation value for this color </param>
            <param name="value"> The value for this color </param>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Hue">
            <summary> Get or set the intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Satuation">
            <summary> Get or set the intensity of the satuation color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Value">
            <summary> Get or set the intensity of the value color channel </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.Equals(Emgu.CV.Structure.Hsv)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Lab">
            <summary> 
            Defines a CIE Lab color 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Lab._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.X">
            <summary> Get or set the intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Y">
            <summary> Get or set the intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Z">
            <summary> Get or set the intensity of the z color channel </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.Equals(Emgu.CV.Structure.Lab)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Luv">
            <summary> 
            Defines a CIE Luv color 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Luv._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.X">
            <summary>
            The intensity of the x color channel
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Y">
            <summary>
            The intensity of the y color channel
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Z">
            <summary>
            The intensity of the z color channel
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.Equals(Emgu.CV.Structure.Luv)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Rgb">
            <summary> 
            Defines a Rgb (Red Green Blue) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Rgb._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.#ctor(System.Double,System.Double,System.Double)">
            <summary>Create a RGB color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.#ctor(System.Drawing.Color)">
            <summary>
            Create a Rgb color using the system color
            </summary>
            <param name="winColor">color</param>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.Equals(Emgu.CV.Structure.Rgb)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Bgr565">
            <summary> 
            Defines a Bgr565 (Blue Green Red) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgr565._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Bgr565 color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.#ctor(System.Drawing.Color)">
            <summary>
            Create a Bgr565 color using the System.Drawing.Color
            </summary>
            <param name="winColor">System.Drawing.Color</param>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.Equals(Emgu.CV.Structure.Bgr565)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Rgba">
            <summary> 
            Defines a Rgba (Red Green Blue Alpha) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Rgba._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgba.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary> Create a RGBA color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
            <param name="alpha"> The alpha value for this color</param>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Alpha">
            <summary> Get or set the intensity of the alpha color channel </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgba.Equals(Emgu.CV.Structure.Rgba)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgba.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Xyz">
            <summary> 
            Defines a Xyz color (CIE XYZ.Rec 709 with D65 white point)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Xyz._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Xyz color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.X">
            <summary>
            Get or set the intensity of the x color channel
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Y">
            <summary>
            Get or set the intensity of the y color channel
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Z">
            <summary>
            Get or set the intensity of the z color channel
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.Equals(Emgu.CV.Structure.Xyz)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Ycc">
            <summary> 
            Defines a Ycc color (YCrCb JPEG)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Ycc._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Ycc color using the specific values</summary>
            <param name="y"> The Y value for this color </param>
            <param name="cr"> The Cr value for this color </param>
            <param name="cb"> The Cb value for this color </param>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Y">
            <summary>
            Get or set the intensity of the Y color channel
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Cr">
            <summary>
            Get or set the intensity of the Cr color channel
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Cb">
            <summary>
            Get or set the intensity of the Cb color channel
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.Equals(Emgu.CV.Structure.Ycc)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment2D">
            <summary> 
            A line segment 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2D._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2D._p2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.#ctor(System.Drawing.Point,System.Drawing.Point)">
            <summary> 
            Create a line segment with the specific starting point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.Direction">
            <summary> The direction of the line, the norm of which is 1 </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.Side(System.Drawing.Point)">
            <summary>
            Determine which side of the line the 2D point is at
            </summary>
            <param name="point">the point</param>
            <returns>
            1 if on the right hand side;
            0 if on the line;
            -1 if on the left hand side;
            </returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.GetExteriorAngleDegree(Emgu.CV.Structure.LineSegment2D)">
            <summary>
            Get the exterior angle between this line and <paramref name="otherLine"/>
            </summary>
            <param name="otherLine">The other line</param>
            <returns>The exterior angle between this line and <paramref name="otherLine"/></returns>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment2DF">
            <summary> 
            A line segment 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2DF._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2DF._p2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.#ctor(System.Drawing.PointF,System.Drawing.PointF)">
            <summary> 
            Create a line segment with the specific start point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.Direction">
            <summary> 
            The direction of the line, the norm of which is 1 
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.YByX(System.Single)">
            <summary> Obtain the Y value from the X value using first degree interpolation</summary>
            <param name="x">The X value</param>
            <returns>The Y value</returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.Side(System.Drawing.PointF)">
            <summary>
            Determin which side of the line the 2D point is at
            </summary>
            <param name="point">the point</param>
            <returns>
            1 if on the right hand side;
            0 if on the line;
            -1 if on the left hand side;
            </returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.GetExteriorAngleDegree(Emgu.CV.Structure.LineSegment2DF)">
            <summary>
            Get the exterior angle between this line and <paramref name="otherLine"/>
            </summary>
            <param name="otherLine">The other line</param>
            <returns>The exterior angle between this line and <paramref name="otherLine"/></returns>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment3DF">
            <summary>
            A 3D line segment
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment3DF._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment3DF._p2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment3DF.#ctor(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary> 
            Create a line segment with the specific start point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.CircleF">
            <summary> A circle </summary>
        </member>
        <member name="M:Emgu.CV.Structure.CircleF.#ctor(System.Drawing.PointF,System.Single)">
            <summary> Create a circle with the specific center and radius </summary>
            <param name="center"> The center of this circle </param>
            <param name="radius"> The radius of this circle </param>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Center">
            <summary> Get or Set the center of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Radius">
            <summary> The radius of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Area">
            <summary> The area of the circle </summary>
        </member>
        <member name="M:Emgu.CV.Structure.CircleF.Equals(Emgu.CV.Structure.CircleF)">
            <summary>
            Compare this circle with <paramref name="circle2"/>
            </summary>
            <param name="circle2">The other box to be compared</param>
            <returns>true if the two boxes equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.ColorPoint">
            <summary>
            A point with Bgr color information
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.ColorPoint.Position">
            <summary>
            The position in meters
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.ColorPoint.Blue">
            <summary>
            The blue color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.ColorPoint.Green">
            <summary>
            The green color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.ColorPoint.Red">
            <summary>
            The red color
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Cross2DF">
            <summary>
            A 2D cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Center">
            <summary>
            The center of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Size">
            <summary>
            The size of this cross
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Cross2DF.#ctor(System.Drawing.PointF,System.Single,System.Single)">
            <summary>
            Construct a cross
            </summary>
            <param name="center">The center of the cross</param>
            <param name="width">the width of the cross</param>
            <param name="height">the height of the cross</param>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Horizontal">
            <summary>
            Get the horizonal linesegment of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Vertical">
            <summary>
            Get the vertical linesegment of this cross
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Cuboid">
            <summary>
            A solid resembling a cube, with the rectangular faces not all equal; a rectangular parallelepiped.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Cuboid.Min">
            <summary>
            The coordinate of the upper corner
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Cuboid.Max">
            <summary>
            The coordinate of the lower corner
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Cuboid.Contains(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Check if the specific point is in the Cuboid
            </summary>
            <param name="point">The point to be checked</param>
            <returns>True if the point is in the cuboid</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Cuboid.Centroid">
            <summary>
            Get the centroid of this cuboid
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.CvStructSizes">
            <summary>
            This is used to hold the sizes of the Open CV structures
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvPoint">
            <summary>
            The size of CvPoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvPoint2D32f">
            <summary>
            The size of CvPoint2D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvPoint3D32f">
            <summary>
            The size of CvPoint3D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvSize">
            <summary>
            The size of CvSize
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvSize2D32f">
            <summary>
            The size of CvSize2D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvScalar">
            <summary>
            The size of CvScalar
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvRect">
            <summary>
            The size of CvRect
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvBox2D">
            <summary>
            The size of CvBox2D
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvMat">
            <summary>
            The size of CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvMatND">
            <summary>
            The size of CvMatND
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvTermCriteria">
            <summary>
            The size of CvTermCriteria
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.IplImage">
            <summary>
            The size of IplImage
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Ellipse">
            <summary>
            An ellipse
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ellipse.RotatedRect">
            <summary>
            The RotatedRect representation of this ellipse
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ellipse.#ctor(System.Drawing.PointF,System.Drawing.SizeF,System.Single)">
            <summary>
            Create an ellipse with specific parameters
            </summary>
            <param name="center"> The center of the ellipse</param>
            <param name="size"> The width and height of the ellipse</param>
            <param name="angle"> The rotation angle in radian for the ellipse</param>
        </member>
        <member name="M:Emgu.CV.Structure.Ellipse.#ctor(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Create an ellipse from the specific RotatedRect
            </summary>
            <param name="box2d">The RotatedRect representation of this ellipse</param>
        </member>
        <member name="T:Emgu.CV.Structure.MCvAvgComp">
            <summary>
            Result of cvHaarDetectObjects
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvAvgComp.Rect">
            <summary>
            Bounding rectangle for the object (average rectangle of a group)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvAvgComp.Neighbors">
            <summary>
            Number of neighbor rectangles in the group
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMat">
            <summary>
            Managed structure equivalent to CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Type">
            <summary>
            CvMat signature (CV_MAT_MAGIC_VAL), element type and flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Step">
            <summary>
            full row length in bytes
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Refcount">
            <summary>
            underlying data reference counter
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.HdrRefcount">
            <summary>
            Header reference count
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Data">
            <summary>
            data pointers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Rows">
            <summary>
            number of rows
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Cols">
            <summary>
            number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.Width">
            <summary>
            Width
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.Height">
            <summary>
            Height
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.NumberOfChannels">
            <summary>
            Get the number of channels
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatConstants">
            <summary>
            Constants used by the MCvMat structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatConstants.TypeOffset">
            <summary>
            Offset of roi
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatND">
            <summary>
            Managed structure equivalent to CvMatND
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.type">
            <summary>
            CvMatND signature (CV_MATND_MAGIC_VAL), element type and flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dims">
            <summary>
            number of array dimensions
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.refcount">
            <summary>
            underlying data reference counter
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.hdr_refcount">
            <summary>
            Header reference count
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.data">
            <summary>
            data pointers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim0">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim1">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim2">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim3">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim4">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim5">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim6">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim7">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim8">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim9">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim10">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim11">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim12">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim13">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim14">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim15">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim16">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim17">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim18">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim19">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim20">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim21">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim22">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim23">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim24">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim25">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim26">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim27">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim28">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim29">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim30">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim31">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.dim">
            <summary>
            pairs (number of elements, distance between elements in bytes) for every dimension
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatND.Dimension">
            <summary>
            The MatND Dimension
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.Dimension.Size">
            <summary>
            Number of elements in this dimension
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.Dimension.Step">
            <summary>
            distance between elements in bytes for this dimension
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvObjectDetection">
            <summary>
            Structure contains the bounding box and confidence level for detected object
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvObjectDetection.Rect">
            <summary>
            Bounding box for a detected object
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvObjectDetection.Score">
            <summary>
            Confidence level 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvObjectDetection.ClassId">
            <summary>
            The class identifier
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint2D64f">
            <summary>
            Managed Structure equivalent to CvPoint2D64f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint2D64f.X">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint2D64f.Y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.#ctor(System.Double,System.Double)">
            <summary>
            Create a MCvPoint2D64f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Addition(Emgu.CV.Structure.MCvPoint2D64f,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Subtraction(Emgu.CV.Structure.MCvPoint2D64f,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Subtract <paramref name="p2"/> from <paramref name="p1"/>
            </summary>
            <param name="p1">The first point</param>
            <param name="p2">The point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Multiply(Emgu.CV.Structure.MCvPoint2D64f,System.Double)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Multiply(System.Double,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.Equals(Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Returns true if the two points equals.
            </summary>
            <param name="other">The other point to compare with</param>
            <returns>True if the two points equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvPoint2D64f.Emgu#Util#IInterpolatable{Emgu#CV#Structure#MCvPoint2D64f}#InterpolationIndex">
            <inheritdoc />
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.Emgu#Util#IInterpolatable{Emgu#CV#Structure#MCvPoint2D64f}#LinearInterpolate(Emgu.CV.Structure.MCvPoint2D64f,System.Double)">
            <inheritdoc />
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint3D32f">
            <summary>
            Managed Structure equivalent to CvPoint3D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.X">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.Y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.Z">
            <summary>
            z-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Create a MCvPoint3D32f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.CrossProduct(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return the cross product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The cross product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.DotProduct(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return the dot product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The dot product of the two 3D point</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvPoint3D32f.Norm">
            <summary>
            return the norm of this 3D point
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.GetNormalizedPoint">
            <summary>
            Get the normalized point
            </summary>
            <returns>The normalized point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Implicit(Emgu.CV.Structure.MCvPoint3D32f)~Emgu.CV.Structure.MCvPoint3D64f">
            <summary>
            The implicit operator to convert MCvPoint3D32f to MCvPoint3D64f
            </summary>
            <param name="point">The point to be converted</param>
            <returns>The converted point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Subtraction(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Subtract one point from the other
            </summary>
            <param name="p1">The point to subtract from</param>
            <param name="p2">The value to be subtracted</param>
            <returns>The subtraction of one point from the other</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Addition(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Multiply(Emgu.CV.Structure.MCvPoint3D32f,System.Single)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Multiply(System.Single,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.Equals(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return true if the location of the two points are equal
            </summary>
            <param name="other">The other point to compare with</param>
            <returns>True if the location of the two points are equal</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint3D64f">
            <summary>
            Managed Structure equivalent to CvPoint3D64f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.X">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.Y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.Z">
            <summary>
            z-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a MCvPoint3D64f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.CrossProduct(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Return the cross product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The cross product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.DotProduct(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Return the dot product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The dot product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Addition(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Subtraction(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Subtract <paramref name="p2"/> from <paramref name="p1"/>
            </summary>
            <param name="p1">The first point</param>
            <param name="p2">The point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Multiply(Emgu.CV.Structure.MCvPoint3D64f,System.Double)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Multiply(System.Double,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.Equals(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Check if the other point equals to this point
            </summary>
            <param name="other">The point to be compared</param>
            <returns>True if the two points are equal</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvScalar">
            <summary>
            Managed structure equivalent to CvScalar 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V0">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V1">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V2">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V3">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.ToArray">
            <summary>
            The scalar values as a vector (of size 4)
            </summary>
            <returns>The scalar values as an array</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
            <param name="v2">v2</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
            <param name="v2">v2</param>
            <param name="v3">v3</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.ToCode(Emgu.Util.TypeEnum.ProgrammingLanguage)">
            <summary>
            Return the code to generate this MCvScalar from specific language
            </summary>
            <param name="language">The programming language to generate code from</param>
            <returns>The code to generate this MCvScalar from specific language</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.Equals(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Return true if the two MCvScalar equals
            </summary>
            <param name="other">The other MCvScalar to compare with</param>
            <returns>true if the two MCvScalar equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSlice">
            <summary>
            Managed structure equivalent to CvSlice
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSlice.start_index">
            <summary>
            Start index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSlice.end_index">
            <summary>
            End index
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvSlice.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new MCvSlice using the specific start and end index
            </summary>
            <param name="start">start index</param>
            <param name="end">end index</param>
        </member>
        <member name="P:Emgu.CV.Structure.MCvSlice.WholeSeq">
            <summary>
            Get the equivalent of CV_WHOLE_SEQ
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvTermCriteria">
            <summary>
            Managed structure equivalent to CvTermCriteria
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.Type">
            <summary>
            The type of termination criteria
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.MaxCount">
            <summary>
            Maximum iteration
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.Epsilon">
            <summary>
            The desired accuracy of change in parameters at which the iterative algorithm stops.
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Int32)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Double)">
            <summary>
            Create the termination Criteria using only the constrain of epsilon
            </summary>
            <param name="eps"> The epsilon value</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Int32,System.Double)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration as well as epsilon
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
            <param name="eps">The epsilon value</param>
        </member>
        <member name="T:Emgu.CV.Structure.MDMatch">
            <summary>
            OpenCV's DMatch structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.QueryIdx">
            <summary>
            Query descriptor index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.TrainIdx">
            <summary>
            Train descriptor index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.ImgIdx">
            <summary>
            Train image index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.Distance">
            <summary>
            Distance
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MIplImage">
            <summary>
            Managed structure equivalent to IplImage
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.NSize">
            <summary>
            sizeof(IplImage) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ID">
            <summary>
            version (=0)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.NChannels">
            <summary>
            Most of OpenCV functions support 1,2,3 or 4 channels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.AlphaChannel">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Depth">
            <summary>
            pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U, IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel0">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel1">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel2">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel3">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq0">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq1">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq2">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq3">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.DataOrder">
            <summary>
            0 - interleaved color channels, 1 - separate color channels.
            cvCreateImage can only create interleaved images 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Origin">
            <summary>
            0 - top-left origin,
            1 - bottom-left origin (Windows bitmaps style)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Align">
            <summary>
            Alignment of image rows (4 or 8).
            OpenCV ignores it and uses widthStep instead 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Width">
            <summary>
            image width in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Height">
            <summary>
            image height in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Roi">
            <summary>
            image ROI. when it is not NULL, this specifies image region to process 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.MaskROI">
            <summary>
            must be NULL in OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageId">
            <summary>
            ditto
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.TileInfo">
            <summary>
            ditto 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageSize">
            <summary>
            image data size in bytes
            (=image->height*image->widthStep in case of interleaved data)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageData">
            <summary>
            pointer to aligned image data 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.WidthStep">
            <summary>
            size of aligned image row in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode0">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode1">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode2">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode3">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst0">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst1">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst2">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst3">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageDataOrigin">
            <summary>
             pointer to a very origin of image data (not necessarily aligned) - it is needed for correct image deallocation 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MKeyPoint">
            <summary>
            OpenCV's KeyPoint class
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Point">
            <summary>
            The location of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Size">
            <summary>
            Size of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Angle">
            <summary>
            Orientation of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Response">
            <summary>
            Response of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Octave">
            <summary>
            octave
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.ClassId">
            <summary>
            class id
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Range">
            <summary>
            The range use to setup the histogram
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Range.All">
            <summary>
            return the full range.
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Range.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a range of the specific min/max value
            </summary>
            <param name="start">The start value of this range</param>
            <param name="end">The max value of this range</param>
        </member>
        <member name="P:Emgu.CV.Structure.Range.Start">
            <summary>
            The start value of this range
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Range.End">
            <summary>
            The end value of this range
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Range.Equals(Emgu.CV.Structure.Range)">
            <summary>
            Return true if the two Range equals
            </summary>
            <param name="other">The other Range to compare with</param>
            <returns>True if the two Range equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.RangeF">
            <summary>
            The range use to setup the histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.RangeF.#ctor(System.Single,System.Single)">
            <summary>
            Create a range of the specific min/max value
            </summary>
            <param name="min">The min value of this range</param>
            <param name="max">The max value of this range</param>
        </member>
        <member name="P:Emgu.CV.Structure.RangeF.Min">
            <summary>
            The minimum value of this range
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.RangeF.Max">
            <summary>
            The maximum value of this range
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.RangeF.Equals(Emgu.CV.Structure.RangeF)">
            <summary>
            Return true if the two RangeF equals
            </summary>
            <param name="other">The other RangeF to compare with</param>
            <returns>True if the two RangeF equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.RotatedRect">
            <summary>
            The class represents rotated (i.e. not up-right) rectangles on a plane.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.RotatedRect.Center">
            <summary>
            The rectangle mass center
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.RotatedRect.Size">
            <summary>
            Width and height of the rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.RotatedRect.Angle">
            <summary>
            The rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.#ctor(System.Drawing.PointF,System.Drawing.SizeF,System.Single)">
            <summary>
            Create a RotatedRect structure with the specific parameters
            </summary>
            <param name="center">The rectangle mass center</param>
            <param name="size">Width and height of the rectangle</param>
            <param name="angle">The rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</param>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.Offset(System.Int32,System.Int32)">
            <summary>
            Shift the box by the specific amount
            </summary>
            <param name="x">The x value to be offset</param>
            <param name="y">The y value to be offset</param>
        </member>
        <member name="P:Emgu.CV.Structure.RotatedRect.Empty">
            <summary>
            Represent an uninitialized RotatedRect
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.GetVertices">
            <summary>
            Get the 4 vertices of this Box.
            </summary>
            <returns>The vertices of this RotatedRect</returns>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.MinAreaRect">
            <summary>
            Get the minimum enclosing rectangle for this Box
            </summary>
            <returns>The minimum enclosing rectangle for this Box</returns>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.Equals(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Returns true if the two box are equal
            </summary>
            <param name="other">The other box to compare with</param>
            <returns>True if two boxes are equal</returns>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.op_Implicit(System.Drawing.RectangleF)~Emgu.CV.Structure.RotatedRect">
            <summary>
            Convert a RectangleF to RotatedRect
            </summary>
            <param name="rectangle">The rectangle</param>
            <returns>The equivalent RotatedRect</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Triangle2DF">
            <summary>
            A 2D triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V0">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V1">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V2">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.#ctor(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Create a triangle using the specific vertices
            </summary>
            <param name="v0">The first vertex</param>
            <param name="v1">The second vertex</param>
            <param name="v2">The third vertex</param>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.Area">
            <summary>
            Get the area of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.Centeroid">
            <summary>
            Returns the centroid of this triangle
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.Equals(Emgu.CV.Structure.Triangle2DF)">
            <summary>
            Compare two triangles and return true if equal
            </summary>
            <param name="tri">the other triangles to compare with</param>
            <returns>true if the two triangles equals, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.GetVertices">
            <summary>
            Get the vertices of this triangle
            </summary>
            <returns>The vertices of this triangle</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Triangle3DF">
            <summary>
            A 3D triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V0">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V1">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V2">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Area">
            <summary>
            Get the area of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Normal">
            <summary>
            Get the normal of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Centeroid">
            <summary>
            Returns the centroid of this triangle
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle3DF.#ctor(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Create a triangle using the specific vertices
            </summary>
            <param name="v0">The first vertex</param>
            <param name="v1">The second vertex</param>
            <param name="v2">The third vertex</param>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle3DF.Equals(Emgu.CV.Structure.Triangle3DF)">
            <summary>
            Compare two triangles and return true if equal
            </summary>
            <param name="tri">the other triangles to compare with</param>
            <returns>true if the two triangles equals, false otherwise</returns>
        </member>
        <member name="T:Emgu.CV.ColorInfoAttribute">
            <summary>
            Attribute used to specify color information
            </summary>
        </member>
        <member name="F:Emgu.CV.ColorInfoAttribute._conversionCodename">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="P:Emgu.CV.ColorInfoAttribute.ConversionCodename">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="M:Emgu.CV.ColorInfoAttribute.#ctor">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="M:Emgu.CV.DisplayColorAttribute.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            The display color
            </summary>
            <param name="blue">blue</param>
            <param name="green">green</param>
            <param name="red">red</param>
        </member>
        <member name="P:Emgu.CV.DisplayColorAttribute.DisplayColor">
            <summary>
            Get or set the display color
            </summary>
        </member>
        <member name="T:Emgu.CV.IColor">
            <summary>
            A color type
            </summary>
        </member>
        <member name="P:Emgu.CV.IColor.MCvScalar">
            <summary>
            The equivalent MCvScalar value
            </summary>
        </member>
        <member name="P:Emgu.CV.IColor.Dimension">
            <summary>
            Get the dimension of the color type
            </summary>
        </member>
        <member name="T:Emgu.CV.AlignExposures">
            <summary>
            The base class for algorithms that align images of the same scene with different exposures
            </summary>
        </member>
        <member name="F:Emgu.CV.AlignExposures._alignExposuresPtr">
            <summary>
            The pointer to the native AlignExposures object
            </summary>
        </member>
        <member name="M:Emgu.CV.AlignExposures.Process(Emgu.CV.IInputArrayOfArrays,Emgu.CV.Util.VectorOfMat,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Aligns images.
            </summary>
            <param name="src">vector of input images</param>
            <param name="dst">vector of aligned images</param>
            <param name="times">vector of exposure time values for each image</param>
            <param name="response">256x1 matrix with inverse camera response function for each pixel value, it should have the same number of channels as images.</param>
        </member>
        <member name="M:Emgu.CV.AlignExposures.DisposeObject">
            <summary>
            Reset the pointer that points to the CalibrateCRF object.
            </summary>
        </member>
        <member name="T:Emgu.CV.AlignMTB">
            <summary>
            This algorithm converts images to median threshold bitmaps (1 for pixels brighter than median luminance and 0 otherwise) and than aligns the resulting bitmaps using bit operations.
            </summary>
        </member>
        <member name="M:Emgu.CV.AlignMTB.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create an AlignMTB object
            </summary>
            <param name="maxBits">logarithm to the base 2 of maximal shift in each dimension. Values of 5 and 6 are usually good enough (31 and 63 pixels shift respectively).</param>
            <param name="excludeRange">range for exclusion bitmap that is constructed to suppress noise around the median value.</param>
            <param name="cut">if true cuts images, otherwise fills the new regions with zeros.</param>
        </member>
        <member name="M:Emgu.CV.AlignMTB.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this AlignMTB object
            </summary>
        </member>
        <member name="T:Emgu.CV.CalibrateCRF">
            <summary>
            The base class for camera response calibration algorithms.
            </summary>
        </member>
        <member name="F:Emgu.CV.CalibrateCRF._calibrateCRFPtr">
            <summary>
            The pointer to the calibrateCRF object
            </summary>
        </member>
        <member name="M:Emgu.CV.CalibrateCRF.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Recovers inverse camera response.
            </summary>
            <param name="src">Vector of input images</param>
            <param name="dst">256x1 matrix with inverse camera response function</param>
            <param name="times">Vector of exposure time values for each image</param>
        </member>
        <member name="M:Emgu.CV.CalibrateCRF.DisposeObject">
            <summary>
            Reset the pointer that points to the CalibrateCRF object.
            </summary>
        </member>
        <member name="T:Emgu.CV.CalibrateDebevec">
            <summary>
            Inverse camera response function is extracted for each brightness value by minimizing an objective function as linear system. Objective function is constructed using pixel values on the same position in all images, extra term is added to make the result smoother.
            </summary>
        </member>
        <member name="M:Emgu.CV.CalibrateDebevec.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            Creates CalibrateDebevec object.
            </summary>
            <param name="samples">Number of pixel locations to use</param>
            <param name="lambda">Smoothness term weight. Greater values produce smoother results, but can alter the response.</param>
            <param name="random">If true sample pixel locations are chosen at random, otherwise the form a rectangular grid.</param>
        </member>
        <member name="M:Emgu.CV.CalibrateDebevec.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this CalibrateCRF object
            </summary>
        </member>
        <member name="T:Emgu.CV.CalibrateRobertson">
            <summary>
            Inverse camera response function is extracted for each brightness value by minimizing an objective function as linear system. This algorithm uses all image pixels.
            </summary>
        </member>
        <member name="M:Emgu.CV.CalibrateRobertson.#ctor(System.Int32,System.Single)">
            <summary>
            Creates CalibrateRobertson object.
            </summary>
            <param name="maxIter">maximal number of Gauss-Seidel solver iterations.</param>
            <param name="threshold">get difference between results of two successive steps of the minimization.</param>
        </member>
        <member name="M:Emgu.CV.CalibrateRobertson.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this CalibrateCRF object
            </summary>
        </member>
        <member name="T:Emgu.CV.MergeExposures">
            <summary>
            The base class algorithms that can merge exposure sequence to a single image.
            </summary>
        </member>
        <member name="F:Emgu.CV.MergeExposures._mergeExposuresPtr">
            <summary>
            The pointer to the unmanaged MergeExposure object
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeExposures.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Merges images.
            </summary>
            <param name="src">Vector of input images</param>
            <param name="dst">Result image</param>
            <param name="times">Vector of exposure time values for each image</param>
            <param name="response">256x1 matrix with inverse camera response function for each pixel value, it should have the same number of channels as images.</param>
        </member>
        <member name="M:Emgu.CV.MergeExposures.DisposeObject">
            <summary>
            Reset the native pointer to the MergeExposure object
            </summary>
        </member>
        <member name="T:Emgu.CV.MergeDebevec">
            <summary>
            The resulting HDR image is calculated as weighted average of the exposures considering exposure values and camera response.
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeDebevec.#ctor">
            <summary>
            Creates MergeDebevec object.
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeDebevec.DisposeObject">
            <summary>
            Release the MergeDebevec object
            </summary>
        </member>
        <member name="T:Emgu.CV.MergeMertens">
            <summary>
            Pixels are weighted using contrast, saturation and well-exposedness measures, than images are combined using laplacian pyramids.
            The resulting image weight is constructed as weighted average of contrast, saturation and well-exposedness measures.
            The resulting image doesn't require tonemapping and can be converted to 8-bit image by multiplying by 255, but it's recommended to apply gamma correction and/or linear tonemapping.
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeMertens.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates MergeMertens object.
            </summary>
            <param name="contrastWeight">contrast measure weight.</param>
            <param name="saturationWeight">saturation measure weight</param>
            <param name="exposureWeight">well-exposedness measure weight</param>
        </member>
        <member name="M:Emgu.CV.MergeMertens.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Merges images.
            </summary>
            <param name="src">Vector of input images</param>
            <param name="dst">Result image</param>
        </member>
        <member name="M:Emgu.CV.MergeMertens.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this MergeMertens object
            </summary>
        </member>
        <member name="T:Emgu.CV.MergeRobertson">
            <summary>
            The resulting HDR image is calculated as weighted average of the exposures considering exposure values and camera response
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeRobertson.#ctor">
            <summary>
            Creates MergeRobertson object.
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeRobertson.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this MergeRobertson object
            </summary>
        </member>
        <member name="T:Emgu.CV.Tonemap">
            <summary>
            Base class for tonemapping algorithms - tools that are used to map HDR image to 8-bit range.
            </summary>
        </member>
        <member name="F:Emgu.CV.Tonemap._tonemapPtr">
            <summary>
            The pointer to the unmanaged Tonemap object
            </summary>
        </member>
        <member name="F:Emgu.CV.Tonemap._algorithmPtr">
            <summary>
            The pointer to the unmanaged Algorithm object
            </summary>
        </member>
        <member name="P:Emgu.CV.Tonemap.AlgorithmPtr">
            <summary>
            The pointer to the unamanged Algorith object
            </summary>
        </member>
        <member name="M:Emgu.CV.Tonemap.#ctor(System.IntPtr,System.IntPtr)">
            <summary>
            Default constructor that creates empty Tonemap
            </summary>
            <param name="ptr">The pointer to the unmanaged object</param>
            <param name="tonemapPtr">The pointer to the tonemap object</param>
        </member>
        <member name="M:Emgu.CV.Tonemap.#ctor(System.Single)">
            <summary>
            Creates simple linear mapper with gamma correction.
            </summary>
            <param name="gamma">positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma equal to 2.2f is suitable for most displays. Generally gamma &gt; 1 brightens the image and gamma &lt; 1 darkens it.</param>
        </member>
        <member name="M:Emgu.CV.Tonemap.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Tonemaps image.
            </summary>
            <param name="src">Source image - 32-bit 3-channel Mat</param>
            <param name="dst">destination image - 32-bit 3-channel Mat with values in [0, 1] range</param>
        </member>
        <member name="M:Emgu.CV.Tonemap.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Tonemap
            </summary>
        </member>
        <member name="P:Emgu.CV.Tonemap.Gamma">
            <summary>
            Positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma equal to 2.2f is suitable for most displays.
            </summary>
        </member>
        <member name="T:Emgu.CV.TonemapDrago">
            <summary>
            Adaptive logarithmic mapping is a fast global tonemapping algorithm that scales the image in logarithmic domain.
            Since it's a global operator the same function is applied to all the pixels, it is controlled by the bias parameter.
            </summary>
        </member>
        <member name="M:Emgu.CV.TonemapDrago.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapDrago object.
            </summary>
            <param name="gamma">gamma value for gamma correction.</param>
            <param name="saturation">positive saturation enhancement value. 1.0 preserves saturation, values greater than 1 increase saturation and values less than 1 decrease it.</param>
            <param name="bias">	value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best results, default value is 0.85.</param>
        </member>
        <member name="M:Emgu.CV.TonemapDrago.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this TonemapDrago
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapDrago.Saturation">
            <summary>
            Positive saturation enhancement value. 1.0 preserves saturation, values greater than 1 increase saturation and values less than 1 decrease it.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapDrago.Bias">
            <summary>
            Value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best results, default value is 0.85.
            </summary>
        </member>
        <member name="T:Emgu.CV.TonemapMantiuk">
            <summary>
            This algorithm transforms image to contrast using gradients on all levels of gaussian pyramid, transforms contrast values to HVS response and scales the response. After this the image is reconstructed from new contrast values.
            </summary>
        </member>
        <member name="M:Emgu.CV.TonemapMantiuk.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapMantiuk object
            </summary>
            <param name="gamma">gamma value for gamma correction.</param>
            <param name="scale">contrast scale factor. HVS response is multiplied by this parameter, thus compressing dynamic range. Values from 0.6 to 0.9 produce best results.</param>
            <param name="saturation">saturation enhancement value.</param>
        </member>
        <member name="M:Emgu.CV.TonemapMantiuk.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this TonemapMantiuk
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapMantiuk.Saturation">
            <summary>
            Saturation enhancement value.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapMantiuk.Scale">
            <summary>
            Contrast scale factor. HVS response is multiplied by this parameter, thus compressing dynamic range. Values from 0.6 to 0.9 produce best results.
            </summary>
        </member>
        <member name="T:Emgu.CV.TonemapReinhard">
            <summary>
            This is a global tonemapping operator that models human visual system.
            Mapping function is controlled by adaptation parameter, that is computed using light adaptation and color adaptation.
            </summary>
        </member>
        <member name="M:Emgu.CV.TonemapReinhard.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapReinhard object.
            </summary>
            <param name="gamma">gamma value for gamma correction</param>
            <param name="intensity">result intensity in [-8, 8] range. Greater intensity produces brighter results.</param>
            <param name="lightAdapt">light adaptation in [0, 1] range. If 1 adaptation is based only on pixel value, if 0 it's global, otherwise it's a weighted mean of this two cases.</param>
            <param name="colorAdapt">chromatic adaptation in [0, 1] range. If 1 channels are treated independently, if 0 adaptation level is the same for each channel.</param>
        </member>
        <member name="M:Emgu.CV.TonemapReinhard.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this TonemapReinhard
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapReinhard.Intensity">
            <summary>
            Result intensity in [-8, 8] range. Greater intensity produces brighter results.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapReinhard.LightAdaptation">
            <summary>
            Light adaptation in [0, 1] range. If 1 adaptation is based only on pixel value, if 0 it is global, otherwise it is a weighted mean of this two cases.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapReinhard.ColorAdaptation">
            <summary>
            chromatic adaptation in [0, 1] range. If 1 channels are treated independently, if 0 adaptation level is the same for each channel.
            </summary>
        </member>
        <member name="T:Emgu.CV.IWidget">
            <summary>
            Interface for all widgets
            </summary>
        </member>
        <member name="P:Emgu.CV.IWidget.GetWidget">
            <summary>
            Get the pointer to the widget object
            </summary>
        </member>
        <member name="T:Emgu.CV.IWidget3D">
            <summary>
            Interface for all widget3D
            </summary>
        </member>
        <member name="P:Emgu.CV.IWidget3D.GetWidget3D">
            <summary>
            Get the pointer to the widget3D object
            </summary>
        </member>
        <member name="T:Emgu.CV.IWidget2D">
            <summary>
            Interface for all widget2D
            </summary>
        </member>
        <member name="P:Emgu.CV.IWidget2D.GetWidget2D">
            <summary>
            Get the pointer to the widget2D object
            </summary>
        </member>
        <member name="T:Emgu.CV.Viz3d">
            <summary>
            Represents a 3D visualizer window. 
            </summary>
        </member>
        <member name="M:Emgu.CV.Viz3d.#ctor(System.String)">
            <summary>
            Create a new 3D visualizer windows
            </summary>
            <param name="windowName">The name of the windows</param>
        </member>
        <member name="M:Emgu.CV.Viz3d.ShowWidget(System.String,Emgu.CV.IWidget,Emgu.CV.Affine3d)">
            <summary>
            Show a widget in the window
            </summary>
            <param name="id">A unique id for the widget.</param>
            <param name="widget">The widget to be displayed in the window.</param>
            <param name="pose">Pose of the widget.</param>
        </member>
        <member name="M:Emgu.CV.Viz3d.RemoveWidget(System.String)">
            <summary>
            Removes a widget from the window.
            </summary>
            <param name="id">The id of the widget that will be removed.</param>
        </member>
        <member name="M:Emgu.CV.Viz3d.SetWidgetPose(System.String,Emgu.CV.Affine3d)">
            <summary>
            Sets pose of a widget in the window.
            </summary>
            <param name="id">The id of the widget whose pose will be set.</param>
            <param name="pose">The new pose of the widget.</param>
        </member>
        <member name="M:Emgu.CV.Viz3d.Spin">
            <summary>
            The window renders and starts the event loop.
            </summary>
        </member>
        <member name="M:Emgu.CV.Viz3d.SpinOnce(System.Int32,System.Boolean)">
            <summary>
            Starts the event loop for a given time.
            </summary>
            <param name="time">	Amount of time in milliseconds for the event loop to keep running.</param>
            <param name="forceRedraw">If true, window renders.</param>
        </member>
        <member name="P:Emgu.CV.Viz3d.WasStopped">
            <summary>
            Returns whether the event loop has been stopped.
            </summary>
        </member>
        <member name="M:Emgu.CV.Viz3d.SetBackgroundMeshLab">
            <summary>
            Set the background color
            </summary>
        </member>
        <member name="M:Emgu.CV.Viz3d.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Viz3d object
            </summary>
        </member>
        <member name="T:Emgu.CV.WArrow">
            <summary>
            This 3D Widget defines an arrow.
            </summary>
        </member>
        <member name="M:Emgu.CV.WArrow.#ctor(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f,System.Double,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs an WArrow.
            </summary>
            <param name="pt1">Start point of the arrow.</param>
            <param name="pt2">End point of the arrow.</param>
            <param name="thickness">Thickness of the arrow. Thickness of arrow head is also adjusted accordingly.</param>
            <param name="color">Color of the arrow.</param>
        </member>
        <member name="P:Emgu.CV.WArrow.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WArrow.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="M:Emgu.CV.WArrow.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WArrow object
            </summary>
        </member>
        <member name="T:Emgu.CV.WCircle">
            <summary>
            This 3D Widget defines a circle.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCircle.#ctor(System.Double,System.Double,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs default planar circle centred at origin with plane normal along z-axis.
            </summary>
            <param name="radius">Radius of the circle.</param>
            <param name="thickness">Thickness of the circle.</param>
            <param name="color">Color of the circle.</param>
        </member>
        <member name="M:Emgu.CV.WCircle.#ctor(System.Double,Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f,System.Double,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs repositioned planar circle.
            </summary>
            <param name="radius">Radius of the circle.</param>
            <param name="center">Center of the circle.</param>
            <param name="normal">Normal of the plane in which the circle lies.</param>
            <param name="thickness">Thickness of the circle.</param>
            <param name="color">Color of the circle.</param>
        </member>
        <member name="P:Emgu.CV.WCircle.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCircle.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="M:Emgu.CV.WCircle.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCircle object
            </summary>
        </member>
        <member name="T:Emgu.CV.WCloud">
            <summary>
            This 3D Widget defines a point cloud.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCloud.#ctor(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Constructs a WCloud.
            </summary>
            <param name="cloud">Set of points which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.</param>
            <param name="color">Set of colors. It has to be of the same size with cloud.</param>
        </member>
        <member name="M:Emgu.CV.WCloud.#ctor(Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs a WCloud.
            </summary>
            <param name="cloud">Set of points which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.</param>
            <param name="color">A single Color for the whole cloud.</param>
        </member>
        <member name="P:Emgu.CV.WCloud.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCloud.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="M:Emgu.CV.WCloud.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCloud
            </summary>
        </member>
        <member name="T:Emgu.CV.WCone">
            <summary>
            This 3D Widget defines a cone.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCone.#ctor(System.Double,System.Double,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs default cone oriented along x-axis with center of its base located at origin.
            </summary>
            <param name="length">Length of the cone.</param>
            <param name="radius">Radius of the cone.</param>
            <param name="resolution">Resolution of the cone.</param>
            <param name="color">Color of the cone.</param>
        </member>
        <member name="M:Emgu.CV.WCone.#ctor(System.Double,Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs repositioned planar cone.
            </summary>
            <param name="radius">Radius of the cone.</param>
            <param name="center">Center of the cone base.</param>
            <param name="tip">Tip of the cone.</param>
            <param name="resolution">Resolution of the cone.</param>
            <param name="color">Color of the cone.</param>
        </member>
        <member name="P:Emgu.CV.WCone.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCone.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="M:Emgu.CV.WCone.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCone object
            </summary>
        </member>
        <member name="T:Emgu.CV.WCoordinateSystem">
            <summary>
            This 3D Widget represents a coordinate system.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCoordinateSystem.#ctor(System.Double)">
            <summary>
            Constructs a WCoordinateSystem.
            </summary>
            <param name="scale">Determines the size of the axes.</param>
        </member>
        <member name="P:Emgu.CV.WCoordinateSystem.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCoordinateSystem.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="M:Emgu.CV.WCoordinateSystem.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCoordinateSysyem object
            </summary>
        </member>
        <member name="T:Emgu.CV.WCube">
            <summary>
            This 3D Widget defines a cube.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCube.#ctor(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f,System.Boolean,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs a WCube.
            </summary>
            <param name="minPoint">Specifies minimum point of the bounding box.</param>
            <param name="maxPoint">Specifies maximum point of the bounding box.</param>
            <param name="wireFrame">If true, cube is represented as wireframe.</param>
            <param name="color">Color of the cube.</param>
        </member>
        <member name="P:Emgu.CV.WCube.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCube.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="M:Emgu.CV.WCube.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCube object
            </summary>
        </member>
        <member name="T:Emgu.CV.WCylinder">
            <summary>
            This 3D Widget defines a cylinder.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCylinder.#ctor(Emgu.CV.Structure.MCvPoint3D64f@,Emgu.CV.Structure.MCvPoint3D64f,System.Double,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs a WCylinder.
            </summary>
            <param name="axisPoint1">A point1 on the axis of the cylinder.</param>
            <param name="axisPoint2">A point2 on the axis of the cylinder.</param>
            <param name="radius">Radius of the cylinder.</param>
            <param name="numsides">Resolution of the cylinder.</param>
            <param name="color">Color of the cylinder.</param>
        </member>
        <member name="P:Emgu.CV.WCylinder.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCylinder.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="M:Emgu.CV.WCylinder.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCylinder object
            </summary>
        </member>
        <member name="T:Emgu.CV.WText">
            <summary>
            This 2D Widget represents text overlay.
            </summary>
        </member>
        <member name="M:Emgu.CV.WText.#ctor(System.String,System.Drawing.Point,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs a WText.
            </summary>
            <param name="text">Text content of the widget.</param>
            <param name="pos">Position of the text.</param>
            <param name="fontSize">Font size.</param>
            <param name="color">Color of the text.</param>
        </member>
        <member name="P:Emgu.CV.WText.GetWidget2D">
            <summary>
            Get the pointer to the widget2D object
            </summary>
        </member>
        <member name="P:Emgu.CV.WText.GetWidget">
            <summary>
            Get the pointer to the widget object.
            </summary>
        </member>
        <member name="M:Emgu.CV.WText.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Viz3d object
            </summary>
        </member>
        <member name="T:Emgu.CV.PointCollection">
            <summary>
            A collection of points
            </summary>
        </member>
        <member name="M:Emgu.CV.PointCollection.EllipseLeastSquareFitting(System.Drawing.PointF[])">
            <summary>
            Fit an ellipse to the points collection
            </summary>
            <param name="points">The points to be fitted</param>
            <returns>An ellipse</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.PolyLine(System.Drawing.PointF[],System.Boolean)">
            <summary>
            convert a series of points to LineSegment2D
            </summary>
            <param name="points">the array of points</param>
            <param name="closed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <returns>array of LineSegment2D</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.PolyLine(System.Drawing.Point[],System.Boolean)">
            <summary>
            convert a series of System.Drawing.Point to LineSegment2D
            </summary>
            <param name="points">the array of points</param>
            <param name="closed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <returns>array of LineSegment2D</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.BoundingRectangle(System.Drawing.PointF[])">
            <summary>
            Find the bounding rectangle for the specific array of points
            </summary>
            <param name="points">The collection of points</param>
            <returns>The bounding rectangle for the array of points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.ReprojectImageTo3D(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Re-project pixels on a 1-channel disparity map to array of 3D points.
            </summary>
            <param name="disparity">Disparity map</param>
            <param name="Q">The re-projection 4x4 matrix, can be arbitrary, e.g. the one, computed by cvStereoRectify</param>
            <returns>The reprojected 3D points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.GeneratePointCloud(Emgu.CV.Structure.Ellipse,System.Int32)">
            <summary>
            Generate a random point cloud around the ellipse. 
            </summary>
            <param name="e">The region where the point cloud will be generated. The axes of e corresponds to std of the random point cloud.</param>
            <param name="numberOfPoints">The number of points to be generated</param>
            <returns>A random point cloud around the ellipse</returns>
        </member>
        <member name="T:Emgu.CV.IBackgroundSubtractor">
            <summary>
            Interface to the BackgroundSubtractor class
            </summary>
        </member>
        <member name="P:Emgu.CV.IBackgroundSubtractor.BackgroundSubtractorPtr">
            <summary>
            Pointer to the native BackgroundSubstractor object
            </summary>
        </member>
        <member name="T:Emgu.CV.BackgroundSubtractorExtension">
            <summary>
            A static class that provide extension methods to backgroundSubtractor
            </summary>
        </member>
        <member name="M:Emgu.CV.BackgroundSubtractorExtension.Apply(Emgu.CV.IBackgroundSubtractor,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Update the background model
            </summary>
            <param name="image">The image that is used to update the background model</param>
            <param name="learningRate">Use -1 for default</param>
            <param name="subtractor">The background subtractor</param>
            <param name="fgMask">The output foreground mask</param>
        </member>
        <member name="M:Emgu.CV.BackgroundSubtractorExtension.GetBackgroundImage(Emgu.CV.IBackgroundSubtractor,Emgu.CV.IOutputArray)">
            <summary>
            Computes a background image.
            </summary>
            <param name="backgroundImage">The output background image</param>
            <param name="subtractor">The background subtractor</param>
            <remarks> Sometimes the background image can be very blurry, as it contain the average background statistics.</remarks>
        </member>
        <member name="T:Emgu.CV.BackgroundSubtractorKNN">
            <summary>
            K-nearest neighbors - based Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorKNN.AlgorithmPtr">
            <summary>
            Pointer to the unmanaged Algorithm object
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorKNN.BackgroundSubtractorPtr">
            <summary>
            Pointer to the unmanaged BackgroundSubtractor object
            </summary>
        </member>
        <member name="M:Emgu.CV.BackgroundSubtractorKNN.#ctor(System.Int32,System.Double,System.Boolean)">
            <summary>
            Create a K-nearest neighbors - based Background/Foreground Segmentation Algorithm.
            </summary>
            <param name="history">Length of the history.</param>
            <param name="dist2Threshold">Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update.</param>
            <param name="detectShadows">If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false.</param>
        </member>
        <member name="M:Emgu.CV.BackgroundSubtractorKNN.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this background model.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorKNN.History">
            <summary>
            The number of last frames that affect the background model
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorKNN.NSamples">
            <summary>
            The number of data samples in the background model
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorKNN.Dist2Threshold">
            <summary>
            The threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to a data sample.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorKNN.KNNSamples">
            <summary>
            The number of neighbours, the k in the kNN. K is the number of samples that need to be within dist2Threshold in order to decide that pixel is matching the kNN background model.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorKNN.DetectShadows">
            <summary>
            If true, the algorithm detects shadows and marks them.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorKNN.ShadowValue">
            <summary>
            Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0 in the mask always means background, 255 means foreground.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorKNN.ShadowThreshold">
            <summary>
            A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel is more than twice darker then it is not shadow.
            </summary>
        </member>
        <member name="T:Emgu.CV.BackgroundSubtractorMOG2">
            <summary>
            The class implements the following algorithm:
            "Improved adaptive Gaussian mixture model for background subtraction"
            Z.Zivkovic
            International Conference Pattern Recognition, UK, August, 2004.
            http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.AlgorithmPtr">
            <summary>
            Pointer to the unmanaged Algorithm object
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.BackgroundSubtractorPtr">
            <summary>
            Pointer to the unmanaged BackgroundSubtractor object
            </summary>
        </member>
        <member name="M:Emgu.CV.BackgroundSubtractorMOG2.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            Create an "Improved adaptive Gaussian mixture model for background subtraction".
            </summary>
            <param name="history">The length of the history.</param>
            <param name="varThreshold">The maximum allowed number of mixture components. Actual number is determined dynamically per pixel.</param>
            <param name="shadowDetection">If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false.</param>
        </member>
        <member name="M:Emgu.CV.BackgroundSubtractorMOG2.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this background model.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.History">
            <summary>
            The number of last frames that affect the background model
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.DetectShadows">
            <summary>
            If true, the algorithm detects shadows and marks them.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.ShadowValue">
            <summary>
            Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0 in the mask always means background, 255 means foreground.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.ShadowThreshold">
            <summary>
            A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel is more than twice darker then it is not shadow.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.NMixtures">
            <summary>
            The number of gaussian components in the background model
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.BackgroundRatio">
            <summary>
            If a foreground pixel keeps semi-constant value for about backgroundRatio * history frames, it's considered background and added to the model as a center of a new component. It corresponds to TB parameter in the paper.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.VarThreshold">
            <summary>
            The main threshold on the squared Mahalanobis distance to decide if the sample is well described by the background model or not. Related to Cthr from the paper.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.VarThresholdGen">
            <summary>
            The variance threshold for the pixel-model match used for new mixture component generation. Threshold for the squared Mahalanobis distance that helps decide when a sample is close to the existing components (corresponds to Tg in the paper). If a pixel is not close to any component, it is considered foreground or added as a new component. 3 sigma =%gt
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.VarInit">
            <summary>
            Tg=3*3=9 is default. A smaller Tg value generates more components. A higher Tg value may result in a small number of components but they can grow too large.
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.VarMin">
            <summary>
            The initial variance of each gaussian component
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.VarMax">
            <summary>
            The minimum variance
            </summary>
        </member>
        <member name="P:Emgu.CV.BackgroundSubtractorMOG2.ComplexityReductionThreshold">
            <summary>
            The maximum variance
            </summary>
        </member>
        <member name="T:Emgu.CV.IDenseOpticalFlow">
            <summary>
            Dense Optical flow
            </summary>
        </member>
        <member name="P:Emgu.CV.IDenseOpticalFlow.DenseOpticalFlowPtr">
            <summary>
            Gets the dense optical flow pointer.
            </summary>
            <value>
            The dense optical flow .
            </value>
        </member>
        <member name="T:Emgu.CV.DenseOpticalFlowExtensions">
            <summary>
            Extension methods for IDenseOpticalFlow
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseOpticalFlowExtensions.Calc(Emgu.CV.IDenseOpticalFlow,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray)">
            <summary>
            Calculates an optical flow.
            </summary>
            <param name="i0">First 8-bit single-channel input image.</param>
            <param name="i1">Second input image of the same size and the same type as prev.</param>
            <param name="flow">Computed flow image that has the same size as prev and type CV_32FC2 </param>
            <param name="opticalFlow">The dense optical flow object</param>
        </member>
        <member name="T:Emgu.CV.DISOpticalFlow">
            <summary>
            DIS optical flow algorithm.
            This class implements the Dense Inverse Search(DIS) optical flow algorithm.Includes three presets with preselected parameters to provide reasonable trade-off between speed and quality.However, even the slowest preset is still relatively fast, use DeepFlow if you need better quality and don't care about speed.
            More details about the algorithm can be found at:
            Till Kroeger, Radu Timofte, Dengxin Dai, and Luc Van Gool. Fast optical flow using dense inverse search. In Proceedings of the European Conference on Computer Vision (ECCV), 2016.
            </summary>
        </member>
        <member name="T:Emgu.CV.DISOpticalFlow.Preset">
            <summary>
            Preset
            </summary>
        </member>
        <member name="F:Emgu.CV.DISOpticalFlow.Preset.UltraFast">
            <summary>
            Ultra fast
            </summary>
        </member>
        <member name="F:Emgu.CV.DISOpticalFlow.Preset.Fast">
            <summary>
            Fast
            </summary>
        </member>
        <member name="F:Emgu.CV.DISOpticalFlow.Preset.Medium">
            <summary>
            Medium
            </summary>
        </member>
        <member name="M:Emgu.CV.DISOpticalFlow.#ctor(Emgu.CV.DISOpticalFlow.Preset)">
            <summary>
            Create an instance of DIS optical flow algorithm.
            </summary>
            <param name="preset">Algorithm preset</param>
        </member>
        <member name="M:Emgu.CV.DISOpticalFlow.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Optical flow algorithm.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.AlgorithmPtr">
            <summary>
            Pointer to cv::Algorithm
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.DenseOpticalFlowPtr">
            <summary>
            Pointer to native cv::DenseOpticalFlow
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.FinestScale">
            <summary>
            Finest level of the Gaussian pyramid on which the flow is computed (zero level corresponds to the original image resolution). The final flow is obtained by bilinear upscaling.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.PatchSize">
            <summary>
            Size of an image patch for matching (in pixels). Normally, default 8x8 patches work well enough in most cases.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.PatchStride">
            <summary>
            Stride between neighbor patches. Must be less than patch size. Lower values correspond to higher flow quality.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.GradientDescentIterations">
            <summary>
            Maximum number of gradient descent iterations in the patch inverse search stage. Higher values may improve quality in some cases.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.VariationalRefinementIterations">
            <summary>
            Number of fixed point iterations of variational refinement per scale. Set to zero to disable variational refinement completely. Higher values will typically result in more smooth and high-quality flow.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.VariationalRefinementAlpha">
            <summary>
            Weight of the smoothness term
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.VariationalRefinementDelta">
            <summary>
            Weight of the color constancy term
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.VariationalRefinementGamma">
            <summary>
            Weight of the gradient constancy term
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.UseMeanNormalization">
            <summary>
            Whether to use mean-normalization of patches when computing patch distance. It is turned on by default as it typically provides a noticeable quality boost because of increased robustness to illumination variations. Turn it off if you are certain that your sequence doesn't contain any changes in illumination.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.UseSpatialPropagation">
            <summary>
            Whether to use spatial propagation of good optical flow vectors. This option is turned on by default, as it tends to work better on average and can sometimes help recover from major errors introduced by the coarse-to-fine scheme employed by the DIS optical flow algorithm. Turning this option off can make the output flow field a bit smoother, however.
            </summary>
        </member>
        <member name="T:Emgu.CV.FarnebackOpticalFlow">
            <summary>
            Class computing a dense optical flow using the Gunnar Farneback's algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.FarnebackOpticalFlow.#ctor(System.Int32,System.Double,System.Boolean,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.OpticalflowFarnebackFlag)">
            <summary>
            Create a FarnebackOpticalFlow object
            </summary>
            <param name="pyrScale">Specifies the image scale (!1) to build the pyramids for each image. pyrScale=0.5 means the classical pyramid, where each next layer is twice smaller than the previous</param>
            <param name="numLevels">The number of pyramid layers, including the initial image. levels=1 means that no extra layers are created and only the original images are used</param>
            <param name="winSize">The averaging window size; The larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field</param>
            <param name="numIters">The number of iterations the algorithm does at each pyramid level</param>
            <param name="polyN">Size of the pixel neighborhood used to find polynomial expansion in each pixel. The larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field. Typically, poly n=5 or 7</param>
            <param name="polySigma">Standard deviation of the Gaussian that is used to smooth derivatives that are used as a basis for the polynomial expansion. For poly n=5 you can set poly sigma=1.1, for poly n=7 a good value would be poly sigma=1.5</param>
            <param name="flags">The operation flags</param>
            <param name="fastPyramids">Fast Pyramids</param>
        </member>
        <member name="M:Emgu.CV.FarnebackOpticalFlow.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.FarnebackOpticalFlow.DenseOpticalFlowPtr">
            <summary>
            Gets the dense optical flow pointer.
            </summary>
            <value>
            The pointer to the dense optical flow object.
            </value>
        </member>
        <member name="P:Emgu.CV.FarnebackOpticalFlow.AlgorithmPtr">
            <summary>
            Return the pointer to the algorithm object
            </summary>
        </member>
        <member name="T:Emgu.CV.KalmanFilter">
            <summary>
            The class implements a standard Kalman filter. However, you can modify transitionMatrix, controlMatrix, and measurementMatrix to get
            an extended Kalman filter functionality.
            </summary>
        </member>
        <member name="M:Emgu.CV.KalmanFilter.#ctor(System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.KalmanFilter"/> class.
            </summary>
            <param name="dynamParams">Dimensionality of the state.</param>
            <param name="measureParams">Dimensionality of the measurement.</param>
            <param name="controlParams">Dimensionality of the control vector.</param>
            <param name="type">Type of the created matrices that should be Cv32F or Cv64F</param>
        </member>
        <member name="M:Emgu.CV.KalmanFilter.Predict(Emgu.CV.Mat)">
            <summary>
            Perform the predict operation using the option control input
            </summary>
            <param name="control">The control.</param>
            <returns>The predicted state. </returns>
        </member>
        <member name="M:Emgu.CV.KalmanFilter.Correct(Emgu.CV.Mat)">
            <summary>
            Updates the predicted state from the measurement.
            </summary>
            <param name="measurement">The measured system parameters</param>
            <returns>The updated predicted state</returns>
        </member>
        <member name="M:Emgu.CV.KalmanFilter.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.StatePre">
            <summary>
            Predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.StatePost">
            <summary>
            Corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.TransitionMatrix">
            <summary>
            State transition matrix (A)
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.ControlMatrix">
            <summary>
            Control matrix (B) (not used if there is no control)
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.MeasurementMatrix">
            <summary>
            Measurement matrix (H)
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.ProcessNoiseCov">
            <summary>
            Process noise covariance matrix (Q)
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.MeasurementNoiseCov">
            <summary>
            Measurement noise covariance matrix (R)
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.ErrorCovPre">
            <summary>
            priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.Gain">
            <summary>
            Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)
            </summary>
            <returns>The result</returns>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.ErrorCovPost">
            <summary>
            posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)
            </summary>
            <returns>The result</returns>
        </member>
        <member name="T:Emgu.CV.ISparseOpticalFlow">
            <summary>
            Sparse Optical flow
            </summary>
        </member>
        <member name="P:Emgu.CV.ISparseOpticalFlow.SparseOpticalFlowPtr">
            <summary>
            Gets the sparse optical flow pointer.
            </summary>
            <value>
            The sparse optical flow .
            </value>
        </member>
        <member name="T:Emgu.CV.SparseOpticalFlowExtensions">
            <summary>
            Extension methods for ISparseOpticalFlow
            </summary>
        </member>
        <member name="M:Emgu.CV.SparseOpticalFlowExtensions.Calc(Emgu.CV.ISparseOpticalFlow,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates a sparse optical flow.
            </summary>
            <param name="opticalFlow">The sparse optical flow</param>
            <param name="prevImg">First input image.</param>
            <param name="nextImg">Second input image of the same size and the same type as prevImg.</param>
            <param name="prevPts">Vector of 2D points for which the flow needs to be found.</param>
            <param name="nextPts">Output vector of 2D points containing the calculated new positions of input features in the second image.</param>
            <param name="status">Output status vector. Each element of the vector is set to 1 if the flow for the corresponding features has been found.Otherwise, it is set to 0.</param>
            <param name="error">Optional output vector that contains error response for each point (inverse confidence).</param>
        </member>
        <member name="T:Emgu.CV.SparsePyrLKOpticalFlow">
            <summary>
            The class can calculate an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.
            </summary>
        </member>
        <member name="M:Emgu.CV.SparsePyrLKOpticalFlow.#ctor(System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.CvEnum.LKFlowFlag,System.Double)">
            <summary>
            Create a SparsePyrLKOpticalFlow object
            </summary>
            <param name="winSize">size of the search window at each pyramid level.</param>
            <param name="maxLevel">0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel.</param>
            <param name="crit">specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon.</param>
            <param name="flags">operation flags</param>
            <param name="minEigThreshold">the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations, divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost.</param>
        </member>
        <member name="M:Emgu.CV.SparsePyrLKOpticalFlow.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.SparsePyrLKOpticalFlow.SparseOpticalFlowPtr">
            <summary>
            Pointer to the unmanaged SparseOpticalFlow object
            </summary>
        </member>
        <member name="P:Emgu.CV.SparsePyrLKOpticalFlow.AlgorithmPtr">
            <summary>
            Return the pointer to the algorithm object
            </summary>
        </member>
        <member name="T:Emgu.CV.Tracker">
            <summary>
            Long-term tracker
            </summary>
        </member>
        <member name="F:Emgu.CV.Tracker._trackerPtr">
            <summary>
            The native pointer to the tracker
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracker.Init(Emgu.CV.IInputArray,System.Drawing.Rectangle)">
            <summary>
            Initialize the tracker with a know bounding box that surrounding the target.
            </summary>
            <param name="image">The initial frame</param>
            <param name="boundingBox">The initial bounding box</param>
        </member>
        <member name="M:Emgu.CV.Tracker.Update(Emgu.CV.IInputArray,System.Drawing.Rectangle@)">
            <summary>
            Update the tracker, find the new most likely bounding box for the target.
            </summary>
            <param name="image">The current frame</param>
            <param name="boundingBox">The bounding box that represent the new target location, if true was returned, not modified otherwise</param>
            <returns>True means that target was located and false means that tracker cannot locate target in current frame. Note, that latter does not imply that tracker has failed, maybe target is indeed missing from the frame (say, out of sight)</returns>
        </member>
        <member name="M:Emgu.CV.Tracker.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this tracker
            </summary>
        </member>
        <member name="T:Emgu.CV.TrackerDaSiamRPN">
            <summary>
            TrackerDaSiamRPN
            </summary>
        </member>
        <member name="M:Emgu.CV.TrackerDaSiamRPN.#ctor(System.String,System.String,System.String,Emgu.CV.Dnn.Backend,Emgu.CV.Dnn.Target)">
            <summary>
            Create a new TrackerDaSiamRPN
            </summary>
            <param name="model">The model file</param>
            <param name="kernelCls1">The kernelCls1 file</param>
            <param name="kernelR1">The kernelR1 file</param>
            <param name="backend">The preferred DNN backend</param>
            <param name="target">The preferred DNN target</param>
        </member>
        <member name="M:Emgu.CV.TrackerDaSiamRPN.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this tracker
            </summary>
        </member>
        <member name="P:Emgu.CV.TrackerDaSiamRPN.TrackingScore">
            <summary>
            Tracking score
            </summary>
        </member>
        <member name="T:Emgu.CV.TrackerGOTURN">
            <summary>
            GOTURN is kind of trackers based on Convolutional Neural Networks (CNN). While taking all advantages of CNN trackers, GOTURN is much faster due to offline training without online fine-tuning nature. GOTURN tracker addresses the problem of single target tracking: given a bounding box label of an object in the first frame of the video, we track that object through the rest of the video. NOTE: Current method of GOTURN does not handle occlusions; however, it is fairly robust to viewpoint changes, lighting changes, and deformations. Inputs of GOTURN are two RGB patches representing Target and Search patches resized to 227x227. Outputs of GOTURN are predicted bounding box coordinates, relative to Search patch coordinate system, in format X1,Y1,X2,Y2.
            </summary>
            <remarks>Original paper is here: http://davheld.github.io/GOTURN/GOTURN.pdf As long as original authors implementation: https://github.com/davheld/GOTURN#train-the-tracker Implementation of training algorithm is placed in separately here due to 3d-party dependencies: https://github.com/Auron-X/GOTURN_Training_Toolkit GOTURN architecture goturn.prototxt and trained model goturn.caffemodel are accessible on opencv_extra GitHub repository.</remarks>
        </member>
        <member name="M:Emgu.CV.TrackerGOTURN.#ctor">
            <summary>
            Create a GOTURN tracker
            </summary>
        </member>
        <member name="M:Emgu.CV.TrackerGOTURN.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this tracker
            </summary>
        </member>
        <member name="T:Emgu.CV.TrackerMIL">
            <summary>
            The MIL algorithm trains a classifier in an online manner to separate the object from the background.
            Multiple Instance Learning avoids the drift problem for a robust tracking.
            Original code can be found here http://vision.ucsd.edu/~bbabenko/project_miltrack.shtml
            </summary>
        </member>
        <member name="M:Emgu.CV.TrackerMIL.#ctor(System.Single,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a MIL Tracker
            </summary>
            <param name="samplerInitInRadius">radius for gathering positive instances during init</param>
            <param name="samplerInitMaxNegNum">negative samples to use during init</param>
            <param name="samplerSearchWinSize">size of search window</param>
            <param name="samplerTrackInRadius">radius for gathering positive instances during tracking</param>
            <param name="samplerTrackMaxPosNum">positive samples to use during tracking</param>
            <param name="samplerTrackMaxNegNum">negative samples to use during tracking</param>
            <param name="featureSetNumFeatures">features</param>
        </member>
        <member name="M:Emgu.CV.TrackerMIL.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this tracker
            </summary>
        </member>
        <member name="T:Emgu.CV.TrackerNano">
            <summary>
            The Nano tracker is a super lightweight dnn-based general object tracking.
            Nano tracker is much faster and extremely lightweight due to special model structure, the whole model size is about 1.9 MB. Nano tracker needs two models: one for feature extraction (backbone) and the another for localization (neckhead).
            </summary>
        </member>
        <member name="M:Emgu.CV.TrackerNano.#ctor(System.String,System.String,Emgu.CV.Dnn.Backend,Emgu.CV.Dnn.Target)">
            <summary>
            Create a Nano tracker
            </summary>
            <param name="backbone">Path to the model for feature extraction. Model download link: https://github.com/HonglinChu/SiamTrackers/tree/master/NanoTrack/models/nanotrackv2</param>
            <param name="neckhead">Path to the model for localization. Model download link: https://github.com/HonglinChu/SiamTrackers/tree/master/NanoTrack/models/nanotrackv2</param>
            <param name="backend">The preferred DNN backend</param>
            <param name="target">The preferred DNN target</param>
        </member>
        <member name="M:Emgu.CV.TrackerNano.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this tracker
            </summary>
        </member>
        <member name="T:Emgu.CV.VariationalRefinement">
            <summary>
            This class implements variational refinement of the input flow field.
            </summary>
            <remarks>See: Thomas Brox, Andres Bruhn, Nils Papenberg, and Joachim Weickert. High accuracy optical flow estimation based on a theory for warping. In Computer Vision-ECCV 2004, pages 25-36. Springer, 2004.</remarks>
        </member>
        <member name="M:Emgu.CV.VariationalRefinement.#ctor">
            <summary>
            Create an instance of Variational Refinement.
            </summary>
        </member>
        <member name="M:Emgu.CV.VariationalRefinement.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Optical flow algorithm.
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.AlgorithmPtr">
            <summary>
            Pointer to the unmanaged cv::Algorithm
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.DenseOpticalFlowPtr">
            <summary>
            Pointer to the unmanaged cv::DenseOpticalFlow
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.FixedPointIterations">
            <summary>
            Number of outer (fixed-point) iterations in the minimization procedure.
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.SorIterations">
            <summary>
            Number of inner successive over-relaxation (SOR) iterations in the minimization procedure to solve the respective linear system.
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.Omega">
            <summary>
            Relaxation factor in SOR
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.Alpha">
            <summary>
            Weight of the smoothness term
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.Delta">
            <summary>
            Weight of the color constancy term
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.Gamma">
            <summary>
            Weight of the gradient constancy term
            </summary>
        </member>
        <member name="T:Emgu.CV.DenseRLOFOpticalFlow">
            <summary>
            Fast dense optical flow computation based on robust local optical flow (RLOF) algorithms and sparse-to-dense interpolation scheme.
            </summary>
        </member>
        <member name="T:Emgu.CV.DenseRLOFOpticalFlow.InterpolationType">
            <summary>
            Interpolation type used to compute the dense optical flow.
            </summary>
        </member>
        <member name="F:Emgu.CV.DenseRLOFOpticalFlow.InterpolationType.Geo">
            <summary>
            Fast geodesic interpolation
            </summary>
        </member>
        <member name="F:Emgu.CV.DenseRLOFOpticalFlow.InterpolationType.Epic">
            <summary>
            Edge-preserving interpolation
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseRLOFOpticalFlow.#ctor(Emgu.CV.RLOFOpticalFlowParameter,System.Single,System.Drawing.Size,Emgu.CV.DenseRLOFOpticalFlow.InterpolationType,System.Int32,System.Single,System.Single,System.Boolean,System.Single,System.Single)">
            <summary>
            Creates instance of DenseRLOFOpticalFlow
            </summary>
            <param name="parameter">The RLOF optical flow parameters</param>
            <param name="forwardBackwardThreshold">Threshold for the forward backward confidence check. Use 1.0f for default</param>
            <param name="gridStep">Size of the grid to spawn the motion vectors. Use (6, 6) for default</param>
            <param name="interpType">Interpolation used to compute the dense optical flow.</param>
            <param name="epicK">See Ximgproc.EdgeAwareInterpolator() K value.</param>
            <param name="epicSigma">See Ximgproc.EdgeAwareInterpolator() sigma value.</param>
            <param name="epicLambda">See Ximgproc.EdgeAwareInterpolator() lambda value.</param>
            <param name="usePostProc">Enables Ximgproc.fastGlobalSmootherFilter</param>
            <param name="fgsLambda">See Ximgproc.EdgeAwareInterpolator().</param>
            <param name="fgsSigma">See Ximgproc.EdgeAwareInterpolator().</param>
        </member>
        <member name="M:Emgu.CV.DenseRLOFOpticalFlow.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.DenseRLOFOpticalFlow.DenseOpticalFlowPtr">
            <summary>
            Gets the dense optical flow pointer.
            </summary>
            <value>
            The pointer to the dense optical flow object.
            </value>
        </member>
        <member name="P:Emgu.CV.DenseRLOFOpticalFlow.AlgorithmPtr">
            <summary>
            Return the pointer to the algorithm object
            </summary>
        </member>
        <member name="T:Emgu.CV.DualTVL1OpticalFlow">
            <summary>
            Dual TV L1 Optical Flow Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.DualTVL1OpticalFlow.#ctor">
            <summary>
            Create Dual TV L1 Optical Flow.
            </summary>
        </member>
        <member name="M:Emgu.CV.DualTVL1OpticalFlow.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.DenseOpticalFlowPtr">
            <summary>
            Gets the dense optical flow pointer.
            </summary>
            <value>
            The pointer to the dense optical flow object.
            </value>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.AlgorithmPtr">
            <summary>
            Return the pointer to the algorithm object
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.Tau">
            <summary>
            Time step of the numerical scheme
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.Lambda">
            <summary>
            Weight parameter for the data term, attachment parameter
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.Theta">
            <summary>
            Weight parameter for (u - v)^2, tightness parameter
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.Gamma">
            <summary>
            Coefficient for additional illumination variation term
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.ScalesNumber">
            <summary>
            Number of scales used to create the pyramid of images
            </summ